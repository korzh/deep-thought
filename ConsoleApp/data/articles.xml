<Articles>
  <Article id="000a2925-f4be-41ed-96c4-5e3505cc9f4a" title="Lookup fields and columns">
    <Content>## Problem
Consider a situation when you have two linked tables in your DB. The first table has a column which actually holds only the code of value stored in the second table.
For example, you have `Customers` with `CityID` column linked to `Cities` table which has two columns: `ID` and `Name`.

Obviously, you would like to show the name (not the code) of the city in your result set when it's necessary. 
In the same time, you would prefer to filter by city ID if it's possible - to prevent extra join to `Cities` table. It would be good also to allow your users to select the city from the list when they add such condition to query instead of making them enter city code or name "manually". 

## Solution
Here are the instructions how to deal with such situation in EasyQuery:

1) Let's guess you have already created your model and you have `Customer` entity with `CityID` attribute there.

2) To achieve our first goal (to make it possible to show city name in results), you can add `City` (or `City name`) attribute into `Customer` entity, and that new attribute should point to `Name` field of `Cities` table.
If you created a model from your DB, you possibly already have `City(s)` entity and `Name` attribute in it. So you can only move that `Name` attribute into `Customer` entity.

Additionally you need to turn off `Use in conditions` option (`attr.UseInCondition = false` if do it from code) - so it can be used in ColumnsPanel only.

3) Now you need to make it possible to filter by city ID in query conditions. Simply rename `CityID` attribute to just `City`, turn off its `Use in result` option (so it will not be able to use it as result column) and setup `SQL LIST` value editor for this attribute to show the list of all cities when this attribute is used in a query condition (you can read more about [value editors here](https://korzh.com/easyquery/docs/fundamentals/about-data-editors)). 
 
So, now your users will be able to add conditions with `City` attribute and select a concrete city (by its name) from the drop-down list. In query panel such conditions will look like `Customer City is equal to London` but in result SQL it will be something like: `Customers.CityID = 234`

4) So far, so good. The only problem that may remain with such approach - is that EntitiesPanel will show you (and your users) two attributes named `City` under `Customer` entity. 

To fix this - you use `Lookup Attribute` field and simply link these two attributes to each other.
After that EntitiesPanel will show only one item named `City` but it will know what attribute to add if you add that item into Columns or into Conditions panel.
</Content>
    <Tags>,data-model,tables,database,lookup-attribute,</Tags>
  </Article>
  <Article id="00e50a7d-106c-4ffc-b4b2-d43ba1f60f4d" title="How it works">
    <Content>![EasyQuery scheme](/files/test/easyquery-dotnet/images/eq-lib-schema.png)

 The above scheme shows the general internal structure of the library and the main principles of its work.

## EasyQuery components

All EasyQuery classes and components can be divided into two main parts:

* logical part (DataModel, Query, SqlQueryBuilder).
* the visual part (QueryPanel, ColumnsPanel, etc.).

The logical part is responsible for the internal representation of data structures and user queries, as well as for the generation of SQL statements (or statements in other query languages like LINQ).
The visual part contains components that provide a user interface (UI) to manage query conditions (QueryPanel) and the result columns (ColumnsPanel), as well as some other useful components.

## Data Model

It is necessary to emphasize that the EasyQuery components do not work with the database directly. All the information about the structure of the data is contained in a special repository called “data model”. We'll review it in details later, and now it’s enough to say that data model is, in fact, the representation of the data in a convenient form for the end users.

Regarding EasyQuery data model - is an object of DataModel class (or inherited from it such as DbModel). Typically, the data model is stored in an XML file that is loaded at program start. But it’s not a necessity - the model can be stored in the database (just as a string in XML format) or can be created "on the fly" directly in the program. More on this - also in a special section devoted to DataModel.

## Common scenario

Now let’s take a closer look how EasyQuery components work in your application.

We assume that your application contains some (page) where users can search for data with the help of EasyQuery visual components (widgets) and then view the results of this search in a convenient way (grid, chart, report, etc.).

As we can see from the scheme above, visual components (such as QueryPanel or ColumnsPanel) takes all necessary information about the available search attributes and operations from the DataModel object.
The internal representation of the query - is stored in the Query object.

So, a typical scenario, in this case, can be the following:

* The user specifies the search criteria and the columns he/she wants to see in result using visual EasyQuery components (QueryPanel, ColumnsPanel, and others).
* Any such modification in visual controls automatically changes the internal representation of the query stored inside Query object.
* When the user is ready to get the result of their query (for example, he/she pressed the Search button ) the application uses SqlQueryBuilder object to generate an SQL statement based on the current contents of the Query.
* The generated SQL query is executed and the results of this execution are shown in some grid, chart, report, diagram, etc.

Instead of SqlQueryBuilder, we can use some other classes to generate different types of queries (for example, LinqQueryBuilder can be used to create LINQ queries).

It is necessary to emphasize that EasyQuery components do not communicate with your database directly. They only provide a convenient UI to build the query and generate SQL (or LINQ) expression based on user input. Thus, you do not have to specifically change something in the already existing code that works with the data. EasyQuery will work well with your current connection and visual components that are involved in data visualization.

As we can see from the described scenario, all the information about the data structure is obtained from the data model (through a DataModel object). In the next section will talk about data model more in details: what is it, why we need it and the different ways of its creation.</Content>
    <Tags>,data-model,database,connection,widgets,controls,query-builder,</Tags>
  </Article>
  <Article id="01362df6-7520-4e6e-9b89-7fc3a9633e68" title="User-friendly name for tables">
    <Content>When users build queries with EasyQuery UI, they do not work with tables and fields. Instead, they work with “entities” and their “attributes”. Each entity represents some object from the real word, e.g., “Customer” or “Order”. Entity attribute is some property of such objects for example “Order date” or “Customer's first name”.

All entities and attributes are described in data model which can be created and then modified using **Data Model Editor**. Entity attributes usually correspond to some fields, but it is not obligatory since you can define “virtual attribute” which is represented by some expression.

For example attribute “Full customer name” can be described as *“Customer.FirstName + ' ' + Customer.LastName”*. Both entities and attributes have Caption property which is shown to a user when he/she defines conditions in QueryPanel control or columns in QueryColumnsPanel control. So it can be considered as that “user-friendly name” you asked for.
</Content>
    <Tags>,data-model,entity-framework,attributes,ui,connection,tables,fields,</Tags>
  </Article>
  <Article id="0310de96-f2c7-4df2-b0f5-2b993b381a52" title="Query with subquery">
    <Content>Sometimes the query conditions are so complex that you can’t express them using plain WHERE clause with AND, OR and NOT. In this case, you need to use subqueries.

For instance, let’s calculate **total lifetime count of paid orders for those countries that have at least one paid order made in September of 2012**.

Expected SQL:

```sql
SELECT Cust.Country AS [Customer Country], COUNT(Ord.OrderID) AS [Order OrderID Count] 
FROM (Customers AS Cust
  RIGHT OUTER JOIN Orders AS Ord ON (Ord.CustomerID = Cust.CustomerID ))
WHERE
(
  Cust.Country IN
  (SELECT CustSQ1.Country 
  FROM (Customers AS CustSQ1
  RIGHT OUTER JOIN Orders AS OrdSQ1 ON (OrdSQ1.CustomerID = CustSQ1.CustomerID ))
  WHERE
  (
  OrdSQ1.OrderDate BETWEEN #2012-09-01# AND #2012-09-30# 
  AND OrdSQ1.Paid = true
  )
  ) 
  AND Ord.Paid = true
)
GROUP BY Cust.Country
```

Here “those countries that have at least one paid order made in September of 2012” condition is implemented as a subquery.

First, add columns - click on “[Add column]” link, select “Customer | Country” menu item, then - [Add column] -&gt; “Order | OrderID”.
Now aggregate the OrderID column - click the Function button on the right side of the column and select “Count” menu item.

Add a condition with a subquery. Click “Add condition”, select “Customer | Country” from menu. Then change the operator - click on “is equal to” link and select “in subquery”. Then click “Edit sub query” link.

The subquery editing dialog appears.

You need to select the single attribute of the same type as our “Customer | Country” attribute.

The “Conditions” area have the same user interface as regular EasyQuery. Here you add the following conditions:

“Order | Date” -&gt; select “custom period” operator -&gt; set start and end date via date picker

“Order | Paid” -&gt; select “is true”.

Click “OK” button to submit the sub-query.

At last, add “Order | Paid is true” condition to the main query.

![Query with subquery](/files/test/easyquery-dotnet/images/subquery.gif)</Content>
    <Tags>,query-example,subquery,sql,code-sample,</Tags>
  </Article>
  <Article id="044a1162-ceed-4391-aaa6-cba2e13e7d15" title="ColumnAliasesUsage class">
    <Content>```csharp
public enum Korzh.EasyQuery.ColumnAliasesUsage
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | Never |  | 
| `1` | IfNecessary |  | 
| `2` | Always |  | 


</Content>
    <Tags />
  </Article>
  <Article id="06076ce8-c8b0-4503-a278-ed5ae5f81f64" title="TimeMacro class">
    <Content>```csharp
public class Korzh.EasyQuery.TimeMacro
    : IMacroValue

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Int32` | Count |  | 
| `DataType` | DataType |  | 
| `String` | ID |  | 
| `String` | Value |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | GetValue(`Int32` index) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="06e1c3e3-ba94-4d50-8de6-4f62c27f3e44" title="Terminology">
    <Content>## Common terms

* **Database** - may refer to any data storage but in most cases we mean some relational database such as MS SQL Server, My SQL, Oracle, etc.
* **Result set** - a result of some search request (query). Usually, is presented as tabular data.
* **Query** - a search request.
* **Query condition** - one of the search terms (for example: "Customer name starts with 'A'"). Any condition consists of some entity attribute ("Customer name"), operator ("starts with", "less than", etc) and one or more values ( "A", "John", "1001", "24 Aug 1991", etc).
* **Query column** - a column in result table we get after executing the query.
* **Database table** - one of the tables of some relational database.
* **AJAX request** - an asynchronous HTTP request which is sent from web page to server to get or transfer some data without reloading the entire web page. In a case of EasyQuery.JS, all visual widgets (such as QueryPanel, ColumnsPanel, and EntitiesPanel) send AJAX requests to get data model, to synchronize or to execute a current query and to get the result set.
* **Widget** - an element of the user interface (UI) on a web page that displays the current status of some object (e.g. Query) and allows to perform a set of operations with it.

## EasyQuery related terms

All following conditions might have other meaning, but here we talk about them in a context of EasyQuery products.

* **Data model** - a special repository for database structure, which presents data in more convenient for the end user form. Instead of tables and fields (as we see it in any relational database) data model has a hierarchic structure of entities and their attributes. More about data model please [read here](https://korzh.com/easyquery/docs/fundamentals/data-model).
* **Entity** - an object of a user's domain area. Usually, it appears in some separate table in the database, but it is not required. Entities' examples: Customer, Order, Product, Patient.
* **Entity attribute** - some characteristic of the entity. For example, Customer Name, Order Date, Product Price, Patient Age. Usually, attribute corresponds to some field in a database table, bu it is not a requirement in general case. Two or more fields can calculate some attributes. For example, the attribute Patient Full Name can be defined as a concatenation of the field values Patients.FirstName and Patients.LastName.
* **Operator** - a particular function that compares two (or more) values and returns truth or false as a result. Examples of operators: "equal to", "not equal," "more than", "less," "starts with" (for textual values), "prior to" (for date and time). The first argument of the operator usually consists of some entity attribute, and the second - of some constant (1000, "A", "01 Jan 2017", etc.).
* **Value editor** - a type of editor to enter values when we define query condition. The most common value editor is just a text field where the user types required value. Another common case is "List" value editor when the user can select a value from some predefined list instead of entering it "manually".
</Content>
    <Tags>,data-model,database,entity,operator,attribute,value-editor,</Tags>
  </Article>
  <Article id="072f3c0e-714b-4541-8ed1-67194f8c78f9" title="TextValueEditor class">
    <Content>```csharp
public class Korzh.EasyQuery.TextValueEditor
    : ValueEditor

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | DefaultText |  | 
| `String` | DefaultValue |  | 
| `String` | IDBase |  | 
| `Boolean` | Multiline |  | 
| `DataType` | ResultType |  | 
| `String` | TypeName |  | 
| `String` | XmlDefinition |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | LoadAttribute(`String` attrName, `String` attrValue) |  | 
| `void` | LoadContentFromXmlReader(`XmlReader` reader) |  | 
| `void` | SaveAttributesToXmlWriter(`XmlWriter` writer) |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeCaption |  | 
| `String` | STypeName |  | 


</Content>
    <Tags />
  </Article>
  <Article id="075f651f-09b4-45c6-a428-20cc72ccbe5e" title="EqServiceProvider class">
    <Content>```csharp
public abstract class Korzh.EasyQuery.Services.EqServiceProvider

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Func&lt;String, String&gt;` | CacheGetter |  | 
| `Action&lt;String, String&gt;` | CacheSetter |  | 
| `String` | DataPath |  | 
| `String` | DefaultModelId |  | 
| `QueryFormats` | Formats |  | 
| `DataModel` | Model |  | 
| `Func&lt;DataModel&gt;` | ModelCreator |  | 
| `Action&lt;DataModel, String&gt;` | ModelLoader |  | 
| `PagingSettings` | Paging |  | 
| `Query` | Query |  | 
| `Func&lt;Query, JsonDict, IQueryBuilder&gt;` | QueryBuilder |  | 
| `Func&lt;Query&gt;` | QueryCreator |  | 
| `Func&lt;String, IEnumerable&lt;QueryListItem&gt;&gt;` | QueryListResolver |  | 
| `Action&lt;Query, String&gt;` | QueryLoader |  | 
| `Action&lt;String&gt;` | QueryRemover |  | 
| `Action&lt;Query, String&gt;` | QuerySaver |  | 
| `Action&lt;Query&gt;` | QuerySynchronizer |  | 
| `Boolean` | StoreModelInCache |  | 
| `Boolean` | StoreQueryInCache |  | 
| `String` | UserId |  | 
| `Func&lt;String, IEnumerable&lt;ListItem&gt;&gt;` | ValueListResolver |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `QueryBuilderResult` | BuildQuery(`Query` query, `JsonDict` optionsDict = null, `Boolean` addPaging = False) |  | 
| `QueryBuilderResult` | BuildQueryDict(`JsonDict` queryDict, `JsonDict` optionsDict = null) |  | 
| `DataModel` | CreateModel() |  | 
| `Query` | CreateQuery() |  | 
| `QueryFormats` | CreateQueryFormats() |  | 
| `void` | DefaultModelLoader(`DataModel` model, `String` modelId) |  | 
| `IEnumerable&lt;QueryListItem&gt;` | DefaultQueryListResolver(`String` modelId) |  | 
| `void` | DefaultQueryLoader(`Query` query, `String` queryId) |  | 
| `void` | DefaultQueryRemover(`String` queryId) |  | 
| `void` | DefaultQuerySaver(`Query` query, `String` queryId) |  | 
| `IEqResultSet` | ExecuteQuery(`Query` query, `JsonDict` optionsDict = null) |  | 
| `IEqResultSet` | ExecuteQueryCore(`Query` query, `JsonDict` optionsDict = null) |  | 
| `String` | GenerateQueryId(`String` name) |  | 
| `IEnumerable&lt;ListItem&gt;` | GetList(`JsonDict` optionsDict) |  | 
| `IEnumerable&lt;ListItem&gt;` | GetList(`JsonDict` optionsDict, `IQueryable&lt;T&gt;` dbSet) |  | 
| `IEnumerable&lt;ListItem&gt;` | GetListCore(`ListRequestOptions` options) |  | 
| `IEnumerable&lt;ListItem&gt;` | GetListForContext(`ListRequestOptions` options, `IQueryable&lt;T&gt;` dbSet) |  | 
| `DataModel` | GetModel(`String` modelId) |  | 
| `Query` | GetQuery(`String` modelId, `String` queryId) |  | 
| `IQueryBuilder` | GetQueryBuilder(`Query` query, `JsonDict` optionsDict = null) |  | 
| `Query` | GetQueryByIds(`JsonDict` queryDict) |  | 
| `Query` | GetQueryByJsonDict(`JsonDict` queryDict) |  | 
| `IEnumerable&lt;QueryListItem&gt;` | GetQueryList(`String` modelId) |  | 
| `String` | GetValueFromCache(`String` key) |  | 
| `ListRequestOptions` | JsonDictToListRequestOptions(`JsonDict` optionsDict) |  | 
| `void` | LoadModelFromCache(`DataModel` model, `String` modelId) |  | 
| `void` | LoadOptions(`JsonDict` optionsDict) |  | 
| `void` | LoadQueryById(`Query` query, `String` queryId) |  | 
| `void` | LoadQueryFromCache(`Query` query, `String` queryId) |  | 
| `Boolean` | RemoveQuery(`String` queryId) |  | 
| `void` | SaveModelInCache(`DataModel` model) |  | 
| `Boolean` | SaveQuery(`Query` query) |  | 
| `Query` | SaveQueryDict(`JsonDict` queryDict, `String` newQueryName) |  | 
| `void` | SaveQueryInCache(`Query` query) |  | 
| `void` | SaveValueInCache(`String` key, `String` value) |  | 
| `void` | SyncQuery(`Query` query) |  | 
| `Query` | SyncQueryDict(`JsonDict` queryDict) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="07861b26-71db-48f9-bb6e-73076ff3ca10" title="Localization of EasyQuery widgets">
    <Content>To localize JavaScript widgets, you need to create a separate .js file with translated texts and include it after eq.all.min.js.

There is EQ.core.texts global object which holds all text messages used in EasyQuery widgets.

You just need to replace it with your own. Here is its default definition: 

```
EQ.core.texts = {
  Locale: "en",
  AltMenuAttribute: "Attribute",
  AltMenuConstantExpression: "Constant expression",
  ButtonApply: "Apply",
  ButtonCancel: "Cancel",
  ButtonOK: "OK",
  ButtonEnable: "Toggle enable",
  ButtonDelete: "Delete",
  ButtonAddCondition: "Add condition",
  ButtonAddPredicate: "Add group of conditions",
  CmdAddConditionAfter: "Add a new condition after the current row",
  CmdAddConditionInto: "Add a new condition",
  CmdAddPredicateAfter: "Open a bracket after the current row",
  CmdAddPredicateInto: "Open a bracket",
  CmdClickToAddCondition: "[Add new condition]",
  CmdDeleteRow: "Delete this row",
  ErrIncorrectPredicateTitleFormat: "Incorrect predicate title format",
  ErrNotNumber: " is not a number",
  ErrIncorrectInteger: "Incorrect integer value",
  ErrIncorrectNumberList: "Incorrect list format",
  False: "False",
  FirstDayOfMonth: "First day of the month",
  FirstDayOfYear: "First day of the year",
  HourStart: "This hour start",
  LinkTypeAll: "all",
  LinkTypeAny: "any",
  LinkTypeNone: "none",
  LinkTypeNotAll: "not all",
  ConjAll: "and",
  ConjAny: "or",
  ConjNotAll: "",
  ConjNone: "",
  Midnight: "Midnight",
  MsgApplySelection: "[Apply selection]",
  MsgAs: "as",
  MsgEmptyList: "(empty list)",
  MsgEmptyListValue: "[select value]",
  MsgEmptyScalarValue: "[enter value]",
  MsgSubQueryValue: "[edit sub-query]",
  MsgOf: "of",
  Noon: "Noon",
  Now: "Now",
  PredicateTitle: "{lt} of the following apply",
  RootPredicateTitle: "Select records where {lt} of the following apply",
  StrAddConditions: "Add conditions",
  SubQueryDialogTitle: "Edit sub-query",
  SubQueryColumnTitle: "Column:",
  SubQueryEmptyColumn: "[select column]",
  SubQueryQueryPanelCaption: "Conditions",
  Today: "Today",
  Tomorrow: "Tomorrow",
  True: "True",
  Yesterday: "Yesterday",

  ButtonSorting: "Sorting",
  ButtonToAggr: "Change to aggregate column",
  ButtonToSimple: "Change to simple column",
  CmdAscending: "Ascending",
  CmdClickToAddColumn: "[Add new column]",
  CmdDeleteColumn: "Delete column",
  CmdDeleteSorting: "Delete sorting",
  CmdDescending: "Descending",
  CmdGroupSort: "Sorting",
  CmdNotSorted: "Not sorted",
  ColTypeAggrFunc: "Aggregate function",
  ColTypeCompound: "Calculated",
  ColTypeGroup: "Column type",
  ColTypeSimple: "Simple column",
  HeaderExpression: "Expression",
  HeaderSorting: "Sorting",
  HeaderTitle: "Title",
  SortHeaderColumn: "Column",
  SortHeaderSorting: "Sorting",
  StrAddColumns: "Add columns",

  CmdMoveToStart: "Move to start",
  CmdMoveRight: "Move right",
  CmdMoveLeft: "Move left",
  CmdMoveToEnd: "Move to the end",
  ButtonMenu: "Show menu",
  CmdToSimple: "Not aggregated"

};
```

So to replace the text for “Add new condition” link you just need to make the following call somewhere at your page start code: 

```
EQ.core.text['CmdClickToAddCondition"] = "My own text for add new condition link";
```

As I told at the beginning - you can place all your translations into a separate .js file and only include it into your page after eq.all.min.js Example: 

```
EQ.core.text = {
 
  AltMenuAttribute: "Attribute - translated",
  AltMenuConstantExpression: "Constant expression - translated",
  ButtonApply: "Apply - translated",
  ButtonCancel: "Cancel - translated",
  . . . . . . . . .
}
```

The same approach works for all items in your data model. Just add Entities, Attributes and Operators properties into EQ.core.texts object and define the translations using entity names, attribute or operator IDs correspondingly: 

```
EQ.core.text = {
 
  Entities: {
  "Contact": "Contacto",
  "Customer": "Cliente",
  ....
  },
 
  Attributes: {
  "Customers.Company": "Empresa",
  "Orders.OrderDate": "Fecha de orden",
  . . . 
  },
 
  Operators: {
  "Equal": { 
  "caption": "Equivale", 
  "displayFormat: "{expr1} [[es igual a]] {expr2}" 
  },
  "StartsWith": { 
  "caption": "Comienza con", 
  "displayFormat": "{expr1} [[comienza con]] {expr2}" 
  }
 
  },
 
  . . . . . . . . .
}
```

Please note that there are 2 properties of Operators object for each operator. One of them (“caption”) defines the translation for operator's caption (the text user see when select operator from drop-down list). Second item (“displayFormat”) sets the translation for operator's format - the text which is rendered for operator right in query condition. 

## Datepicker localization

When you need to localize some widgets, you should use jQuery DatePicker widget, and its localization is described in jQuery [documentation](https://jqueryui.com/datepicker/#localization).

Also, you need to add an option to your easyQuerySettings variable:

```
window.easyQuerySettings = {
  . . . . .,
  locale: "fr", //add this option to make DatePicker set necessary region automatically
  . . . . .,
  queryPanel: { 
  dateFormatValue: "dd/mm/yy", 
  dateFormatDisplay: "dd/mm/yy" 
  },
  
};
```</Content>
    <Tags>,javascript,widgets,localize-components,data-model,code-sample,</Tags>
  </Article>
  <Article id="0bd0f6c2-1b01-4ca6-83c7-b6e5ace2555b" title="Dynamic PHP query builder with EasyQuery">
    <Content>        &lt;p&gt;
            JavaScript (jQuery) query builder widgets are now available as a separate (free) product: &lt;a href="/easyquery/javascript"&gt;EasyQuery.JS&lt;/a&gt;.
            &lt;br&gt; Please read &lt;a href="~/easyquery/javascript/docs/getting-started/query-builder-php"&gt;this article&lt;/a&gt; to learn how to use it with PHP backend.
        &lt;/p&gt;
</Content>
    <Tags>,javascript,php,data-model,</Tags>
  </Article>
  <Article id="0c1bb21b-bb80-4537-89d4-be5d643d8b69" title="Operators page">
    <Content>This article defines operators which can be used in conditions (such as 'is equal to', 'less than' and others). List in the left part shows defined operations. Add or delete one by right-clicking the list and choosing an appropriate topic from the pop-up menu or using corresponding speed buttons on the top of the page. To edit an operation select it from the list and modify its properties in the right part of the page.

## Operator properties

* **Operator ID** is an internal identifier for the operator.

* **Caption property** allows specifying how this operator will be presented to a user when he/she selects it in condition.

* **Display Format** is a template which describes how an operator (an all condition) will be shown to end user in query panel. The most usual value of this field is: `{expr1} [[operator text]] {expr2}`

Here `{expr1}` and `{expr2}` will be substituted by the corresponding expression in condition (an entity attribute or constant).

The text in `[[ ]]` brackets will be shown as a link for operator selection.

For “between” operator Display Format property will also contain '**and**' word between second and third expression:

```
{expr1} [[is between]] {expr2} and {expr3}
```

* **Expression** is a template for condition expression in generated SQL query. It may contain any correct SQL expressions (operators such as =, &gt;,&lt;, functions or even names of stored procedures) and the following special variables:

  * `{expr1}` - is substituted with the entity attribute selected by user

  * `{expr2}`, `{expr3}`, … - are substituted by constant values typed or selected by user or entity attributes selected at the right part of the condition.

Additionally, you can use the following constructions:

* `{exprN.table}` - will be replaced by table name of N expression if this expression represents an entity attribute or by an empty string in another case.
* `{exprN.field}` - will be replaced by field name of N expression if this expression represents an entity attribute or by an empty string in another case.

Examples:

 * For the simple “is equal to” operator the format string is:

```
{expr1} = {expr2}
```
 * The “starts with” operator has the following format:

```
{expr1} LIKE {expr2}
```

You can define more complex operators even with sub-queries. For example here is an expression for “more then average” operator:

```
{expr1} &gt; (SELECT AVG({expr2.field}) FROM {expr2.table})
```

* **Default data type** - represents an expected type of operator parameters used in condition expression. “Auto” value means the same type as the type of entity attribute used at the left part of the condition; other values correspond to particular data types.

* **Default value kind** - defines the kind of data which has the parameters of this operator.
  
  * “Scalar” - means a simple single value is needed: one string, one number, etc. This kind also allows specifying entity attribute.
  * “Const” - the same as previous one but allows specifying the only constant value (entity attributes are not allowed).
  * “Attribute” - the same as the first one but allows to specify only entity attribute (constant values are not allowed).
  * “List” type requires a list of scalar values separated by the comma. E.g., having this option checked, when the user enters a, b, c as a parameter value, it's treated as 'a', 'b', 'c' instead of 'a, b, c' in the generated SQL text.
  * “Query” type means that operator requires SQL SELECT statement as a value in the right part of the condition. To build this statement query panel opens a separate dialog.

* **Group** - allows selecting the group which operators belong to.

* **Default value editor** - allows specifying the value editor for operator's parameters. To learn more about free editors see Value Editors topic. To specify editor parameters click on “Settings…” button. Operator value editor has higher priority in a condition than the editor defined for entity attribute used at the left part of this condition.

* **Apply to types** is a list of check boxes defining data types to which the operation is applicable.

## Main operations

To add new operator use “Operators | Add operator” menu item. To delete - use “Operators | Delete selected”.

Operators menu also contains “Add/Update default operators” menu item which can be used to add the default operators in the model or update the parameters of existing one.

There are the following default operators: 

| ID | Caption | SQL expression |
|-------------------------|-------------------------------|--------------------|
|Equal | is equal to | {expr1} = {expr2} |
|NotEqual | is not equal to | {expr1} &lt;&gt; {expr2} |
|LessThan | is less than | {expr1} &lt; {expr2} |
|LessOrEqual | is less than or equal to | {expr1} &lt;= {expr2} |
|GreaterThan 	 | greater than | {expr1} &gt; {expr2} |
|GreaterOrEqual | greater than or equal to | {expr1} &gt;= {expr2} |
|IsNull			 | is null			 | {expr1} is null |	
|InList 	 | is in list | {expr1} in ({expr2})|
|StartsWith 	 	 | starts with | {expr1} like {expr2}|
|NotStartsWith	 | does not start with | not({expr1} like {expr2})|
|Contains 	 | contains | {expr1} like {expr2}|
|NotContains 	 | does not contain | not({expr1} like {expr2})|
|Between 	 | is between | {expr1} between {expr2} and {expr3}|
|InSubQuery 	 | is in set 	 | {expr1} in ({expr2})|
|DateEqualSpecial 	 | is 	 | {expr1} = {expr2} |
|DateEqualPrecise 	 | is 	 | {expr1} = {expr2} |
|DateBeforeSpecial 	 | is before (special date) | {expr1} &lt; {expr2} |
|DateBeforePrecise | is before (precise date) | {expr1} &lt; {expr2} |
|DateAfterSpecial | is after (special date) | {expr1} &gt; {expr2} |
|DateAfterSpecial | is after (precise date) | {expr1} &gt; {expr2} |

 “Special” and “Precise” operators with the same expressions differ by value editors. “Special” operators have “Custom List” value editor with “SpecDateValues” name. This list is filled at runtime by such values as Today, Yesterday, First day of the month, etc.

The “Precise” operator has usual “Date/time value editor” which allows simply to enter a necessary date (or select it using the calendar).</Content>
    <Tags>,data-model,code-sample,operators,</Tags>
  </Article>
  <Article id="0d5d1d6f-3266-413f-bd95-137f060e395c" title="ConstValueItem class">
    <Content>```csharp
public class Korzh.EasyQuery.ConstValueItem

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | ID |  | 
| `String` | Text |  | 


</Content>
    <Tags />
  </Article>
  <Article id="0f087eba-64e0-414f-b833-2029c9ae9740" title="ColumnsChangingEventArgs class">
    <Content>```csharp
public class Korzh.EasyQuery.ColumnsChangingEventArgs
    : ColumnsChangeEventArgs

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | Accepted |  | 


</Content>
    <Tags />
  </Article>
  <Article id="0fc41025-a0c1-4f8c-862b-3c4dbdb93796" title="TimeMacroType class">
    <Content>```csharp
public enum Korzh.EasyQuery.TimeMacroType
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | Today |  | 
| `1` | Yesterday |  | 
| `2` | Tomorrow |  | 
| `3` | FirstDayOfWeek |  | 
| `4` | FirstDayOfNextWeek |  | 
| `5` | FirstDayOfPrevWeek |  | 
| `6` | FirstDayOfMonth |  | 
| `7` | FirstDayOfPrevMonth |  | 
| `8` | FirstDayOfNextMonth |  | 
| `9` | LastDayOfMonth |  | 
| `10` | FirstDayOfYear |  | 
| `11` | FirstDayOfNextYear |  | 
| `12` | FirstDayOfPrevYear |  | 
| `13` | Now |  | 
| `14` | HourStart |  | 
| `15` | Midnight |  | 
| `16` | Noon |  | 


</Content>
    <Tags />
  </Article>
  <Article id="10195c23-b880-4520-8fa3-32726bb526de" title="SqlListValueEditor class">
    <Content>```csharp
public class Korzh.EasyQuery.SqlListValueEditor
    : ListValueEditor

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | DefaultText |  | 
| `String` | DefaultValue |  | 
| `String` | IDBase |  | 
| `DataType` | ResultType |  | 
| `String` | SQL |  | 
| `String` | SQLCount |  | 
| `String` | TypeName |  | 
| `String` | XmlDefinition |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | LoadContentFromXmlReader(`XmlReader` reader) |  | 
| `void` | SaveContentToJsonDict(`JsonDict` dict) |  | 
| `void` | SaveContentToXmlWriter(`XmlWriter` writer) |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeCaption |  | 
| `String` | STypeName |  | 


</Content>
    <Tags />
  </Article>
  <Article id="1097abe0-0e29-4dda-a6e0-b4360db0b49f" title="Aggregate data">
    <Content>We often need not only to extract data from database but to calculate something - entire orders sum, average weight, count of participants, etc.

Let’s suppose we want to calculate total orders count. In SQL we use the COUNT function like this:

```sql
SELECT COUNT(Ord.OrderID) AS [Order Count] 
FROM Orders AS Ord
```

## Let’s do it using EasyQuery.

First, add a column - click on “[Add column]” link, select “Order | OrderID” menu item. Then click the Function button on the right side of the column and select “Count” menu item.

![Build query with aggregation](/files/test/easyquery-dotnet/images/aggregate-data-1.gif)

## Let’s complicate the task

Now our goal is to calculate the count of orders made during the current year and grouped by customer country.

Expected SQL:

```sql
SELECT Cust.Country AS [Customer Country], COUNT(Ord.OrderID) AS [Order OrderID Count] 
FROM (Customers AS Cust
  RIGHT OUTER JOIN Orders AS Ord ON (Ord.CustomerID = Cust.CustomerID ))
WHERE
(
  Ord.OrderDate &gt;= #2014-01-01# )
GROUP BY Cust.Country
ORDER BY 1
```

You need some knowledge to generate it, right? But not with EasyQuery!

First, add a condition to set “during this year” restriction. Click “Add condition”, select “Order | Date” from menu. Then change the operator - click on “is equal to” link and select “after (special)”. At last, click on “Today” link and select “First day of the year”

Then add a new column “Customer | Country” as described above. Just to get more presentable result drag this column to the first place, then tell it to sort results by Country ascending (click the button with arrows on the left side of Country column and select “Ascending” menu item).

Voila!

Note, that you don’t need to think about columns to group by - all columns that are not aggregated are automatically used to group by them.

![Build more complex query with aggregation](/files/test/easyquery-dotnet/images/aggregate-data-2.gif)

</Content>
    <Tags>,query-example,sql,aggregate-function,code-sample,</Tags>
  </Article>
  <Article id="1177e7f1-2c0f-4143-825c-713f8bf82e6a" title="Advanced search page in your MVC app in 5 minutes">
    <Content>&lt;h2&gt;Problem&lt;/h2&gt;
  &lt;ol&gt;
  &lt;li&gt;You have an ASP.NET MVC project which works with some database (directly or through EntityFramwork).&lt;/li&gt;
  &lt;li&gt;You have a request for a new page in your application with "advanced search" functionality where users will be able to build quite complicated queries to underlying DB and get the result instantly&lt;/li&gt;
  &lt;li&gt;You need this functionality, you know, "for yesterday" :)&lt;/li&gt;
  &lt;/ol&gt;
  &lt;h2&gt;Solution&lt;/h2&gt;
  &lt;p&gt;&lt;b&gt;1. Open your project in Visual Studio&lt;/b&gt;&lt;/p&gt;
  &lt;p&gt;&lt;b&gt;2. Go to Package Manager (PM) Console&lt;/b&gt;&lt;/p&gt;
  &lt;p&gt;Use the menu item if the console is not opened currently:
  &lt;br&gt; Tools | Nuget Package Manager | Package Manager Console&lt;/p&gt;
  &lt;p&gt;&lt;b&gt;3. Install EasyQuery Nuget package&lt;/b&gt;&lt;/p&gt;
  &lt;p&gt;Just type in PM console&lt;/p&gt;
  &lt;br&gt;
  &lt;pre&gt;
&lt;code class="bash"&gt;PM&gt; Install-Package EasyQuery.Mvc.Scaffolding&lt;/code&gt;
&lt;/pre&gt;
  &lt;br&gt;
  &lt;p&gt;&lt;b&gt;4. Scaffold an advanced search page&lt;/b&gt;&lt;/p&gt;
  &lt;p&gt;Type:
  &lt;/p&gt;
  &lt;br&gt;
  &lt;pre&gt;
&lt;code class="bash"&gt;PM&gt; Scaffold EasyQuery.MvcController {ControllerName} -ConnectionName {ConnectionName}&lt;/code&gt;
&lt;/pre&gt;
  &lt;br&gt;
  &lt;p&gt;to add a new controller and corresponding view page. &lt;/p&gt;
  &lt;p&gt;Here {ConnectionName} parameter is the name of your connection defined in Web.config file.&lt;/p&gt;
  &lt;p&gt;Example:&lt;/p&gt;
  &lt;br&gt;
  &lt;pre&gt;
&lt;code class="bash"&gt;PM&gt; Scaffold EasyQuery.MvcController AdvancedSearch -ConnectionName DefaultConnection&lt;/code&gt;
&lt;/pre&gt;
  &lt;br&gt;
  &lt;p&gt;in case you are using EntityFramework use -DbContext parameter of Scaffold command. For example:&lt;/p&gt;
  &lt;br&gt;
  &lt;pre&gt;
&lt;code class="bash"&gt;PM&gt; Scaffold EasyQuery.MvcController AdvancedSearch -DbContext NorthwindContext&lt;/code&gt;
&lt;/pre&gt;
  &lt;br&gt;
  &lt;p&gt;&lt;b&gt;5. Open your advanced search page in browser&lt;/b&gt;&lt;/p&gt;
  &lt;p&gt;Now you can try to open your new page in browser and check how it works. If you named your new controller (and view) exactly as in examples above ("AdvancedSearch") then you can type:&lt;/p&gt;
  &lt;p&gt;&lt;i&gt;http://localhost:[port]/AdvancedSearch&lt;i&gt;&lt;/p&gt;
  &lt;p&gt;That's all!&lt;/p&gt;
  &lt;p&gt;To see the whole process described above in action you can visit &lt;a href="http://youtu.be/cPz7-8KY0bQ"&gt;this video&lt;/a&gt; page on YouTube.&lt;/p&gt;
</Content>
    <Tags>,asp-net,mvc,code-sample,entity-framework,</Tags>
  </Article>
  <Article id="11891a13-dc17-47fb-8175-263c56771d16" title="ListItem class">
    <Content>```csharp
public class Korzh.EasyQuery.Services.ListItem

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | id |  | 
| `IEnumerable&lt;ListItem&gt;` | items |  | 
| `String` | text |  | 


</Content>
    <Tags />
  </Article>
  <Article id="12e82467-2bf8-4d44-91f4-3a4d8869de06" title="How to add a column with the same attribute as in newly added condition">
    <Content>```js


var query = EQ.client.getQuery();
query.addChangedCallback(function (eventParams) {
    if (eventParams.changeType == "condition.add") {
        var cond = eventParams.condition;
        if (cond.expressions) {
            var attrID = cond.expressions[0].id;
            var ColumnsPanelWidget = $('#ColumnsPanel');
            ColumnsPanelWidget.ColumnsPanel("addNewColumn", attrID);
        }
    }
});

```</Content>
    <Tags>,entity-framework,asp-net,mvc,code-sample,data-model,</Tags>
  </Article>
  <Article id="12fa1254-c111-4b63-b306-4e0075848e19" title="Version 3.9.0 release notes">
    <Content>## 1. Core library

* Now you can choose the symbol which precedes the parameter name (e.g. '@' or ':') with the new `ParameterPrefix` option in `DbQueryFormats`.
* Another new option `PrefixUnicodeConsts` in DbQueryFormats: means that if `true` - 'N' prefix is added to SQL statements for Unicode string literals.
* There is a new possibility to mark any condition as "In Join", so that condition will be added into JOIN clause instead of WHERE. Also, you can mark any condition as "Parameterized", so the values in this condition will be placed into result SQL as parameters.

## 2. JavaScript widgets

* Now it is possible to turn on/off each widget separately thanks to the new configuration of buttons in QueryPanel widget. There is a new **SortingBar** widget, which allows defining the order of sorting columns.
* New "Options" button allows performing any operation with the condition. Besides, there is a new possibility to turn condition parameterization on/off, and another new function to mark a condition as "join condition".

## 3. Data Model Editor

* Now Data Model Editor saves its position on exit and restores on the next launch. Also, we'd like to note, that Data Model Editor now shows MS SQL as the default DB gate.

## 4. Other editions of EasyQuery

* There is a significant update for the users of ASP.NET MVC projects: we improved EqServiceProvider, so now it's not necessary to use Session to store data in between the requests.
* For WebForms users there is a new Refresh method and also a new property ShowCheckboxes in QueryPanel control. We also fixed DateTimePicker error for the values with time part.
* There are new menu items for each condition in WPF controls: "Toggle parameterization" and "Toggle 'in join' status".
</Content>
    <Tags>,dme,asp-net,javascript,widgets,</Tags>
  </Article>
  <Article id="13836bde-3154-49ab-85c4-19afaff60c4d" title="EntityList class">
    <Content>```csharp
public class Korzh.EasyQuery.EntityList
    : Collection&lt;Entity&gt;, IList&lt;Entity&gt;, ICollection&lt;Entity&gt;, IEnumerable&lt;Entity&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;Entity&gt;, IReadOnlyCollection&lt;Entity&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | SortByName() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="14378d61-3bb3-4466-a590-907ec5dd55f8" title="Data Model">
    <Content>In short (and by its name), data model - is a model (representation) of some data stored in your database. It solves two major problems:

* Presents the data to the end user in a more friendly and familiar way.
* Contains some meta information that helps EasyQuery components to build query statements in SQL or other query languages.

Any data model contains the following main sections:

1. Entities and their attributes.
2. Operators.
3. Tables and the links between them.

In the following paragraphs, we will examine all these sections in more detail. 

## Entities and their Attributes

In general, an entity represents some object from real life and an attribute - is some property of that object.
Examples of entities: Customer, Order, Product, Vendor, etc.
Examples of attributes: Customer Name, Product price, Order freight, Vendor country, etc.

When creating a new model, each entity usually represents a table in the database and each attribute - one field in that table.
However, it is not a rule in general case: some entities can combine fields from different tables. Furthermore, there is "virtual" attribute, whose value is calculated from other fields.

Each entity and attribute have a variety of properties. For example "Name" or "Caption" property contains the name that end users will see when they build a query.
For entity attributes, you can also specify a list of possible values (so the user can choose from this list, instead of entering data manually). Another important property of entity attribute is "Expression" - it contains the exact expression that goes into the generated SQL statement.

## Operators

We use operators to define query conditions. For example: "is equal to", "is greater than", "starts with", "is between", etc. Typically, each operator directly "represents" some conditional operation in SQL or any other query language but instead of mathematical symbols (like "=", "&gt;") or some tricky SQL structures, operators in EasyQuery are presented to end users as simple phrases in natural language.
Compare:

```
Emp.fname LIKE 'Alex%'
```

and

```
Employee first name starts with 'Alex'
```

## Tables and their links

Entities, their attributes, and operators - is that part of the model, which end users work with when building a query. But the tables and their links are needed for internal use only by EasyQuery components - to generate SQL statements correctly.

Using the list of tables and you can control which tables can take part in the queries built over this model.
Additionally, for each link, you can define a default link type (INNER, LEFT, RIGHT) which will be used in generated SQL statements.

## Creating a Model

So, now we know that the model is necessary for a proper work of EasyQuery components. The only question is: how could we create one?

There are several different ways to set up and populate the data model. Here are the most popular:

* **Manually**
  
The model is created using a single utility Data Model Editor (DME), which is supplied EasyQuery. When you create a model, we usually connect to the database using one of the available connection types (OLEDB, SQL Client, Oracle, etc.), to get the necessary information about structure database: list of tables, relationships between them, the fields for each table, etc. Then you can manually add/delete attributes (fields), change their description, etc.
  With this approach, the model is usually stored in an XML file, which is then loaded when you start the application using the LoadFromFile().
  If the structure of your database does not change often - we recommend you use this approach because it provides greater control over the presentation of data to the end user. Some fields can be hidden, for others, you can change the name or assign an individual "value editor" that allows users to choose a value from some list instead of entering it manually.

* **Creating model "on the fly"**
  
There is an opportunity to create a model directly based on Connection object using DbGate component and a special method of DataModel: `LoadFromConnection()`.
  In this case, in fact, we just have a mapping of the database structure with all tables (including some service tables or the tables which just implement many-to-many relations) and the fields in these tables. All entities and attributes will have the same names as their corresponding tables and fields.

* **Creating a model by DbContext**
  
When using EntityFramework we can get a model by DbContext (or ObjectContext for older versions of EF) class using special method `LoadFromDbContext()` (or `LoadFromContext()`).
This method is very similar to the previous one, with the difference that we get the model's structure directly from a "context" class instead of using meta-information from database.
</Content>
    <Tags>,data-model,operator,entity,attribute,tables,links,connection,</Tags>
  </Article>
  <Article id="16b7e25d-952e-472a-9a0e-3eb332e6390f" title="EqEntityAttrAttribute class">
    <Content>```csharp
public class Korzh.EasyQuery.EqEntityAttrAttribute
    : Attribute

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | UseInConditions |  | 
| `Boolean` | UseInResult |  | 
| `Boolean` | UseInSorting |  | 


</Content>
    <Tags />
  </Article>
  <Article id="17ab18da-e766-4626-b591-83ba03735e20" title="ColumnsChangeEventArgs class">
    <Content>```csharp
public class Korzh.EasyQuery.ColumnsChangeEventArgs
    : EventArgs

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Column` | Column |  | 
| `Int32` | Info |  | 
| `Int32` | Part |  | 
| `ChangeType` | What |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `ColumnsChangeEventArgs` | Default |  | 


</Content>
    <Tags />
  </Article>
  <Article id="1f57c637-08ec-4980-bea6-47ca7145b1e4" title="Creating new data model using Data Model Editor">
    <Content>## 1. Run Data Model Editor (DME)

Of course, it's an obvious step but it may cause some difficulties as well. If you already [downloaded](https://korzh.com/easyquery/) and installed EasyQuery (both trial or full version) then DME is already installed on your computer. For Windows 7 and earlier versions you can find it through Start menu: Start | All Programs | Korzh EasyQuery | Data Model Editor. For Windows 8 just open Start screen and start to type “Data Model Editor”.

## 2. Create new model and establish a database connection

  - Use “Model | New..” menu item
  - Type the name of your model (e.g. “MyModel”)
  - Choose the type of database connection (e.g. “MS SQL Server (native)”)
  - Enter the connection string. You can use “Build connection string” to construct the connection string visually.
  - Test your database connection using “Test connection” button.
  - Press OK to finish model creating

![Data Model Editor - new model](/files/test/easyquery-dotnet/images/dme-newmodel.png)

## 3. Fill the list of tables

After pressing OK and closing the previous dialog you will be asked to add database tables into your model. Click “Yes” to agree and the Select Tables dialog will appear. 

![Data Model Editor - fill tables list](/files/test/easyquery-dotnet/images/dme-addtables01.png)

Select the tables you want to add into your model (select all of them if you don't have any limitations) and press OK to add them.
## 4. Establish the link between tables

DME will offer you to add the links automatically using information about foreign keys or (if foreign keys are not defined in you DB) a special algorithm which searches for field pairs in all added tables (e.g. table1.customerID → table2.customerID). Select “Yes” to start that process. When it is finished you can check added links for each table in “Links” list box.

## 5. Save your data model into XML

That's mostly all. The initial setup has been finished. Use “Model | Save..” menu item to save your model into an XML file. 

![Data Model Editor - save model](/files/test/easyquery-dotnet/images/dme-savemodel.png)

You will load this XML file in your application LoadFromFile(“path to file”) method of DbModel class. 

</Content>
    <Tags>,data-model,database,tables,connection,links,sql-server,dme,</Tags>
  </Article>
  <Article id="1fe8bc79-a7db-4ffe-9189-becab3eae202" title="TextStorage class">
    <Content>```csharp
public class Korzh.Utils.TextStorage

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | Get(`String` id) |  | 
| `void` | LoadFromFile(`String` path) |  | 
| `void` | LoadFromFileForCulture(`String` baseFileName, `CultureInfo` cultureInfo = null, `String` fileExt = properties) |  | 
| `void` | LoadFromResources(`ResourceManager` resManager) |  | 
| `void` | LoadFromStream(`Stream` input) |  | 
| `void` | LoadFromTextReader(`TextReader` reader) |  | 
| `void` | Put(`String` key, `String` value) |  | 


### Static Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `CultureInfo` | GetCurrentCulture() |  | 
| `CultureInfo` | GetCurrentUICulture() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="2100f4c0-1279-4bf0-a8ac-38992c8d5f3c" title="NoPathResolution class">
    <Content>```csharp
public enum Korzh.EasyQuery.NoPathResolution
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | ThrowException |  | 
| `1` | CartesianProduct |  | 
| `2` | FlexibleModel |  | 


</Content>
    <Tags />
  </Article>
  <Article id="211fadd9-14ee-417f-b8ec-016f631318a2" title="Utils class">
    <Content>```csharp
public static class Korzh.EasyQuery.Utils

```

### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | InternalDateFormat |  | 
| `String` | InternalTimeFormat |  | 


### Static Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | AreCompatibleTypes(`DataType` type1, `DataType` type2) |  | 
| `String` | ComposeKey(`String` parent, `String` child) |  | 
| `Boolean` | ContainsNonAscii(`String` s) |  | 
| `DataKind` | DataKindByName(`String` kindName) |  | 
| `DataType` | DataTypeByName(`String` typeName) |  | 
| `String` | DateTimeToInternalFormat(`DateTime` dt, `DataType` dataType) |  | 
| `String` | DateTimeToUserFormat(`DateTime` dt, `DataType` dataType) |  | 
| `String` | FormatDateTimeValue(`String` val, `String` format, `DataType` dataType) |  | 
| `CultureInfo` | GetCurrentCulture() |  | 
| `CultureInfo` | GetCurrentUICulture() |  | 
| `DataType` | GetDataTypeBySystemType(`Type` systemType) |  | 
| `String` | GetDateTimeInternalFormat(`DataType` dataType, `Boolean` shortTime = False) |  | 
| `String` | GetElementContentAsString(`XmlReader` reader) |  | 
| `IList&lt;Int32&gt;` | GetEnumValues(`Type` oEnumType) |  | 
| `IFormatProvider` | GetInternalFormatProvider() |  | 
| `DateTime` | GetSpecialDateValue(`String` s) |  | 
| `Type` | GetSystemTypeByDataType(`DataType` type) |  | 
| `Type` | GetSystemTypeByDataType(`DataType` dtype, `Type` defaultType) |  | 
| `DateTime` | InternalFormatToDateTime(`String` val, `DataType` dataType) |  | 
| `Boolean` | IsStrNullOrEmpty(`String` s) |  | 
| `Boolean` | MoveToAttribute(`XmlReader` reader, `String` attrName) |  | 
| `DateTime` | OldFormatToDateTime(`String` val) |  | 
| `Boolean` | SafeParseBool(`String` value, `Boolean` defValue = False) |  | 
| `Int32` | SafeParseInt(`String` s, `Int32` defValue = 0) |  | 
| `String` | StrToIdentifier(`String` s) |  | 
| `Boolean` | TextEq(`String` s1, `String` s2) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="24042a70-dbaa-49ab-b9ac-45ac468a0c4c" title="Version 3.7.0 release notes">
    <Content>## 1. New functions in EQ.client namespace (for ASP.NET MVC projects)

We have added two new functions to the EQ.client namespace of EasyQuery.JS library: newQuery and removeQuery. Now (together with saveQuery/loadQuery functions available earlier) we have a full set of operations which allow you to manage the list of queries available for your end-users.
To see how all these functions work - take a look at [EasyReportDemo](http://demo.easyquerybuilder.com/adhoc-reporting) sample project which is also available online.

## 2. Support for complex types LoadFromType and LinqQueryBuilder

Version 3.6.0 introduced new **FilterBar** widget which allows you quickly and easily build data filtering UI on your web-pages. Usually, FilterBar works together with the LoadFromType method of DbModel classes which helps to create data-model dynamically based on the structure of some model class.
You can test how this widget and new function work together in our **EqMvcDemoLinq** sample project (it's included into trial version and published as [live demo](http://demo.easyquerybuilder.com/data-filtering/)).
Before version 3.7.0 users could create filters only by properties from the main class excluding all complex types and "navigation" properties. Now, there is no this restriction anymore. For example, in sample project mentioned above, you can filter the list of Orders by Product Name or Ship Address.

## 3. New properties and events in EqServiceProviderDb class

There are few improvements in EqServiceProviderDb class which help you to process client-side AJAX requests from EasyQuery widgets.

  - UserID property
  It allows you to separate queries for different users when the default query loading/saving mechanism (XML files) is used. In this case, EqServiceProvider saves queries for different users into different folders.
  - ContextType property and ContextGetter event
  
These two options allow simplifying the implementation of EasyQueryController in the case when you do search for some context class. Here is how your controller's actions may look like now: 

```js
public EasyQueryController() {
  eqService = new EqServiceProviderDb();
  . . . . . .
 
  eqService.ContextType = typeof(NorthwindContext);
  eqService.ContextGetter = () =&gt; new NorthwindContext();
}
 
. . . . . .
 
[HttpPost]
public ActionResult GetModel(string modelName) {
  var result = eqService.GetModel(modelName);
  return Json(result.SaveToDictionary());
}
 
. . . . . .
 
[HttpPost]
public ActionResult ExecuteQuery(string queryJson, string optionsJson) {
  var query = eqService.LoadQueryDict(queryJson.ToDictionary());
  var resultSet = eqService.ExecuteQuery(query, optionsJson.ToDictionary());
 
  . . . . . .
}
```
## 4. New options in EasyQuery widgets

  - EQ.client.locale
  Now you can set the region for resources used in EasyQuery widgets. For example, setting this option will make DatePicker widget to use some local resources instead of default ones.
  - formatColumnHeader and formatGridCell callbacks in ''easyQueryViewSettings''
  These two callback functions allow you to change the way the result set is rendered. For example, you can make some column to be rendered as hyperlink (see the code below)

Here is how you can set all options described above through easyQuerySettings variable: 

```js
&lt;script&gt; 
  window.easyQuerySettings = {
  serviceUrl: "/EasyQuery",
  loadDefaultModel: true,
  locale:"fr", //setting current locale to French
  . . . . . . . . .
  };
 
  window.easyQueryViewSettings = {
  
  formatColumnHeader: function(dataTable, colIndex, label) {
  var col = dataTable.getColumnProperties(colIndex);
  if (col.type == "numeric")
  label += " ##";
  return label;
  },
 
  formatGridCell: function (dataTable, rowIndex, colIndex, value) {
  var colId = dataTable.getColumnId(colIndex);
  var props = dataTable.getColumnProperties(colIndex);
  if (colId == "OrderID" || (props &amp;&amp; props.table == "Orders" &amp;&amp; props.field == "OrderID")) {
  linkToOrderPage = "/Order/" + value ;
  value = '&lt;a href="' + linkToOrderPage + '" target="_blank"&gt;' + value + '&lt;/a&gt;';
  }
  return value;
  }
  };
 
&lt;/script&gt; 
```</Content>
    <Tags>,mvc,code-sample,widgets,controllers,</Tags>
  </Article>
  <Article id="24bab5b4-6a44-4fe2-bbad-fb19ed5ccdc7" title="IQueryBuilder class">
    <Content>```csharp
public interface Korzh.EasyQuery.IQueryBuilder

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Type` | ResultType |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `QueryBuilderResult` | GetResult() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="252874dc-a46e-41ea-b76f-352856472e2d" title="QueryBuilderResult class">
    <Content>```csharp
public abstract class Korzh.EasyQuery.QueryBuilderResult

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `QueryParamList` | Params |  | 
| `String` | Statement |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | GetStatement() |  | 
| `String` | ToString() |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `QueryBuilderResult` | Empty |  | 


</Content>
    <Tags />
  </Article>
  <Article id="252ab890-3955-45fd-be5d-817e02b30fb4" title="Dynamically populate lists by information from other conditions — WinForms">
    <Content>We will discuss this problem and its solution by example. Let's say the user can define a condition with city e.g. “City name is equal to LA”. But if the user has already selected a country (or a few countries) in one of their condition lists then the list of cities available for indicated condition must be filled with only the cities in the selected countries.

To implement such functionality, you just need to monitor all changes in a query and when the “Country” field is selected in some condition - you should set some variable and then use this variable when generating the list of Cities. To monitor all changes you can use `ConditionsChanged` event of `Query` object.

So, here our code sample.

First of all, we save an attribute which should be monitored into the particular variable. After that you use that variable when populating “Cities” list: 

```js
  private DataModel.EntityAttr countryAttr = null;
  
  public MainForm()
  {
  //
  // Required for Windows Form Designer support
  //
  InitializeComponent();
  . . . . . . . 
  //somewhere at the form start
  countryAttr = model.EntityRoot.FindAttribute(EntAttrProp.SqlName, "Customers.Country");
  }
  
  //each time user updates the condition with monitored attribute,
  //we refresh all lists that depends on it
  private void query_ConditionsChanged(object sender, ConditionsChangeEventArgs e) {
  if (e.Condition.BaseAttr != null &amp;&amp; e.Condition.BaseAttr == countryAttr) {
  QPanel.RefreshList("RegionList");
  }
  }
  
  private void QPanel_ListRequest(object sender, ListRequestEventArgs e) {
  if (e.ListName == "RegionList") {
  e.ListItems.Clear();
  string country = query.GetOneValueForAttr(countryAttr);
  
  if (country == "Canada") { 
  e.ListItems.Add("British Columbia", "BC");
  e.ListItems.Add("Quebec", "Quebec");
  }
  else if (country == "USA") {
  e.ListItems.Add("California", "CA");
  e.ListItems.Add("Colorado", "CO");
  e.ListItems.Add("Oregon", "OR");
  e.ListItems.Add("Washington", "WA");
  }
  }
```</Content>
    <Tags>,winforms,asp-net,code-sample,entity-framework,conditions,</Tags>
  </Article>
  <Article id="25a809ef-0159-48db-ae9a-f822eca470c4" title="StringExtensions class">
    <Content>```csharp
public static class Korzh.EasyQuery.StringExtensions

```

### Static Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | BreakBy(this `String` s, `Char` sep, `String&amp;` key, `String&amp;` val) |  | 
| `Int32` | CompareToCI(this `String` s1, `String` s2) |  | 
| `Int32` | ToInt(this `String` s, `Int32` defValue = 0) |  | 
| `Int64` | ToLong(this `String` s, `Int64` defValue = 0) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="25c0d8c6-30e3-4939-9216-f3aaf79d43bb" title="Operand class">
    <Content>```csharp
public class Korzh.EasyQuery.Operand

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | _defaultValue |  | 
| `Int32` | index |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `DataType` | DataType |  | 
| `String` | DefaultText |  | 
| `String` | DefaultValue |  | 
| `ValueEditor` | Editor |  | 
| `DataKind` | Kind |  | 
| `DataModel` | Model |  | 
| `String` | Name |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | LoadNodes(`XmlReader` reader) |  | 
| `JsonDict` | SaveToJsonDict() |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 
| `String` | ToString() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="26586084-1579-4414-9c10-066eb31864d1" title="Working with table aliases">
    <Content>When do you need aliases? Sometimes you want to use one table for several different links and only your user's query can define which link you want to use to build a correct query.
To build such links you need to use aliases. Let's see the following example.

You want to have links like `Table1.FieldA → Table2.FieldC` and `Table1.FieldB → Table2.FieldC`
You have a database that contains the information about people migration within the United States.
There are tables **People** and **States** in your database. **StateFrom** field contains 2 letter state abbreviation of the state where the person from, and **StateLives** contains the state abbreviation of the state where the person lives now. State table contains **StateID** - this 2 letter key and **StateName** - long state name. 

&lt;table class="clear"&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style="border:none"&gt;
				&lt;table class="clear"&gt;   
					&lt;thead&gt;
						&lt;tr&gt;&lt;th&gt;People&lt;/th&gt;&lt;/tr&gt;
					&lt;/thead&gt;
					&lt;tbody&gt;
						&lt;tr&gt;&lt;td&gt;PersonID&lt;/td&gt;&lt;/tr&gt;
						&lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;/tr&gt;
						&lt;tr&gt;&lt;td&gt;StateFrom&lt;/td&gt;&lt;/tr&gt;
						&lt;tr&gt;&lt;td&gt;StateLives&lt;/td&gt;&lt;/tr&gt;
						&lt;tr&gt;&lt;td&gt;Phone&lt;/td&gt;&lt;/tr&gt;
					&lt;/tbody&gt;
				&lt;/table&gt;   
			&lt;/td&gt;
			&lt;td style="border:none" width="10%"&gt;&lt;/td&gt;
			&lt;td style="border:none"&gt;
				&lt;table class="clear"&gt;   
					&lt;thead&gt;
						&lt;tr&gt;&lt;th&gt;States&lt;/th&gt;&lt;/tr&gt;
					&lt;/thead&gt;
					&lt;tbody&gt;
						&lt;tr&gt;&lt;td&gt;StateID&lt;/td&gt;&lt;/tr&gt;
						&lt;tr&gt;&lt;td&gt;StateName&lt;/td&gt;&lt;/tr&gt;
					&lt;/tbody&gt;
				&lt;/table&gt;   
			&lt;/td&gt;
			&lt;td style="border:none" width="70%"&gt;&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

Open Data Model Editor and add People table. After this add States table twice and set Table Aliases to 'StateFrom' for the first table and 'StateLives' for the second. Add 2 different links to table People:

1) People.StateFrom → StateFrom.SateId

2) People.StateLives → StateLives.SateId

Then go to the Fields page and create two fields:

1) “State person from” which corresponds to StateName field from the States table with StateFrom alias

2) “State person lives now” - corresponds to StateName field from States table with StateLives alias.

Now your users can create queries and use 2 States tables which a really connected to one table in the database. SQL standard allows you to create such queries when you use aliases and Simple Query does too. See the example on the picture: 

![Data Model Editor - query example](/files/test/easyquery-dotnet/images/dme-query.png)

Here we ask for the people who have arrived from California and do not live in Oregon now. </Content>
    <Tags>,data-model,code-sample,dme,tables,links,</Tags>
  </Article>
  <Article id="271405ea-db6f-4aa4-910e-3b80bcf9f333" title="StringTokenizer class">
    <Content>```csharp
public class Korzh.EasyQuery.StringTokenizer

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | FullToken |  | 
| `TokenType` | LastBreak |  | 
| `Int32` | Position |  | 
| `Boolean` | ProcessAIdents |  | 
| `Int32` | TokenStart |  | 
| `TokenType` | TokType |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | FirstToken() |  | 
| `String` | NextToken() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="27227f79-bd86-49a1-b19f-8a14a0646cd9" title="QueryParamList class">
    <Content>```csharp
public class Korzh.EasyQuery.QueryParamList
    : Collection&lt;QueryParam&gt;, IList&lt;QueryParam&gt;, ICollection&lt;QueryParam&gt;, IEnumerable&lt;QueryParam&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;QueryParam&gt;, IReadOnlyCollection&lt;QueryParam&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | ClearGeneratedParams() |  | 
| `void` | CloneParamsFrom(`QueryParamList` prms) |  | 
| `void` | ExtractFromExpr(`String` expr) |  | 
| `QueryParam` | FindById(`String` paramId) |  | 
| `String` | GenNextParamId(`String` paramIdBase, `String&amp;` suffix) |  | 
| `Int32` | IndexById(`String` paramId) |  | 
| `void` | InsertItem(`Int32` index, `QueryParam` item) |  | 
| `void` | LoadFromJsonDict(`IEnumerable` paramList) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | ResetParamIdGenerator() |  | 
| `IEnumerable` | SaveToJsonDict(`DataModel` model) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="27c37443-5498-4c34-b1d5-67db5aae7500" title="Query with table joins">
    <Content>&lt;div class="row"&gt;
  &lt;div class="col-md-12 c-content-media-1 krh-blogpost"&gt;
  &lt;p&gt;Let’s make our example more interesting. Suppose we would like to see all orders for USA customers. For each order we want to see the name of customer, order date and sum. All results rows must be sorted by order date.&lt;/p&gt;
  &lt;p&gt;To get this data by SQL we need to join two tables (Customers and Orders), list necessary columns in SELECT clause and add ORDER By clause:&lt;/p&gt;
  &lt;pre&gt;
&lt;code class="sql"&gt;SELECT Ord.OrderDate, Cust.CompanyName, Ord.Freight
FROM Customers AS Cust
  JOIN Orders AS Ord ON (Ord.CustomerID = Cust.CustomerID ))
WHERE
  Cust.Country = 'USA'
ORDER BY Ord.OrderDate
&lt;/code&gt;
&lt;/pre&gt;
  &lt;p&gt;Here are the point where you can see how EasyQuery can simplify the process of query construction. All you need to do - is to add necessary columns into Columns panel and set the sorting order for Order date column. EasyQuery will take care about the rest: tables joins, correct aliases for tables and columns, etc.&lt;/p&gt;
  &lt;p&gt;So, just click on “[Add column]” link, select Order | Date from menu. Then repeat this operator for Customer | Company Name and Order | Freight attributes. Finally, click on the first button in Order Date column row and select “Ascending” from the drop-down list.&lt;/p&gt;
  &lt;p&gt;Here is a screenshot what you will get in a result:&lt;/p&gt;
  &lt;div class="c-center"&gt;
  &lt;div class="krh-blog-ss-block"&gt;
  &lt;a href="~/static/easyquery/usecases/query-example-02.png" class="fancybox" data-fancybox-group="gallery" title="An example of query with a tables' join"&gt;
  &lt;img src="~/static/easyquery/usecases/query-example-02.png" alt="An example of query with a tables' join"&gt;
  &lt;/a&gt;
  &lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</Content>
    <Tags>,data-model,sql,table-join,code-sample,</Tags>
  </Article>
  <Article id="289beab3-7a3e-4289-9738-e5420f3f8eee" title="EditorsMap class">
    <Content>```csharp
public class Korzh.EasyQuery.EditorsMap
    : Collection&lt;ValueEditorEntry&gt;, IList&lt;ValueEditorEntry&gt;, ICollection&lt;ValueEditorEntry&gt;, IEnumerable&lt;ValueEditorEntry&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;ValueEditorEntry&gt;, IReadOnlyCollection&lt;ValueEditorEntry&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | AddEditor(`ValueEditor` editor) |  | 
| `ValueEditor` | FindEditor(`Operator` op, `DataType` type) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="2a0df359-6359-4c44-ac66-34c4b4d34af9" title="Version 3.6.0 release notes">
    <Content>Version 3.6.0 of EasyQuery adds a lot of new features, especially for ASP.NET MVC projects.
Here you will find a brief description of most important changes

## 1. FilterBar widget
FilterBar widget allows you to add a special filtering panel to your list (table) views. Here how it looks:
FilterBar: ad-hoc data filtering Click to enlarge
It's very easy to add FilterBar widget on your web page. We have created a unique HTML extension method for that:

```html
@Html.FilterBar()

  . . . . . . . . 

@section scripts {
  &lt;script src="@Url.Content("~/Scripts/eq.all.min.js")" type="text/javascript"&gt;&lt;/script&gt;
  &lt;script src="@Url.Content("~/Scripts/eq.view.grid.js")" type="text/javascript"&gt;&lt;/script&gt; 
}
```

To see how FilterBar works - open EqMvcDemoLinq sample project and open either Orders or Customers page there.

## 2. New JavaScrpt files for views

In addition to an eq.all.min.js file which contains the definition of primary EasyQuery.JS classes and UI widgets, we distribute few "view" scripts which allow you to define some basic functionality on your web-page quickly and easily. 
Before version 3.6.0 there was only one such script file: `eq.view.js`. Now we have 3 of them:

  * eq.view.basic.js - a default EasyQuery layout (it replaces eq.view.js from previous version)
  * eq.view.report.js - for ad-hoc reporting views
  * eq.view.grid.js - for a simple list (table) view with pagination and filtering (via FilterBar)


## 3. Pagination support in MVC edition
That was the most requested feature from our users. We didn't plan to implement this functionality since EasyQuery's main purpose - is to provide end-user with a friendly UI for data filtering or advanced search. However, developers want to get a complete solution which not only allows them to get some SQL or LINQ statement but also executes a generated query and shows the result set. 
That's why we add some basic functionality to support pagination on MVC views which use EasyQuery widgets. 
To see how it works - take a look at EqMvcDemoEF or EqMvcDemoLinq sample projects which are included in the distribution package.

## 4. New methods in Query and DataModel classes

If you create a database web-application, then most probably you have a few "List" views there where you need to display a list of model items. It's very likely that you also need to provide some search or filtering functionality on those views. To help you with these tasks new version of EasyQuery has two new methods in DataModel and Query classes:

  * DataModel.LoadFromType(Type type) - this method allows you to fill your DbModel object with the structure of some model class.
  * DynamicQuery(Query query) extension method allows filtering your list (IEnumerable or IQueryable) by conditions defined in Query object

Here is how it may work in your controller:
```c#
  public OrderController() {
  eqService = new EqServiceProviderDb();
 
  eqService.ModelLoader = (model, modelName) =&gt; {
  model.LoadFromType(typeof(Order));
  model.SortEntities();
  };
  
  }
  . . . . . . . .
 
  public ActionResult ApplyFilter(string queryJson, string optionsJson) {
  var query = eqService.LoadQueryDict(queryJson.ToDictionary());
 
  var list = db.Orders.DynamicQuery&lt;order&gt;(query);
  return View("_OrderListPartial", list);
  }
```

## 5. Upgrading from previous versions
All projects which use version 3.5.0 of EasyQuery will be compiled with version 3.6.0 without changes 
However, we suggest you consider the following recommendation to avoid any possible problems in future:

1) `eq.view.js` file is obsolete now. Use `eq.view.basic.js` instead.

2) If you take EasyQuery .js and .css files from our CDN - it's better to reference the files for exact version instead of using the ones in default catalog. For example, instead of the following script inclusions on your HTML page:
```html
&lt;link href="http://cdn.korzh.com/eq/themes/default/easyquery.css" rel="stylesheet" type="text/css" media="screen" /&gt;
&lt;link href="http://cdn.korzh.com/eq/themes/default/eqview.css" rel="stylesheet" type="text/css" /&gt;
```

use these ones:

```html
&lt;link href="http://cdn.korzh.com/eq/3.6.0/themes/default/easyquery.css" rel="stylesheet" type="text/css" media="screen" /&gt;
&lt;link href="http://cdn.korzh.com/eq/3.6.0/themes/default/eqview.css" rel="stylesheet" type="text/css" /&gt;
```
  

3) If you used the same layout as in our sample projects (EqMvcDemoDB and others) you would need to make a few modifications in your HTML and CSS files:

* Add container around a &lt;div&gt; element which acts as a placeholder for EntitiesPanel widget. So in result it will should the following way:

```html
&lt;div class="entities-panel-container"&gt;
  &lt;!-- EntitiesPanel widget placeholder --&gt;
  &lt;div id="EntitiesPanel"&gt;&lt;/div&gt;
&lt;/div&gt;
```

  * Use the same approach for ColumnsPanel and QueryPanel widgets:
```html
&lt;div class="columns-panel-container"&gt;
  &lt;!-- ColumnsPanel widget placeholder --&gt;
  &lt;div id="ColumnsPanel"&gt;&lt;/div&gt;
&lt;/div&gt;
. . . . . .
&lt;div class="query-panel-container"&gt;
  &lt;!-- QueryPanel widget placeholder --&gt;
  &lt;div id="QueryPanel"&gt;&lt;/div&gt;
&lt;/div&gt;
```

* Some CSS classes are marked as deprecated in new version. You need to change them in all elements where they used:
  * `condition-block` to `conditions-block` 
  * `condition-hr hr` to `conditions-hr hr`
  * `condition-title` to `conditions-title`
  

4) Add new `Korzh.EasyQuery.Mvc.NETXX` assembly into your project if you want to use some JSON serialization/deserialization extension methods and HTML helpers (like Html.FilterBar() and others)
  

5) Use controller classes defined in our sample project as the templates for your own controller classs (EasyQueryController or whatever name you use) which implements data filtering and/or advanced search functionality in your project. Here are the sample projects you can use:
  * EQMvcDemoDb - uses EasyQuery with direct connection to database and SQL query language.
  * EQMvcDemoEF - uses EasyQuery with EnityFramework and Entity SQL as query langauge.
  * EQMvcDemoLinq - uses EntityFramework and LINQ with the help of new methods: LoadFromType and DynamicQuery
  * EQMvcDemoDb - uses EasyQuery to implement a web-page with ad-hoc reporting.
</Content>
    <Tags>,code-sample,mvc,javascript,entity-framework,asp-net,</Tags>
  </Article>
  <Article id="2a2b2de5-3b29-4848-9a67-4c3ea0b213f3" title="Value Editors">
    <Content>Here you can find the full list of editors and choose any you need in your work with Data Model: 

* **Auto**: means that the most appropriate value editor will be used depending on entity attribute's data type and operator which applied in a condition. For example for date attribute - DataTime Picker control will be shown, for boolean one - the user will get an ability to select the value from the list of two items: False and True.

* **Text editor**: the values will be edited in usual text box field. You can specify default value and type of edited data for this editor.

* **Date/time editor**: query panel will show date/time picker control for elements with such value editor.

* **List of constants**: a user will be prompted to select one (or more in a case of using “is in list” operator) value from the list of available values. Values column stands for values accepted as the choice result (and inserted into SQL text); Text is similar to the text items displayed to a user in the pop-up list.

* **Custom list**: the same behavior as in the previous case but this editor does not allow you to enter the list itself. Instead, you can specify the name for this list and fill it at runtime in RequestList event handler of QueryPanel control.

* **SQL list**: Similar to previous two options, but the list of available values a by some SQL query to a database. The first column of the resulting recordset is interpreted as an actual value which will be used in result SQL statement and the second one is used as captions (the text shown to the user).

* **Custom**: The programmer should provide the value editor for this field manually using a special event in QueryPanel component. There is an auxiliary text field “Custom Data” where the developer can enter any textual information and get access to it at run-time through CustomData property of any condition object.
</Content>
    <Tags>,data-model,dme,sql,query-panel,</Tags>
  </Article>
  <Article id="2a67d66b-0072-4cf3-9971-d933544d427b" title="EdgeInfo class">
    <Content>```csharp
public class Korzh.EasyQuery.EdgeInfo

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | InnerProperty |  | 
| `ObjectModelType` | InnerType |  | 
| `String` | OuterProperty |  | 
| `ObjectModelType` | OuterType |  | 


</Content>
    <Tags />
  </Article>
  <Article id="2c6dee5f-bd4a-4248-ae0b-1b573709df08" title="EasyQuery ASP.NET - using jQuery widgets on WebForms project">
    <Content>While we have native WebForms controls which can be used in your project, sometimes it's more convenient to use our jQuery widgets even in WebForms project and set up a kind of “controller” for them on server-side using web-service. 

## 1. Create data model

Run Data Model Editor application in wizard mode (“Create Data Model” program icon) and follow the instructions to create a new data model for your database. You will define database tables you would like to use in your queries, links between them and entities with their attributes (mostly fields in added tables). When the model is created - save it to some file on your hard-drive (let it be model1.xml for example);

## 2. Add the references to EasyQuery libraries.

Then open your project and add the following assemblies to its References list:

* Korzh.EasyQuery.NET40
* Korzh.EasyQuery.Db.NET40
* Korzh.EasyQuery.Services.Db.NET40

We listed here the names of .NET 4.0 assemblies. Use the similar assemblies but with another “suffix” if you have another target platform. For example, the assemblies ending on ”.NET45” should be used for .NET 4.5 platform and so on.

## 3. Setup a web-service class

To handle AJAX requests from client-side controls (widgets) you need some web-service or controller on your server side. EasyQuery library contains EqServiceProviderDb class which allow you to define such service very easily and in the shortest time.

First of all, add a new WebService class into your project. Right-click on your project node in Solution Explorer, select “Add | New Item” and then choose “Web Service” from the item templates. Change the default name of new web-service to “EasyQueryWebService.asmx” and click Add button. Then open EasyQueryService.asmx.cs and copy the following default implementation: 

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Services;
using System.Data.OleDb;
 
using Korzh.EasyQuery.Db;
using Korzh.EasyQuery.Services;
using Korzh.EasyQuery.Services.Db;
using System.Web.Script.Serialization;
using System.Collections;
 
namespace WebDemoAjaxCS {
  /// &lt;summary&gt;
  /// Summary description for EasyQueryWebService
  /// &lt;/summary&gt;
  [WebService(Namespace = "http://korzh.com/")]
  [WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
  [System.ComponentModel.ToolboxItem(false)]
  [System.Web.Script.Services.ScriptService]
  public class EasyQueryWebService : System.Web.Services.WebService {
 
  private EqServiceProviderDb eqService;
 
  public EasyQueryWebService() {
  eqService = new EqServiceProviderDb();
  eqService.CustomListResolver = (listname) =&gt; {
  if (listname == "Regions") {
  return new List&lt;ListItem&gt; {
  new ListItem("CA","California"),
  new ListItem("OR","Oregon")
  };
  }
  return Enumerable.Empty&lt;ListItem&gt;();
  };
 
  //these two linese allows eqService object access Session to store the content of model and query between requests
  eqService.SessionGetter = key =&gt; Session[key];
  eqService.SessionSetter = (key, value) =&gt; Session[key] = value;
 
  //we will share Query object between this service and our .aspx page - so it's better to store it in session as well
  eqService.StoreQueryInSession = true;
 
  //Our demo project uses Access database - so we set an appropriate format here
  eqService.Formats.SetDefaultFormats(FormatType.MsAccess);
 
  //Make this property true if you use SqlServer and want to include schema name into generated SQL statements
  eqService.Formats.UseSchema = false;
 
  //Calculating the path to App_Data folder where our model file and our database (.mdb file) are stored
  string dataPath = System.Web.HttpContext.Current.Server.MapPath("~/App_Data");
  eqService.DataPath = dataPath;
 
  //Setting up the connection
  eqService.Connection = new OleDbConnection("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=" +
  System.IO.Path.Combine(dataPath, "Nwind.mdb") + ";Persist Security Info=False");
 
  }
 
  #region auxiliary functions
  /// &lt;summary&gt;
  /// Converts Dictionary object to JSON
  /// &lt;/summary&gt;
  /// &lt;param name="data"&gt;The dictionary.&lt;/param&gt;
  /// &lt;returns&gt;The correctly formatted JSON string that represents this dictionary&lt;/returns&gt;
  private string DictionaryToJson(IDictionary&lt;string, object&gt; dict) {
  return new JavaScriptSerializer().Serialize(dict);
  }
 
  /// &lt;summary&gt;
  /// Converts JSON string to Dictionary object.
  /// &lt;/summary&gt;
  /// &lt;param name="json"&gt;A JSON string.&lt;/param&gt;
  /// &lt;returns&gt;New IDictionary object created by JSON string passed in parameter&lt;/returns&gt;
  private IDictionary&lt;string, object&gt; JsonToDictionary(string json) {
  return new JavaScriptSerializer().Deserialize&lt;IDictionary&lt;string, object&gt;&gt;(json);
  }
 
  /// &lt;summary&gt;
  /// Converts IEnumerable object to JSON
  /// &lt;/summary&gt;
  /// &lt;param name="data"&gt;The IEnumerable object.&lt;/param&gt;
  /// &lt;returns&gt;The correctly formatted JSON string that represents this list&lt;/returns&gt;
  private string ListToJson(IEnumerable list) {
  return new JavaScriptSerializer().Serialize(list);
  }
 
  /// &lt;summary&gt;
  /// Flushes the content of the string passed in parameter into response stream
  /// &lt;/summary&gt;
  /// &lt;param name="s"&gt;&lt;/param&gt;
  private void FlushResult(string s) {
  Context.Response.Write(s); 
  }
 
  /// &lt;summary&gt;
  /// Flushes the content of the IDictionary object passed in parameter into response stream.
  /// Before writing to response the dictionary is serialized into JSON string
  /// &lt;/summary&gt;
  /// &lt;param name="dict"&gt;The IDictionary object&lt;/param&gt;
  private void FlushResult(IDictionary&lt;string, object&gt; dict) {
  Context.Response.Write(DictionaryToJson(dict));
  }
 
  /// &lt;summary&gt;
  /// Flushes the content of the IEnumerable object passed in parameter into response stream.
  /// Before writing to response the list is serialized into JSON string
  /// &lt;/summary&gt;
  /// &lt;param name="list"&gt;The IEnumerable object&lt;/param&gt;
  private void FlushResult(IEnumerable list) {
  Context.Response.Write(ListToJson(list));
  }
 
  #endregion
 
 
  /// &lt;summary&gt;
  /// Gets the model by its name
  /// &lt;/summary&gt;
  /// &lt;param name="modelName"&gt;The name of requested model. 
  /// If null or empty this method returns current model object stored in Session
  /// &lt;/param&gt;
  /// &lt;returns&gt;&lt;/returns&gt;
  [WebMethod(EnableSession=true)]
  public void GetModel(string modelName) {
  var model = eqService.GetModel(modelName);
  FlushResult(model.SaveToDictionary());
  }
 
  /// &lt;summary&gt;
  /// Gets the query by its name
  /// &lt;/summary&gt;
  /// &lt;param name="queryName"&gt;The name of the query. If null or empty this method returns current query object stored in Session&lt;/param&gt;
  /// &lt;returns&gt;&lt;/returns&gt;
  [WebMethod(EnableSession = true)]
  public void GetQuery(string queryName) {
  var query = eqService.GetQuery(queryName);
  FlushResult(query.SaveToDictionary());
  }
 
  /// &lt;summary&gt;
  /// It's called when it's necessary to synchronize query on client side with its server-side copy.
  /// Additionally this action can be used to return a generated SQL statement (or several statements) as JSON string
  /// &lt;/summary&gt;
  /// &lt;param name="queryJson"&gt;The JSON representation of the query .&lt;/param&gt;
  /// &lt;param name="optionsJson"&gt;The additional parameters which can be passed to this method to adjust query statement generation.&lt;/param&gt;
  /// &lt;returns&gt;&lt;/returns&gt;
  [WebMethod(EnableSession = true)]
  public void SyncQuery(string queryJson, string optionsJson) {
  IDictionary&lt;string, object&gt; queryDict = JsonToDictionary(queryJson);
  eqService.SyncQueryDict(queryDict);
 
  var statement = eqService.BuildQueryDict(queryDict, JsonToDictionary(optionsJson));
  Dictionary&lt;string, object&gt; dict = new Dictionary&lt;string, object&gt;();
  dict.Add("statement", statement);
  FlushResult(dict);
  }
 
 
  /// &lt;summary&gt;
  /// Saves the query.
  /// &lt;/summary&gt;
  /// &lt;param name="queryJson"&gt;The JSON representation of the query .&lt;/param&gt;
  /// &lt;param name="queryName"&gt;Query name.&lt;/param&gt;
  /// &lt;returns&gt;&lt;/returns&gt;
  [WebMethod(EnableSession = true)]
  public void SaveQuery(string queryJson, string queryName) {
  eqService.SaveQueryDict(JsonToDictionary(queryJson), queryName);
  Dictionary&lt;string, object&gt; dict = new Dictionary&lt;string, object&gt;();
  dict.Add("result", "OK");
  FlushResult(dict);
  }
 
  /// &lt;summary&gt;
  /// This action returns a custom list by list name and/or SQL statement (for SQLLIST value editors).
  /// &lt;/summary&gt;
  /// &lt;param name="options"&gt;List request options - an instance of &lt;see cref="ListRequestOptions"/&gt; type.&lt;/param&gt;
  /// &lt;returns&gt;&lt;/returns&gt;
  [WebMethod(EnableSession = true)]
  public void GetList(string listName, string sql) {
  ListRequestOptions options = new ListRequestOptions() { listName = listName, sql = sql };
  FlushResult(ListToJson(eqService.GetList(options)));
  //FlushResult("");
  }
 
 
  /// &lt;summary&gt;
  /// Executes the query passed as JSON string and returns the result record set (again as JSON).
  /// &lt;/summary&gt;
  /// &lt;param name="queryJson"&gt;The JSON representation of the query.&lt;/param&gt;
  /// &lt;param name="optionsJson"&gt;Different options in JSON format&lt;/param&gt;
  /// &lt;returns&gt;&lt;/returns&gt;
  [WebMethod(EnableSession = true)]
  public void ExecuteQuery(string queryJson, string optionsJson) {
  var query = eqService.LoadQueryDict(JsonToDictionary(queryJson));
  var sql = eqService.BuildQuery(query, JsonToDictionary(optionsJson));
 
  var resultSet = eqService.GetDataSetBySql(sql);
  Session["EQ_LAST_RESULT_SET"] = resultSet;
 
  var resultSetDict = eqService.DataSetToDictionary(resultSet, JsonToDictionary(optionsJson));
 
  Dictionary&lt;string, object&gt; dict = new Dictionary&lt;string, object&gt;();
  dict.Add("statement", sql);
  dict.Add("resultSet", resultSetDict);
 
  FlushResult(dict);
  }
 
  }
 
}
```
Most of the methods of this class are self-explanatory. Public methods are “service methods” (or “actions” concerning MVC controllers). They process AJAX requests from JavaScript widgets and return necessary data in JSON format. As you can see, all “magic” happens inside EqServiceProviderDb instance. You can configure its behavior through different properties and events. All configuration work is performed in EasyQueryWebService constructor as you can see. 

## 4. Client-side scripts and CSS files

Now we move from server-side code to client-side. You should include the necessary scripts and CSS files to your page(s). First of all, we need jQuery, and jQuery UI scripts and CSS files since EasyQuery controls are implemented as jQuery widgets. Secondly, the EasyQuery script itself and corresponding CSS files. We suggest you use the scripts and CSS files from our CDN since it always contains the latest versions. You can find local copies of those files in \JS sub-folder of EasyQuery's installation folder. Additionally, you may need to define the easyQuerySettings global variable which contains different options and callbacks for EasyQuery widgets.

Here is an example of the main additions to your .aspx file
```
&lt;head&gt;
  . . . . . . . .
 
  &lt;link href="http://cdn.korzh.com/eq/3.7.0/themes/default/easyquery.css" rel="stylesheet" type="text/css" media="screen" /&gt;
  &lt;link href="http://cdn.korzh.com/eq/3.7.0/themes/default/eqview.css" rel="stylesheet" type="text/css" /&gt;
 
  &lt;script src="http://code.jquery.com/jquery-1.10.2.js"&gt;&lt;/script&gt;
  &lt;script src="http://code.jquery.com/ui/1.10.3/jquery-ui.js"&gt;&lt;/script&gt;
  &lt;link href="http://code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css" rel="stylesheet" type="text/css" /&gt;
  &lt;script type="text/javascript" src="https://www.google.com/jsapi"&gt;&lt;/script&gt;
 
  &lt;!-- EasyQuery widgets settings --&gt;
  &lt;script type="text/javascript"&gt;
 
  // Load the Visualization API and the piechart package (not necessary in general case).
  //google.load('visualization', '1.0', { 'packages': ['corechart'] });
 
  // Set a callback to run when the Google Visualization API is loaded.
  //google.setOnLoadCallback(GoogleVisualizationLoaded);
 
  function GoogleVisualizationLoaded() {
  //Visualization loaded!!!
  }
 
 
  //Settings for EasyQuery widgets 
  window.easyQuerySettings = {
  serviceUrl: "/EasyQueryWebService.asmx",
  modelName: "NWindMDB",
  loadQueryOnStart: true,
  entitiesPanel: { showCheckboxes: true },
  columnsPanel: { allowAggrColumns: true, attrElementFormat: "{entity} {attr}", showColumnCaptions: true, adjustEntitiesMenuHeight: false },
  queryPanel: { alwaysShowButtonsInPredicates: false, adjustEntitiesMenuHeight: false, menuSearchBoxAfter: 20 },
  syncQueryOptions: {
  sqlOptions: { SelectDistinct: true }
  },
 
  listRequesHandler: function (params, onResult) {
  //listRequest event handler goes here
  }
 
  };
  &lt;/script&gt;
  . . . . . . . .
&lt;/head&gt;
&lt;body&gt;
  . . . . . . . . 
 
  &lt;!--- place these scripts at the end of your page, before closing body tag --&gt;
  &lt;script src="http://cdn.korzh.com/eq/3.7.0/eq.all.min.js" type="text/javascript"&gt;&lt;/script&gt;
  &lt;script src="http://cdn.korzh.com/eq/3.7.0/eq.view.basic.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/body&gt;
```

## 5. Web-page code

Finally we need to define our visual widgets on the web-page and connect them with our server-side service. First of all we need to define the placeholders for our widgets into your .aspx file: 

```
&lt;!--Placeholder for Entities panel --&gt;
&lt;div id="EntitiesPanel"&gt;&lt;/div&gt;
. . . . . . . . . . 
&lt;!--Placeholder for Columns panel --&gt;
&lt;div id="ColumnsPanel"&gt;&lt;/div&gt;
. . . . . . . . . .
 
&lt;!--Placeholder for Query (conditions) panel --&gt; 
&lt;div id="QueryPanel"&gt;&lt;/div&gt;
```

 It's better to give them the same IDs as in the example above since in this case, they will be automatically accessible by EasyQuery's client-side scripts without additional configuration.

Usually, you need some default functionality to clear your current query, load/save and execute it. Our scripts have a default implementation for all these operations and to make them work - you just need to define the placeholders for corresponding buttons. 

```
&lt;div id="ClearQueryButton" class="eqv-button clear-button"&gt;Clear query&lt;/div&gt;
&lt;div id="LoadQueryButton" class="eqv-button load-query-button"&gt;Load query&lt;/div&gt;
&lt;div id="SaveQueryButton" class="eqv-button save-query-button"&gt;Save query&lt;/div&gt;
```

 As in a case of widget placeholders, you should define them with exactly the same IDs. The names of style classes can be different - the ones which are listed here are from our default style theme defined in an eqview.css file.

It will work out-of-box if you define the widget placeholders and buttons as it's described above. All the functions which control this default behavior are defined in an eq.view.js file which is distributed with full, unminified source code - so you can see how it works and change the way it works if necessary.

## 6. Sample project

You can download a sample project which implements all functionality described in this article directly from our [web-site](http://korzh.com/download/EqWebFormsDemo.zip). 
</Content>
    <Tags>,asp-net,webforms,web-service,javascript,widgets,code-sample,</Tags>
  </Article>
  <Article id="2d4bd528-1528-4b16-98e4-e2328b4475bb" title="ConditionsChangeEventArgs class">
    <Content>```csharp
public class Korzh.EasyQuery.ConditionsChangeEventArgs
    : EventArgs

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Condition` | Condition |  | 
| `Int32` | Info |  | 
| `ChangeType` | What |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `ConditionsChangeEventArgs` | Default |  | 


</Content>
    <Tags />
  </Article>
  <Article id="2fff8a00-86a5-49c6-a3df-a4b4e44c6353" title="TextStorageMap class">
    <Content>```csharp
public class Korzh.Utils.TextStorageMap
    : Dictionary&lt;String, TextStorage&gt;, IDictionary&lt;String, TextStorage&gt;, ICollection&lt;KeyValuePair&lt;String, TextStorage&gt;&gt;, IEnumerable&lt;KeyValuePair&lt;String, TextStorage&gt;&gt;, IEnumerable, IDictionary, ICollection, IReadOnlyDictionary&lt;String, TextStorage&gt;, IReadOnlyCollection&lt;KeyValuePair&lt;String, TextStorage&gt;&gt;, ISerializable, IDeserializationCallback

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `TextStorage` | GetStorage(`String` storageId = null) |  | 
| `void` | ReloadNativeResources(`String` storageId = null) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="3260c179-e39d-470a-87a4-cb70cfb3c187" title="Aggregate data">
    <Content>&lt;div class="row"&gt;
  &lt;div class="col-md-12 c-content-media-1 krh-blogpost"&gt;
  &lt;p&gt;We often need not only to extract data from database but to calculate something - total orders sum, average weight, count of participants, etc.&lt;/p&gt;
  &lt;p&gt;Let’s suppose we want to calculate total orders count. In SQL we use the COUNT function like this:&lt;/p&gt;
  &lt;pre&gt;
&lt;code class="sql"&gt;SELECT COUNT(Ord.OrderID) AS [Order Count] 
FROM Orders AS Ord&lt;/code&gt;
&lt;/pre&gt;
  &lt;h2&gt;Let’s do it using EasyQuery.&lt;/h2&gt;
  &lt;p&gt;First, add a column - click on “[Add column]” link, select “Order | OrderID” menu item. Then click the Function button on the right side of the column and select “Count” menu item.&lt;/p&gt;
  &lt;div class="c-center"&gt;
  &lt;div class="krh-blog-ss-block"&gt;
  &lt;a href="~/static/easyquery/usecases/aggregate-data-1.gif" class="fancybox" data-fancybox-group="gallery" title="EasyQuery example: aggregate data"&gt;
  &lt;img src="~/static/easyquery/usecases/aggregate-data-1.gif" alt="EasyQuery example: aggregate data"&gt;
  &lt;/a&gt;
  &lt;/div&gt;
  &lt;/div&gt;
  &lt;h2&gt;Let’s complicate the task&lt;/h2&gt;
  &lt;p&gt;Now our goal is to calculate count of orders made during current year and grouped by customer country.&lt;/p&gt;
  &lt;p&gt;Expected SQL:&lt;/p&gt;
  &lt;pre&gt;&lt;code class="sql"&gt;SELECT Cust.Country AS [Customer Country], COUNT(Ord.OrderID) AS [Order OrderID Count] 
FROM (Customers AS Cust
  RIGHT OUTER JOIN Orders AS Ord ON (Ord.CustomerID = Cust.CustomerID ))
WHERE
(
  Ord.OrderDate &gt;= #2014-01-01# )
GROUP BY Cust.Country
ORDER BY 1
&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;You need some knowledge to generate it, right? But not with EasyQuery!&lt;/p&gt;
  &lt;p&gt;First, add a condition to set “during this year” restriction. Click “Add condition”, select “Order | Date” from the menu. Then change the operator - click on “is equal to” link and select “after (special)”. At last, click on “Today” link and select “First day of the year”&lt;/p&gt;
  &lt;p&gt;Then add a new column “Customer | Country” as described above. Just to get more presentable result drag this column to the first place, then tell it to sort results by Country ascending (click the button with arrows on the left side of Country column and select “Ascending” menu item).&lt;/p&gt;
  &lt;p&gt;
  Voila!
  &lt;/p&gt;
  &lt;p&gt;Note, that you don’t need to think about columns to group by - all columns that are not aggregated are automatically used to group by them.&lt;/p&gt;
  &lt;div class="c-center"&gt;
  &lt;div class="krh-blog-ss-block"&gt;
  &lt;a href="~/static/easyquery/usecases/aggregate-data-2.gif" class="fancybox" data-fancybox-group="gallery" title="EasyQuery example: aggregate data"&gt;
  &lt;img src="~/static/easyquery/usecases/aggregate-data-2.gif" alt="EasyQuery example: aggregate data"&gt;
  &lt;/a&gt;
  &lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</Content>
    <Tags>,data-model,code-sample,aggregate-function,sql,</Tags>
  </Article>
  <Article id="33a5ac2d-0127-4454-b13b-d64787fb92c8" title="ScalarExprOptions class">
    <Content>```csharp
public enum Korzh.EasyQuery.ScalarExprOptions
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | Empty |  | 
| `1` | CaseInsensative |  | 
| `2` | Parameterized |  | 


</Content>
    <Tags />
  </Article>
  <Article id="356bd7e8-94ae-4f1d-bd4e-877a70e201d4" title="Operator class">
    <Content>```csharp
public class Korzh.EasyQuery.Operator

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | expr |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `DataTypeList` | AppliedTypes |  | 
| `String` | Caption |  | 
| `Boolean` | CaseInsensitive |  | 
| `String` | ConstValueFormat |  | 
| `Operand` | DefaultOperand |  | 
| `String` | DisplayFormat |  | 
| `String` | Expr |  | 
| `OperatorGroup` | Group |  | 
| `String` | ID |  | 
| `Boolean` | IsCondition |  | 
| `Boolean` | IsRange |  | 
| `String` | MainText |  | 
| `String` | MathSymbol |  | 
| `DataModel` | Model |  | 
| `OperandList` | Operands |  | 
| `Int32` | ParamCount |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | CalcParamCount() |  | 
| `Operand` | GetOperand(`Int32` operandIndex) |  | 
| `void` | LoadAttribute(`String` propname, `String` propvalue) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | LoadNodes(`XmlReader` reader) |  | 
| `void` | SaveAttributes(`XmlWriter` writer) |  | 
| `void` | SaveNodes(`XmlWriter` writer) |  | 
| `JsonDict` | SaveToJsonDict() |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 
| `String` | ToString() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="35d87cf6-fca0-4a71-91c5-b0d44330f9c7" title="Upgrading from version 3.x to 4.0">
    <Content>## 1. Change your assemblies
In version 3.x you referenced EasyQuery assemblies stored somewhere on your hard drive. This approach does not work anymore in ASP.NET Core application instead you need to reference Nuget packages.
The number of EasyQuery assemblies has been increased to reflect the modular approach used in .NET Core.
Here is an example of a .csproj section which references EasyQuery packages in a typical ASP.NET Core project with Entity Framework:
 
```xml
   &lt;PackageReference Include="Korzh.EasyQuery" Version="4.0.0" /&gt;
   &lt;PackageReference Include="Korzh.EasyQuery.Db" Version="4.0.0" /&gt;
   &lt;PackageReference Include="Korzh.EasyQuery.Json" Version="4.0.0" /&gt;
   &lt;PackageReference Include="Korzh.EasyQuery.Linq" Version="4.0.0" /&gt;
   &lt;PackageReference Include="Korzh.EasyQuery.AspNetCore" Version="4.0.0" /&gt;
   &lt;PackageReference Include="Korzh.EasyQuery.EntityFrameworkCore.Relational" Version="4.0.0" /&gt;
```
 
## 2. Change your controller’s methods
EasyQuery widgets from version 3.x used `application/x-www-form-urlencoded` content type to send data from client to the server.
Version 4.0 widgets send data in plain JSON - so you need to change the signature of all action method in your EasyQueryController (or whatever name you gave it) class.
The easiest way to do it - download the latest sample project from [GitHub](https://github.com/easyquery/AspNetCoreSamples) and copy action methods from EasyQueryConroller.cs to your controller class. Most of the action methods have the same names as in version 3.x but slightly different set of parameters.
Here is an example of `SyncQuery` method:
 
Version 3.x
```c#
       [HttpPost]
       public ActionResult SyncQuery(string queryJson, string optionsJson) {
           var query = eqService.SyncQueryDict(queryJson.ToDictionary());
           var statement = eqService.BuildQuery(query, optionsJson.ToDictionary());
           Dictionary&lt;string, object&gt; dict = new Dictionary&lt;string, object&gt;();
           dict.Add("statement", statement);
           return Json(dict);
       }
```
 
Version 4.0
```c#
       [HttpPost]
       public IActionResult SyncQuery([FromBody] JsonDict jsonDict) {
           var queryDict = jsonDict["query"];
           var optionsDict = jsonDict["options"] as JsonDict;
           var query = eqService.SyncQueryDict(queryDict as JsonDict);
           var statement = eqService.BuildQuery(query, optionsDict);
           Dictionary&lt;string, object&gt; dict = new Dictionary&lt;string, object&gt;();
           dict.Add("statement", statement);
           return Json(dict);
       }
```
 
## 3. Add EasyQuery services to DI
To make it work properly, you need to register some EasyQuery services in Dependency Injection (DI) mechanism. There are one extension method `AddEasyQuery` which does all necessary work.
Call it in `ConfigureServices` method of your `Startup` class:
 
```c#
public void ConfigureServices(IServiceCollection services)
{
    .    .    .    .    .    .    .
    services.AddEasyQuery();
}
```

## 4. Change your EasyQuery.JS files
EasyQuery JavaScript and CSS files have been updated as well, so you need to use their latest versions.
You can either place them directly to your project’s `wwwroot` folder our use our CDN as in the previous version:
 
* https://cdn.korzh.com/eq/4.0/eq.all.min.js
* https://cdn.korzh.com/eq/4.0/eq.view.basic.js
* https://cdn.korzh.com/eq/4.0/eq.view.grid.js
* https://cdn.korzh.com/eq/4.0/eq.view.report.js
 
* https://cdn.korzh.com/eq/4.0/themes/default/easyquery.css
* https://cdn.korzh.com/eq/4.0/themes/default/eqview.css</Content>
    <Tags>,asp-net-core,code-sample,how-to,</Tags>
  </Article>
  <Article id="36421391-9b31-4079-a6ee-99dff6149e3f" title="Generating queries for 2 (or more) databases">
    <Content>This option is not available “out-of-the-box”, but you can do it using some tricks.

**1)** Run Data Model Editor (DME) and create a new data model based on connection to the first database. Add all the tables from that DB you need.

**2)** Then connect to another database using Model | Model Settings… menu item. Again add the tables you need from that database.

**3)** Add necessary links between tables from the first DB and tables from the second one.

**4)** Don't forget to set Formats.UseDbName option to `true` in your code:

`query1.Formats.UseDbName = true;`
</Content>
    <Tags>,entity-framework,data-model,dme,tables,</Tags>
  </Article>
  <Article id="36870bde-a40f-478e-b836-0602f3bc94e1" title="Create virtual (calculated) attribute in you model">
    <Content>## What are they for

There are 2 types of entity attributes in each data model:

* **data attributes** which are based on corresponding fields (columns) in some database table. At the beginning, all attributes in your model are “data attributes”. They are created automatically by meta-information of your database.
* **virtual attributes** are actually a kind of calculated columns. For example, you can create a “Full name” attribute for your “Employee” entity and define its expression like `Employees.FirstName + ' ' + Employees.LastName`

The main advantage of a virtual attribute is that you will not need to type full expression each type they would like to see such column in a result set or to use that expression in a query condition. It just can select this attribute (either in columns or conditions) the same way as they do for any other entity attribute in your model. EasyQuery will do the rest of the jobs automatically: it will add a necessary table(s) into result SQL, join them with other tables used in that query and add the expression defined for virtual attribute either in SELECT or WHERE clause.

## How to add

1) Run Data Model Editor and open your model there.

2) Go to the Entities tab and select the entity node where you would like to add a new virtual attribute.

3) Right-click on that node and select “Add virtual attribute” menu item.

4) Then you will need to define main properties of new attribute:

* Caption - it's a name with which this attribute will be presented to your end-users (when they select it in Columns or Conditions sections). Its “Full Name” in our example above.
* Expression - the exact SQL expression which is used in result SQL statement in the place of this attribute. It must include full field names include a table (like “Employees.FirstName” in our example).
* Used tables - it's the list of tables used in this attribute's expression. This list should be filled automatically, after you enter the expression. If not - add a table(s) manually used “Add” button.
* Data type - it's important to set a correct data type for a new attribute, so it will be correctly processed during SQL generation (quotes, formats, etc.).
* “Other options” section - it's the same as for data attribute. You can disable your new attribute for Conditions section (uncheck “Use in conditions” mark) or for Columns (“Use in result”). You can also mark it as “aggregate” - so EasyQuery will automatically add “GROUP BY” clause when this attribute is used in Columns section.
* Description - any text which describes your attribute. The value of this field can be shown as a tooltip when a user moves the mouse cursor over corresponding entity node in Entities Panel.

5) Finally, you need to define the list of operators which can be used with your attribute in conditions. Open “Operators” tab for your attribute (don't confuse it with global Operators tab - the one you need is inside “Entity/attribute properties” panel) and click on “Defaults” button to get a default list of operators suitable for this attribute. Of course, you can skip this step if you don't plan to use this attribute in conditions (“Use in conditions” option is turned off).

6) That's all. Save your model and tell your users about new attribute they can use in their queries.
</Content>
    <Tags>,data-model,virtual-attribute,dme,operator,</Tags>
  </Article>
  <Article id="38f7aec3-a819-40d2-945d-69ace39d6c3a" title="ValueEditorsList class">
    <Content>```csharp
public class Korzh.EasyQuery.ValueEditorsList
    : Collection&lt;ValueEditor&gt;, IList&lt;ValueEditor&gt;, ICollection&lt;ValueEditor&gt;, IEnumerable&lt;ValueEditor&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;ValueEditor&gt;, IReadOnlyCollection&lt;ValueEditor&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `ValueEditor` | FindByID(`String` editorId) |  | 
| `Int32` | IndexByID(`String` editorId) |  | 
| `String` | NormalizeId(`String` id) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="3e7357ce-9cc2-4298-947c-a6fdb1a756ca" title="GdtResultSet class">
    <Content>```csharp
public class Korzh.EasyQuery.Services.GdtResultSet
    : JsonDict, IDictionary&lt;String, Object&gt;, ICollection&lt;KeyValuePair&lt;String, Object&gt;&gt;, IEnumerable&lt;KeyValuePair&lt;String, Object&gt;&gt;, IEnumerable, IDictionary, ICollection, IReadOnlyDictionary&lt;String, Object&gt;, IReadOnlyCollection&lt;KeyValuePair&lt;String, Object&gt;&gt;, ISerializable, IDeserializationCallback, IEqResultSet

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | IsDataFillStarted |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Int32` | ColumnCount |  | 
| `IList&lt;JsonDict&gt;` | Columns |  | 
| `Int64` | RecordCount |  | 
| `IList&lt;JsonDict&gt;` | Rows |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | AddColumn(`String` columnId, `String` title, `Type` columnType) |  | 
| `Boolean` | ContainsTime(`DateTime` dt) |  | 
| `String` | GetGoogleTypeBySystemType(`Type` systemType) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="3e8cf6ed-c675-4d9f-989c-35e7fb69876c" title="OrderByStyles class">
    <Content>```csharp
public enum Korzh.EasyQuery.OrderByStyles
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | Numbers |  | 
| `1` | Names |  | 
| `2` | Aliases |  | 


</Content>
    <Tags />
  </Article>
  <Article id="3f3944db-2040-4fb1-a5b7-eb43286a014e" title="OperatorGroupList class">
    <Content>```csharp
public class Korzh.EasyQuery.OperatorGroupList
    : Collection&lt;OperatorGroup&gt;, IList&lt;OperatorGroup&gt;, ICollection&lt;OperatorGroup&gt;, IEnumerable&lt;OperatorGroup&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;OperatorGroup&gt;, IReadOnlyCollection&lt;OperatorGroup&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `OperatorGroup` | FindByName(`String` groupName) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="3fb658ba-2638-4923-bdc7-198910d2aeaf" title="Getting started for EasyQuery ASP.NET MVC">
    <Content>&gt; See also: [Getting started for ASP.NET WebForms](/easyquery/docs/getting-started/asp-net-webforms)

&amp;nbsp;             

To apply [EasyQuery ASP.NET](/easyquery#asp-net/) to your MVC web application please perform the following steps:

## 0. Install EasyQuery trial
Just open [EasyQuery webpage](https://korzh.com/easyquery), click on "Try it now" button and select the edition you need to download trial version. 
When the download is finished - run the setup file and follow the instructions.

## 1. Create data model

Open “EasyQuery ASP.NET” folder on your desktop and run Data Model Editor (DME) application in wizard mode (“Create Data Model” program icon). Follow the instructions to create a new data model for your database. You will need to add database tables (select the ones you allow your users to use in their queries), links between them and the entities with their attributes (usually they are added automatically when you add tables). When the model is created - save it to App_Data folder of your project (let name it MyModel.xml for example). For more information about data model and for more detailed instructions on how to create it - please read:

   1. [About data model](https://korzh.com/easyquery/docs/fundamentals/data-model)
   2. [Creating new data model using Data Model Editor](https://korzh.com/easyquery/docs/getting-started/new-data-model)

## 2. Add references to EasyQuery libraries.

Then open your project and add the following assemblies to References list:

  - Korzh.EasyQuery.NET45
  - Korzh.EasyQuery.Db.NET45
  - Korzh.EasyQuery.Services.Db.NET45

We listed here the names of .NET 4.5 assemblies. Use the similar assemblies but with another “suffix” if you have another target platform. For example, the assemblies ending on ”.NET40” should be used for .NET 4.0 platform and so on.

## 3. Setup MVC controller

To handle AJAX requests from client-side controls (widgets) you need some web-service or controller on your server side. EasyQuery library contains several ready-to-use controllers which you can copy into your project. The controller you need can be taken from one of the sample projects distributed with EasyQuery. Open “EasyQuery ASP.NET” folder on your desktop, then go to “Samples” folder and select one of the sample projects listed there:

  - EQMvcDemoDb - for the case when EasyQuery is used with direct database connection and SQL query language;
  - EQMvcDemoEF - EasyQuery with EnityFramework and Entity SQL as query language;
  - EQMvcDemoLinq - EntityFramework and LINQ

Then copy EasyQueryController.cs file from Controllers folder of selected demo project to your project's Controllers folder. You may need to change some settings in controller's constructor. All code there are well commented - so you can easily modify necessary parts. For example, you can change SqlServerCe connection used in our demo to SqlServer connection. To make this change you will need to modify 2 lines of code in an original class. First - in using section change 

```sql
using System.Data.SqlServerCe;
```
to 

```sql
using System.Data.SqlClient;
```
 Then change the connection initialization code in controller's constructor.

From: 

``` .   .   .   .   .   .
    eqService.Connection = new SqlCeConnection("Data Source=" + System.IO.Path.Combine(dataPath, "Northwind.sdf"));
```
to

``` .   .   .   .   .   .
    eqService.Connection = new SqlConnection("Your connection string goes here");
```

## 4. Client-side scripts and CSS files

Now we move from server-side code to client-side. Here is the full list of a section you will need to add to your web page to use EasyQuery widgets on it:

  - EasyQuery CSS files.
  - EasyQuery script files.
  - EasyQuery widgets settings script (if necessary).
  - Placeholders for EasyQuery widgets.

Here is an example of .chtml file with all these sections included: 

```chtml
.   .   .   .   .   .   .   .   .
 
    &lt;!--EasyQuery CSS files --&gt;
    &lt;link href="~/Content/easyquery.css" rel="stylesheet" type="text/css" media="screen" /&gt;
    &lt;link href="~/Content/eqview.css" rel="stylesheet" type="text/css" /&gt;
 
    &lt;!-- Second option: EasyQuery CSS files from CDN --&gt;
&lt;!--
    &lt;link href="http://cdn.korzh.com/eq/3.8/themes/default/easyquery.css" rel="stylesheet" type="text/css" media="screen" /&gt;
    &lt;link href="http://cdn.korzh.com/eq/3.8/themes/default/eqview.css" rel="stylesheet" type="text/css" media="screen" /&gt;
--&gt;
 
 
    &lt;!-- EasyQuery widgets settings --&gt;
    &lt;script type="text/javascript"&gt;
 
        //Settings for EasyQuery widgets 
        window.easyQuerySettings = {
            serviceUrl: "/EasyQuery",
            modelName: "NWindSQL",
            entitiesPanel: { showCheckboxes: true },
            columnsPanel: { allowAggrColumns: true, attrElementFormat: "{entity} {attr}", showColumnCaptions: true, adjustEntitiesMenuHeight: false },
            queryPanel: { alwaysShowButtonsInPredicates: false, adjustEntitiesMenuHeight: false, menuSearchBoxAfter: 20 },
            syncQueryOptions: {
                sqlOptions: {SelectDistinct:true}
            },
 
            listRequesHandler: function (params, onResult) {
               //listRequest event handler goes here
            }
 
        };
 
	&lt;/script&gt;
 
    .   .   .   .   .   .   .   .   .
 
        &lt;!-- EntitiesPanel widget placeholder --&gt;
        &lt;div id="EntitiesPanel" class="entities-panel"&gt;&lt;/div&gt;
 
    .   .   .   .   .   .   .   .   .
 
        &lt;!-- ColumnsPanel widget placeholder --&gt;
        &lt;div id="ColumnsPanel" class="columns-panel"&gt;&lt;/div&gt;
 
    .   .   .   .   .   .   .   .   .
 
        &lt;!-- QueryPanel widget placeholder --&gt;
        &lt;div id="QueryPanel" class="query-panel"&gt;&lt;/div&gt;
 
   &lt;div id="footer"&gt;
        &lt;div class="copyright"&gt;
            © Copyright 2006-2016. &lt;a href="http://devtools.korzh.com/" target="_blank"&gt;Korzh.com&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
 
 
&lt;!-- jQuery and jQuery UI scripts --&gt; 
&lt;script src="http://code.jquery.com/jquery-2.1.1.js"&gt;&lt;/script&gt; 
&lt;script src="http://code.jquery.com/ui/1.10.3/jquery-ui.js"&gt;&lt;/script&gt;
 
 
&lt;!-- Google Visualization script (if you plan to use charts --&gt; 
&lt;script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"&gt;&lt;/script&gt;
 
 
&lt;!-- EasyQuery script files --&gt; 
&lt;script src="@Url.Content("~/Scripts/eq.all.min.js")" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="@Url.Content("~/Scripts/eq.view.basic.js")" type="text/javascript"&gt;&lt;/script&gt;
 
&lt;!-- Another option: use CDN versions of those files --&gt;
&lt;!--
    &lt;script src="http://cdn.korzh.com/eq/3.8/eq.all.min.js" type="text/javascript"&gt;&lt;/script&gt;
    &lt;script src="http://cdn.korzh.com/eq/3.8/eq.view.basic.js" type="text/javascript"&gt;&lt;/script&gt;
--&gt;
 
 
&lt;script type="text/javascript"&gt;
        // Load the Visualization API and the piechart package.
        google.charts.load('current', { 'packages': ['corechart'] }); 

        // Set a callback to run when the Google Visualization API is loaded.
        google.charts.setOnLoadCallback(GoogleVisualizationLoaded);

        function GoogleVisualizationLoaded() {
            //alert("Visualization loaded!!!");
        }
 
&lt;/script&gt;
```
To avoid writing all necessary code from scratch you can use EasyQuery.cshtml view file from our sample project as a template and then just modify it according to your needs.</Content>
    <Tags>,asp-net,mvc,javascript,data-model,controller,client-side,get-start,dme,code-sample,</Tags>
  </Article>
  <Article id="3fb6d495-45c0-40e7-aa3f-9d08a2ba90ae" title="Add query builder page from our MVC sample project in your own app">
    <Content>## The problem

You would like to add into your project the same query builder page (or with some little modifications) as in our EQMvcDemoDB sample project.

## The solution

### 1) EasyQuery assemblies, controller, and view

First of all, you need the controller and view file which will give your users the access to query builder page.

* Copy `EQMvcDemoDB\Controllers\EasyQueryController.cs` file to `YourProject\Controllers\`
* Change the namespace in EasyQueryController.cs to the one used in your project (e.g. `MyCompany.MyApplication`)
* Copy `EQMvcDemoDB\Views\EasyQuery\EasyQuery.cshtml` file to `YourProject\Views\EasyQuery`
* Add both files it into your project 
* Copy `EQMvcDemoDB\App_Data\NWindSQL.xml` file to `YourProject\App_Data`. Create `App_Data` folder if necessary.
* Add `App_Data\NWindSQL.xml` into your project. Set it's “Build Action” property to “Content” and “Copy to Output Directory” to “Always”.
* Reference the following EasyQuery assemblies in your project:
   * Korzh.EasyQuery.NET45.dll
   * Korzh.EasyQuery.Db.NET45.dll
   * Korzh.EasyQuery.Mvc.NET45.dll

Try to build your project. Our demo uses SQL Server Compact database (it's more convenient DB type for distribution), so all references to SqlCe classes and namespaces might not be compiled in your project. Simply comment them for now - we will modify them later.   
Run your project and check if the new page can be opened by /EasyQuery URL. The page will look quite ugly (since we haven't added any CSS files and scripts yet), but it must be opened without errors.

### 2) Style and scripts for the new page

Now we need to brush up the style of our new page. We have created special CSS files with default styles for EasyQuery widgets and QueryBuilder page. You need to copy those file into your project's folder, include them into the project and then link to your view page. Additionally, you will need to add some JavaScript files. First of all, we need JQuery and JQuery-UI scripts. Secondly - `eq.all.min.js` file which contains all EasyQuery widgets and `eq.view.basic.js` which contains some basic view functionality (load/save/execute queries). 
So:

* Copy `easyquery.css` and `eqview.css` files from `EQMvcDemoDb\Content\` to `YourProject\Content\`
* Include these CSS files into your project.
* Copy `eq.all.min.js` and `eq.view.basic.js` file from `EQMvcDemoDB\Scripts` to `YourProject\Scripts` and include both these files to your project.
* Add jQuery and jQuery UI scripts to your new `EasyQuery.cshtml` view if those libraries are not included into your layout view yet.
* Link jQuery UI styles. Again, this step is not necessary if jQuery UI .css files are already linked in your layout view.

Here is an example how your new view file may look like after all these changes:

```html
     .    .    .    .    .    .    .    .    .
  &lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"&gt;&lt;/script&gt;
  &lt;script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.10.1/jquery-ui.min.js"&gt;&lt;/script&gt;
 
  &lt;link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.10.1/themes/base/minified/jquery-ui.min.css" rel="stylesheet" type="text/css" /&gt;
   .    .    .    .    .    .    .
```
After that please try to open EasyQuery page once again. Now it must look much better but still does not provide any functionality since we haven't added any server-side code yet.

### 3) Updating EasyQuery controller, connecting to your DB
Currently, we use our demo model for NWind database - just to make sure that everything works as expected and we don't have any problem in our server-side code, view markup or scripts. Now it's time to make the final modifications and connect this new query builder page to your project's data.

But at first, we would like to make an overview of what happens "under the hood" when you open that page.
Your new "advanced search" page contains few JQuery UI widgets provided by EasyQuery script (eq.all.min.js): QueryPanel, ColumnsPanel and EntitiesPanel. Those widgets make AJAX calls to your server-side code to perform the following tasks:

* To get data model.
* To load/save queries.
* To build an SQL statement.
* To execute the generated SQL and get the result set.

All these actions are implemented in EasyQueryController class. The basic functionality is provided by the methods of the special `eqService` object of `EqServiceProviderDb` class. Each action method (like `GetModel`, `GetQuery`, `ExecuteQuery` and others) simply gets the request's parameters, pass them to the corresponding method of EqServiceProviderDb, pack the results into a proper format and returns them to the client.
So, in most cases, you will not need to modify any action method in EasyQueryController class. Instead, you will need to change some options of `eqService` to make it load your model, connect to your DB or to generate SQL statement with correct syntax.

So, here is what we are going to do:

 * First of all, you will need your data model. To create it - run Data Model Editor (installed with EasyQuery library), connect it to your DB and follow the instructions. After performing all these steps save your model into some file. Let's call this new model file `MyModel.xml`. For more information about creating a new model with Data Model Editor please read this [article](https://korzh.com/easyquery/docs/getting-started/new-data-model).

 * Copy `MyModel.xml` into `App_Data` folder, add it to the project and set its “Build Action” and “Copy to Output Directory” properties to the same values as for NWindSQL.xml file from the previous step.

* Now you need to tell `eqService` how to load your data model instead of NWindSQL. You can use `DefaultModelName` property for that. Additionally, you will need to modify the connection string and the formats for generated SQL statements. Let's suppose you use MS SQL database. So the initialization part of EasyQueryController for your case will look this way:

```c#
private EqServiceProviderDb eqService;

public EasyReportController() {
    eqService = new EqServiceProviderDb();

    eqService.Paging.Enabled = true;
    eqService.DefaultModelName = "MyModel";

    eqService.StoreModelInSession = true;
    eqService.StoreQueryInSession = true;
            
    string connectionString = ConfigurationManager.ConnectionStrings["Default"].ConnectionString;
    eqService.Connection = new SqlConnection(connectionString);

    //EqServiceProvider needs to know where to save/load queries to/from
    eqService.DataPath = System.Web.HttpContext.Current.Server.MapPath("~/App_Data");   

    //You can set DbConnection directly (without using ConfigurationManager)
    //eqService.Connection = new SqlConnection("Your connection string goes here");

    //to support saving/loading models and queries to/from Session 
    eqService.SessionGetter = key =&gt; Session[key];
    eqService.SessionSetter = (key, value) =&gt; Session[key] = value;

    .   .   .   .   .   .   .   .   .

    //other parts of EasyQueryController's constructor will be the same as in original file
```

That's all! Now your application has its own form for advanced search!

### 4) Alternative ways of model loading
If you use Entity Framework for working the DB - it's  necessary to create the model “manually” using Data Model Editor. EasyQuery allows you to load your model either from your `.edmx` file (in case of using DB-first approach) or from your DbContext object.
In both these cases, you will need to:
 *  reference `Korzh.EasyQuery.EF6.NET45` assembly in your project 
 *  define your own `ModelLoader` delegate handler in EasyQueryController's constructor and call model loading code there.   

Here are the examples:

Loading model from some .edmx file: 
```c#
public EasyReportController() {
    eqService = new EqServiceProviderDb();
    .    .    .    .    .    .    .    .    .
    
    eqService.ModelLoader = (model, modelName) =&gt; {
        string edmxFilePath = System.IO.Path.Combine(eqService.DataPath, "MyModel.edmx");
        model.LoadFromEdmx(edmxFilePath);   
     }; 

    .    .    .    .    .    .    .    .    .

```

Loading model from the DbContext: 
```c#
//loading from .edmx file
public EasyReportController() {
    eqService = new EqServiceProviderDb();
    .    .    .    .    .    .    .    .    .
    
    var context = new NorthwindDbContext();

    eqService.ModelLoader = (model, modelName) =&gt; {
        model.LoadFromDBContext(context);   
     }; 

    .    .    .    .    .    .    .    .    .

```</Content>
    <Tags>,mvc,asp-net,query-builder,code-sample,controllers,javascript,</Tags>
  </Article>
  <Article id="4185304a-33b3-413d-81e5-63c5fd50f9ee" title="Adhoc reporting page in your web application">
    <Content>## The problem
 
You would like to add into your project the same (or similar) page for adhoc reporting as in our [EasyReportDemo](http://demo.easyquerybuilder.com/adhoc-reporting) sample project.
 
## The solution
 

### 1) EasyQuery assemblies, controller, and view

First of all, you need the controller and view file which will give your users the access to query builder page.

* Reference the following EasyQuery assemblies in your project:
   * Korzh.EasyQuery.NET45.dll
   * Korzh.EasyQuery.Db.NET45.dll
   * Korzh.EasyQuery.Mvc.NET45.dll
* Copy `EasyReportDemo\Controllers\EasyReportController.cs` file to `YourProject\Controllers\`
* Change the namespace in EasyReportController.cs to the one used in your project (e.g. `MyCompany.MyApplication`)
* Copy `EasyReportDemo\Views\Home\EasyReport.cshtml` file to `YourProject\Views\Home\` folder
* Add both files it into your project 
* Add `EasyReport` action to your `HomeController`. Make it open `EasyReport` view page:
```c#
public ActionResult EasyReport()
{
    return View("EasyReport");
}
```
* Copy `EasyReportDemo\App_Data\NWindSQL.xml` file to `YourProject\App_Data`. Create `App_Data` folder if necessary.
* Add `App_Data\NWindSQL.xml` into your project. Set it's “Build Action” property to “Content” and “Copy to Output Directory” to “Always”.

Try to build your project. Our demo uses SQL Server Compact database (it's more convenient DB type for distribution), so all references to SqlCe classes and namespaces might not be compiled in your project. Simply comment them for now - we will modify them later.   
Run your project and check if the new page can be opened by `/Home/EasyReport` URL. The page will look quite ugly (since we haven't added any CSS files and scripts yet), but it must be opened without errors. 

### 2) Style and scripts for the new page
 
Now we need to brush up the style of our new page. We have created special CSS files with default styles for EasyQuery widgets and EasyReport page. You need to copy those file into your project's folder, include them into the project and then link them to your view page. Additionally, you will need to add some JavaScript files. First of all, we need JQuery and JQuery-UI scripts. Secondly - `eq.all.min.js` file which contains all EasyQuery widgets. 

So:
 
* Copy `easyquery.css` and `eqview.css` files from EasyReportDemo\Content\ to YourProject\Content\
* Include these CSS files into your project.
* Copy `eq.all.min.js` file from EasyReportDemo\Scripts to YourProject\Scripts and include this file into your project.
* Add jQuery, jQuery-UI and jQuery scripts into your new EasyReport.cshtml view at the beginning of "Scripts" section. You can skip this step if jQuery scripts are already included in your layout file (..\Views\Shared\_Layout.cshtml).
* Link jQuery UI styles. Again this step is not necessary if those .css files are already linked in your layout file.

All EasyQuery script and CSS files (`eq.all.min.js`, easyquery.css and others) must be already included in your view page since there were there in original EasyReport.cshtml you copied from our sample project.
 
Here is an example how your new view file may look like after all these changes:
 
```html
@{
  ViewBag.Title = "Adhoc reporting";
}
 
&lt;link href="http://code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css" rel="stylesheet" type="text/css" /&gt;
&lt;link href="~/Content/easyquery.css" rel="stylesheet" type="text/css" media="screen" /&gt;

.    .    .    .    .    .    .    .

@section Scripts {
    &lt;script src="http://code.jquery.com/jquery-1.11.1.js"&gt;&lt;/script&gt;
    &lt;script src="http://code.jquery.com/ui/1.11.2/jquery-ui.js"&gt;&lt;/script&gt;

    &lt;!-- EasyQuery script files --&gt; 
    &lt;script src="@Url.Content("~/Scripts/eq.all.min.js")" type="text/javascript"&gt;&lt;/script&gt;
    &lt;script src="@Url.Content("~/Scripts/eq.view.report.js")" type="text/javascript"&gt;&lt;/script&gt;
    &lt;script src="@Url.Content("~/Scripts/easychart.js")" type="text/javascript"&gt;&lt;/script&gt;
}
```
After that please try to open EasyReport page once again. Now it must look much better but still does not provide any functionality since we haven't added any server-side code yet.
 
### 3) Updating EasyQuery controller, connecting to your DB
Currently, we use our demo model for NWind database - just to make sure that everything works as expected and we don't have any problem in our server-side code, view markup or scripts. Now it's time to make the final modifications and connect this new query builder page to your project's data.

But at first, we would like to make an overview of what happens "under the hood" when you open that page.
Your new "advanced search" page contains few JQuery UI widgets provided by EasyQuery script (eq.all.min.js): QueryPanel and ColumnsBar. Those widgets make AJAX calls to your server-side code to perform the following tasks:

* To get data model.
* To load/save queries.
* To build an SQL statement.
* To execute the generated SQL and get the result set.

All these actions are implemented in EasyReportController class. The basic functionality is provided by the methods of the special `eqService` object of `EqServiceProviderDb` class. Each action method (like `GetModel`, `GetQuery`, `ExecuteQuery` and others) simply gets the request's parameters, pass them to the corresponding method of EqServiceProviderDb, pack the results into a proper format and returns them to the client.
So, in most cases, you will not need to modify any action method in EasyReportController class. Instead, you will need to change some options of `eqService` to make it load your model, connect to your DB or to generate SQL statement with the correct syntax.

So, here is what we are going to do:

 * First of all, you will need your data model. To create it - run Data Model Editor (installed with EasyQuery library), connect it to your DB and follow the instructions. After performing all these steps save your model into some file. Let's call this new model file `MyModel.xml`. For more information about creating a new model with Data Model Editor please read this [article](https://korzh.com/easyquery/docs/getting-started/new-data-model).

 * Copy `MyModel.xml` into `App_Data` folder, add it to the project and set its “Build Action” and “Copy to Output Directory” properties to the same values as for NWindSQL.xml file from the previous step.

* Now you need to tell `eqService` how to load your data model instead of NWindSQL. You can use `DefaultModelName` property for that. Additionally, you will need to modify the connection string and the formats for generated SQL statements. Let's suppose you use MS SQL database. So the initialization part of EasyQueryController for your case will look this way:
  
```c#

private EqServiceProviderDb eqService;

public EasyReportController() {
    eqService = new EqServiceProviderDb();

    eqService.Paging.Enabled = true;
    eqService.DefaultModelName = "MyModel";

    eqService.StoreModelInSession = true;
    eqService.StoreQueryInSession = true;
            
    string connectionString = ConfigurationManager.ConnectionStrings["Default"].ConnectionString;
    eqService.Connection = new SqlConnection(connectionString);

    //EqServiceProvider needs to know where to save/load queries to/from
    eqService.DataPath = System.Web.HttpContext.Current.Server.MapPath("~/App_Data");   

    //You can set DbConnection directly (without using ConfigurationManager)
    //eqService.Connection = new SqlConnection("Your connection string goes here");

    //to support saving/loading models and queries to/from Session 
    eqService.SessionGetter = key =&gt; Session[key];
    eqService.SessionSetter = (key, value) =&gt; Session[key] = value;

    .   .   .   .   .   .   .   .   .

    //other parts of EasyReportController's constructor will be the same as in original file

```

That's all! Now your application has its own form for adhoc-reporting!
 
### 4) Alternative ways of model loading
 
If you use Entity Framework for working the DB - it's  necessary to create the model “manually” using Data Model Editor. EasyQuery allows you to load your model either from your `.edmx` file (in case of using DB-first approach) or from your DbContext object.
In both these cases, you will need to:
 *  reference `Korzh.EasyQuery.EF6.NET45` assembly in your project 
 *  define your own `ModelLoader` delegate handler in EasyQueryController's constructor and call model loading code there.   
Here are the examples:

Loading model from some .edmx file: 
```c#
public EasyReportController() {
    eqService = new EqServiceProviderDb();
    .    .    .    .    .    .    .    .    .
    
    eqService.ModelLoader = (model, modelName) =&gt; {
        string edmxFilePath = System.IO.Path.Combine(eqService.DataPath, "MyModel.edmx");
        model.LoadFromEdmx(edmxFilePath);   
     }; 

    .    .    .    .    .    .    .    .    .

```

Loading model from the DbContext: 
```c#
//loading from .edmx file
public EasyReportController() {
    eqService = new EqServiceProviderDb();
    .    .    .    .    .    .    .    .    .
    
    var context = new NorthwindDbContext();

    eqService.ModelLoader = (model, modelName) =&gt; {
        model.LoadFromDBContext(context);   
     }; 

    .    .    .    .    .    .    .    .    .

```
</Content>
    <Tags>,asp-net,mvc,entity-framework,code-sample,query-builder,adhoc-reporting,</Tags>
  </Article>
  <Article id="41b8137f-d181-425a-92a1-a57d973dcb32" title="QueryParam class">
    <Content>```csharp
public class Korzh.EasyQuery.QueryParam

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | Caption |  | 
| `DataType` | DataType |  | 
| `String` | EditorId |  | 
| `String` | Id |  | 
| `Boolean` | IsGenerated |  | 
| `String` | Value |  | 
| `Object` | ValueAsObject |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | CopyFrom(`QueryParam` param) |  | 
| `void` | CoreReadXmlAttribute(`String` attrName, `String` attrValue) |  | 
| `void` | LoadFromJsonDict(`JsonDict` paramDict) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `JsonDict` | SaveToJsonDict(`DataModel` model) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="42f09029-15e5-4a55-83d2-910c88bd2e1e" title="Hide some entities and/or attributes">
    <Content>## Problem
Sometimes we need to hide certain entities and/or attributes from data model (for example for security reasons). There are several ways to limit the quantity of entities and attributes shown in Data Model, and here we explain how to implement it.

## Solution #0: Modify your model using Data Model Editor (DME)
In case your model is stored in some XML file you can just open it in DME and turn off `Use in result` and `Use in conditions` options for the entities and/or attributes you would like to hide. Here are the instructions:
 - Run DME
 - Open your model's XML file
 - Go to "Entities" tab
 - Select entity or attribute your would like to hide in the "Entities" tree view 
 - Uncheck `Use in result` and `Use in conditions` checkboxes for selected item in the right panel


## Solution #1: `RunThoughEntity` function 
Here is an article which [describes](https://korzh.com/easyquery/docs/how-to/run-through-data-model-entities) how to navigate through all entities in your model. To hide an entity from your model after loading it you just need to set `UseInResult` and `UseInConditions` properties for corresponding `Entity` object to `false`.

Add the following code to the `RunThroughEntity` function for the entities you would like to hide (we guess here that that is the entity named “User”):
```
If (entity.Name == “User”) {
  entity.UseInResult = false;
  entity.UseInConditions = false;
}
```
## Solution #2: `Scan` method in `Entity` class (Version 3.8.0 and later)

`Scan` method in `Entity` class works exactly as `RunThroughEntity` function. You can call that method for root entity of your model and pass a delegate which will be called for each sub-entity.

So you model loading code will be equal to the following:

```
model.LoadFromDBContext(YourDbContextObject); //here we can use any other way of model loading of course

model.EntityRoot.Scan(entity =&gt; {
  if (entity.Name == "User") {
  entity.UseInConditions = false;
  entity.UseInResult = false;
  } 
}, null, false);
```

## Solution #3: `Eq..` attributes for DbContext classes 

If you load data model right from DbContext, you can just add `EqEntity` and `EqEntityAttr` attributes in from of important class and property definitions. 
Here is an example:

```c#
  [EqEntity(UseInResult = false, UseInConditions=false)]
  public class Customer {

  [EqEntityAttr(UseInResult = false, UseInConditions=false)]
  public string Id { get; set; }
  
  . . . . . . 

```</Content>
    <Tags>,data-model,entity-framework,code-sample,dme,</Tags>
  </Article>
  <Article id="4358fd15-95c2-445a-9e6a-f962bc31c0d0" title="Add new operator into your data model">
    <Content>Each data model contains a lot of default operators. However, sometimes you may need to add a new operator to your model.

Let's suppose we need “within last N days” operator which words for date/time fields, takes a numeric operand (N) and returns true if specified date is within last N days starting from today.

Here are the instructions:

## 1) Open your model file

Run Data Model Editor utility (DME) and open your model (.xml) file (Model | Open… menu item).

## 2) Add new operator

Go to Operators tab and select “Operators | Add Operator” menu item. New operator with default ID “NewOp” will appear at the bottom of the list of operators. 

![Data Model Editor - add new operator](/files/test/easyquery-dotnet/images/dm-new-operator-01.png)

After that, we need to define all properties for a new operator.

## 3) Setting operator's properties

### ID: "DateWithinLastNDays"

This is mostly an internal property. EasyQuery will use to reference this operator in attributes and query conditions.

### Caption: "Last N days"

This value will be shown to users in a drop-down list when they select operator

### Display format: 
```
{expr1} [[is within last]] {expr2} days
```

This field defines how your operator (actually the whole condition with this operator) will look in a condition row in query panel. The part within [[ and ]] will be clickable.

### Expression: 
```
{expr1} &gt; DATEADD(day, -{expr2}, GETDATE())
```

The most important property for an operator. It defines the result expression which will come into generated SQL statement. {expr1} and {expr2} parts specify the operands. The first operand is always an attribute, second - some value entered by a user.

### Applied types: "Date, DateTime"

Since this operator can be used only with Date and DateTime attributes - we uncheck all options in “Applied types” field except these two.

Here is how Operators tab in DME looks like after all changes described above: 

![Data Model Editor - operator properties](/files/test/easyquery-dotnet/images/dm-new-operator-02.png)

## 4) Setting operand's properties

Each operator has one or more operands. By default, all operands have the same kind and data type, but this preset can be changed. In our case, we need the second operand to be numeric (integer if more precisely) data type. To set it - just open “Operands” tab, select “Default operand” item in the list and choose “Int” in “Data type” combo box. All other operand properties let be left with their default values.

N.B.: By default “data type” property has “Auto” value. It means that this operand will have the same type as attribute selected for the left part of the condition. It's useful for operators which can be applied to attributes with different data types (e.g. “is equal to”). 

![Data Model Editor - operand properties](/files/test/easyquery-dotnet/images/dm-new-operator-03.png)

## 5) Associate new operator with attribute(s)

Finally, we need to associate new operator with one or more attributes for which it may be used in query conditions. To do it:

* open “Entities” tab
* select necessary attribute
* open its “Operators” tab
* click on “Add” button, check new operator and click OK.

![Data Model Editor - associate operator with attributes](/files/test/easyquery-dotnet/images/dm-new-operator-04.png)

## 6) Done!

Finally, save your model and run the project which uses this model to test new operator: 

![Data Model Editor - new operator in the query panel](/files/test/easyquery-dotnet/images/dm-new-operator-05.png)</Content>
    <Tags>,data-model,operator,expression,</Tags>
  </Article>
  <Article id="43a667e0-4a9f-4b26-b6ad-bac37b22aac6" title="Test post">
    <Content />
    <Tags />
  </Article>
  <Article id="4444968b-7c90-4154-ac9d-ae163919b46a" title="IMacroValue class">
    <Content>```csharp
public interface Korzh.EasyQuery.IMacroValue

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Int32` | Count |  | 
| `DataType` | DataType |  | 
| `String` | ID |  | 
| `String` | Value |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | GetValue(`Int32` index) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="468b03d8-493d-43dc-acaa-2be939e51521" title="ListValueEditor class">
    <Content>```csharp
public class Korzh.EasyQuery.ListValueEditor
    : ValueEditor

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | ControlType |  | 
| `Boolean` | Multiselect |  | 


</Content>
    <Tags />
  </Article>
  <Article id="47b6d796-b6db-4f72-b7cf-84a5c79bc89d" title="IPaging class">
    <Content>```csharp
public interface Korzh.EasyQuery.Services.IPaging

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Int64` | PageCount |  | 
| `Int64` | PageIndex |  | 
| `Int64` | PageSize |  | 
| `Int64` | TotalRecords |  | 


</Content>
    <Tags />
  </Article>
  <Article id="4a590184-1265-457d-bdfd-bdd9806cbc12" title="Building data model dynamically by DB meta-information">
    <Content>You can avoid creating a data model XML file through Data Model Editor utility and fill your model right in the code directly from your database (or more precisely: by its meta-info).

To perform this task, you just need to create an appropriate instance of DbGate class (depending on DB and connection type you use), connect it to your database and call FillByDbGate() method of DbModel.

Here is an example: 

```
 //clear current model
  model.Clear();
 
  //add default operators
  model.AddDefaultOperators();
 
  //create a DbGate instance (this one is for SqlConnection, you can also use OleDbGate, OdbcGate, OracleGate, etc. ).
  Korzh.EasyQuery.DataGates.SqlClientGate sqlGate = new Korzh.EasyQuery.DataGates.SqlClientGate();
 
  //connect DbGate object to your database
  sqlGate.ConnectionString = @"Data Source=localhost;Initial Catalog=NWind;Integrated Security=True";
  sqlGate.Connected = true;
 
  //fill the model
  model.FillByDbGate(sqlGate, FillModelOptions.Default);
 
  //update visual controls 
  queryPanel1.UpdateModelInfo();
  columnsPanel1.UpdateModelInfo();
```

Please note: To create some DbGate object (like SqlClientGate) will need to add a corresponding assembly into the “References” section of your project. For exampl, to execute the code listed above you will need to reference Korzh.EasyQuery.DataGates.NET40.dll assembly.</Content>
    <Tags>,data-model,code-sample,dme,data-builder,</Tags>
  </Article>
  <Article id="4b66ae1a-5420-4a22-81e3-7d4eea257b53" title="Predicate class">
    <Content>```csharp
public abstract class Korzh.EasyQuery.Predicate
    : Condition

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | _isRoot |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `ConditionsStore` | Conditions |  | 
| `Boolean` | IsEmpty |  | 
| `Boolean` | IsRoot |  | 
| `LinkType` | Linking |  | 
| `String` | LinkingStr |  | 
| `String` | TypeName |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Predicate` | AddPredicate(`LinkType` lnkType) |  | 
| `SimpleCondition` | AddSimpleCondition(`String` attrId, `String` operatorId, `String[]` values) |  | 
| `SimpleCondition` | AddSimpleCondition(`EntityAttr` attr, `Operator` op, `EqExpression[]` exprs) |  | 
| `void` | BeginUpdate() |  | 
| `void` | CheckIfEnabled() |  | 
| `Boolean` | ContainsGhosts(`Condition&amp;` outCond) |  | 
| `void` | EndUpdate() |  | 
| `Condition` | FindCondByAttr(`EntityAttr` attr) |  | 
| `Boolean` | GetHaving() |  | 
| `Int32` | GetOffspringCount() |  | 
| `String` | GetPredicateHeader() |  | 
| `String` | GetText(`QueryTextFormats` formats, `String` levelSpace, `String` prefix) |  | 
| `IEnumerable&lt;Entity&gt;` | GetUsedEntities() |  | 
| `void` | LoadFromJsonDict(`JsonDict` dictPredicate) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | Reset() |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 
| `void` | SetEnabled(`Boolean` newValue) |  | 
| `void` | SetQuery(`Query` newQuery) |  | 
| `void` | SetReadOnly(`Boolean` newValue) |  | 
| `void` | WriteContent(`XmlWriter` writer) |  | 
| `void` | WriteSubNodesToXml(`XmlWriter` writer) |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeName |  | 


</Content>
    <Tags />
  </Article>
  <Article id="4c916810-6581-4ccd-b21b-244977b331cc" title="Upgrading from version 2.x to 3.0">
    <Content>Version 3.0 of EasyQuery introduces an essential update of the library since its first release. You can find more information about the changes we made in [this document](https://korzh.com/easyquery/release-notes/version-3.0.0). Here we introduce a step-by-step description what changes you need to do in your project to make it compatible with version 3.0 of EasyQuery.

## 1. Remove all old assemblies from your project's references

These assemblies Korzh.WebControls.CLR40, Korzh.EasyQuery.CLR40 and Korzh.EasyQuery.WebControls.CLR40 should be removed from your project. Here we have indicated only the assemblies for WebForms (ASP.NET) edition of EasyQuery and for the .NET 4.0 but you need to do the same for any other edition and version of the .NET framework as well. Version 3.0 assemblies have different names (see the next step for details).

## 2. Add new EasyQuery assemblies.

Again we suppose here that your project is for the .NET 4.0 and WebForms edition of EasyQuery. Use similar assembly names for other editions and .NET versions. So you need to reference the following assemblies in your project: 

- Korzh.EasyQuery.NET40.dll
- Korzh.EasyQuery.Db.NET40.dll
- Korzh.EasyQuery.WebControls.NET40.dll

## 3. Add necessary namespaces

Since we have separated our core classes in two groups (the ones who represent the general query and data model objects and the classes which are designed to work with databases), you need to add Korzh.EasyQuery.Db namespace into the “using” section on the forms where EasyQuery controls are used:

`using Korzh.EasyQuery.Db;`

Additionally, you may need to remove the deprecated namespace `Korzh.WinControls.XControls` (in case it was used in your code).

## 4. Change the types of the Query and DataModel objects.

Since `Query` and `DataModel` classes now represent some basic entities (not dealt with a database) you need to change the types of those object to `DbQuery` and `DbModel` correspondingly. Additionally, you will need to do similar changes for all data model and query objects as well, since some basic classes (like SimpleCondition or EntityAttrExpr) have become abstract so you can't create an instance of these classes anymore and need to use some their Db* descendants. Moreover, some classes which were the sub-classes before (like `Query.Column` or `DataModel.EntityAttr`) now become first-level classes (`Column` or `EntityAttr` correspondingly).

Here is the full map of necessary changes: 

- DataModel → DbModel
- Query → DbQuery
- DataModel.Table → Table
- DataModel.Link → TableLink
- DataModel.Entity → DbEntity
- DataModel.EntityAttr → DbEntityAttr
- Query.Column → DbColumn
- Query.SimpleCondition → DbSimpleCondition
- Query.Predicate → DbPredicate
- EntityAttrExpr → DbEntityAttrExpr
- AggrFuncExpr → DbAggrFuncExpr

## 5. Changes in SQL generation logic

Since all SQL generation functionality in version 3.0 was moved into the particular SqlQueryBuilder class, you can't call BuildSQL() method of the Query object to build the SQL or read it's Result property to get the generated statement. Instead of that, you need to create an instance of SqlQueryBulider class and call its BuildSQL() method.

Example:
Was in version 2.x: 
```js
 query.BuildSQL();
  SqlTextBox.Text = query.Result.SQL;
```
Become in version 3.0:
```js
 SqlQueryBuilder builder = new SqlQueryBuilder(query);
  builder.BuildSQL();
  SqlTextBox.Text = builder.Result.SQL;
```
## 6. Change the types of other objects (conditions, expressions, attributes) if necessary

Here is the map of the changes you may need to do:

  - EntAttrProp → EntityAttrProp
  - EntAttrProp.SqlName → EntityAttrProp.Expression
  - Korzh.WinControls.XControls.XSortOrder → Korzh.EasyQuery.WinControls.XSortOrder

That's all. Now your project must work well with EasyQuery 3.0!
</Content>
    <Tags>,code-sample,asp-net,data-model,sql,</Tags>
  </Article>
  <Article id="4df5b061-1189-4055-b4cb-65c30056b279" title="ExprList class">
    <Content>```csharp
public class Korzh.EasyQuery.ExprList
    : Collection&lt;EqExpression&gt;, IList&lt;EqExpression&gt;, ICollection&lt;EqExpression&gt;, IEnumerable&lt;EqExpression&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;EqExpression&gt;, IReadOnlyCollection&lt;EqExpression&gt;

```

</Content>
    <Tags />
  </Article>
  <Article id="529eee0a-1ba4-4aa1-8eb1-5b5e61cef159" title="EntityAttrExpr class">
    <Content>```csharp
public abstract class Korzh.EasyQuery.EntityAttrExpr
    : EqExpression

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `EntityAttr` | Attribute |  | 
| `String` | CustomFunc |  | 
| `DataType` | DataType |  | 
| `Boolean` | IsParentExpr |  | 
| `DataKind` | Kind |  | 
| `String` | Text |  | 
| `String` | TypeName |  | 
| `String` | Value |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | AssignExpr(`EqExpression` expr) |  | 
| `void` | Init(`DataModel` model, `EntityAttr` attr) |  | 
| `void` | LoadFromJsonDict(`JsonDict` dict) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | SaveToJsonDictCore(`JsonDict` dict) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer, `String` tagName) |  | 
| `void` | SetAttribute(`EntityAttr` attr) |  | 
| `void` | SetContentSilent(`String` val, `String` txt) |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeName |  | 
| `String` | TextFormat |  | 


</Content>
    <Tags />
  </Article>
  <Article id="535e6bca-606b-4a32-a11e-1f4f950fb983" title="DataKind class">
    <Content>```csharp
public enum Korzh.EasyQuery.DataKind
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | Scalar |  | 
| `1` | Const |  | 
| `2` | Attribute |  | 
| `3` | List |  | 
| `4` | Query |  | 


</Content>
    <Tags />
  </Article>
  <Article id="55d97fcb-6af8-4226-9466-476f332bb0db" title="Localization of query builder's UI">
    <Content>It is quite easy to translate the user interface of EasyQuery components into another language. There two possible methods of localization:

## 1. Satellite assemblies

First of all, you can do it using satellite assemblies which are the standard way of localization for .NET components.

After installation you can find EasyQuery [satellite assemblies](https://blogs.msdn.microsoft.com/global_developer/2011/07/22/introduction-to-satellite-assemblies/) in the the following folder: {install dir}\assemblies\NET##\XX Here * {install dir} - is the folder where you have installed EasyQuery (C:\Program Files\Korzh.NET by default) * ## - indicates to the number of .NET version you need (e.g. 40 or 35) * XX - is the language code (e.g. \fr - for French or \de - for German)

## 2. "On-the-fly localization through .properties files

However, there is another way: more easy and faster one. All EasyQuery namespaces contain a unique static TextResources class which you can use to change the texts employed in EasyQuery controls. You can change each string separately through `Put()` static method or directly load a `.properties` which contains all translations for current namespace.

Here are more detailed instructions:

1) Find all `.properties` files in the \res\EasyQuery\ subfolder of the EasyQuery.NET installation folder.

2) Make a copy of each such file with some language code suffix. For example `EQCoreMessages.properties` will become `EQCoreMessages_PT.properties` for the Portuguese language. After that just translate all text messages at the right part (after '=' symbol) in each row of all new `.properties` files.

3) Finally, just load those files somewhere at the beginning of your application e.g. in a constructor or during form loading.

Example: 

```
Korzh.EasyQuery.TextResources.LoadFromFile("EQCoreMessages_PT.properties");
Korzh.EasyQuery.WebControls.TextResources.LoadFromFile("EQWebMessages_PT.properties");
```

In the example above we have loaded the resources for core Korzh.EasyQuery and for WebControls assemblies. For other editions, you will need to change the second line of code correspondingly.

Here is how it will look for WPF edition: 

```
Korzh.EasyQuery.TextResources.LoadFromFile("EQCoreMessages_PT.properties");
Korzh.EasyQuery.WpfControls.TextResources.LoadFromFile("EQWpfMessages_PT.properties");
```

or for WinForms: 

```
Korzh.EasyQuery.TextResources.LoadFromFile("EQCoreMessages_PT.properties");
Korzh.EasyQuery.WinControls.TextResources.LoadFromFile("EQWinMessages_PT.properties");
```</Content>
    <Tags>,localization,i18n,code-sample,</Tags>
  </Article>
  <Article id="57249ca4-889b-4b80-9f75-712a1e88f257" title="EntityAttr class">
    <Content>```csharp
public class Korzh.EasyQuery.EntityAttr
    : IComparable&lt;EntityAttr&gt;

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `Operator` | _defaultOperator |  | 
| `Boolean` | _isGhost |  | 
| `Entity` | entity |  | 
| `String` | expr |  | 
| `EntAttrKind` | kind |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | Caption |  | 
| `String` | ColumnName |  | 
| `String` | CustomFunc |  | 
| `DataType` | DataType |  | 
| `ValueEditor` | DefaultEditor |  | 
| `String` | Description |  | 
| `EditorsMap` | Editors |  | 
| `Entity` | Entity |  | 
| `String` | Expr |  | 
| `String` | FullExpr |  | 
| `String` | ID |  | 
| `Boolean` | IsGhost |  | 
| `Boolean` | IsNullable |  | 
| `EntAttrKind` | Kind |  | 
| `EntityAttr` | LookupAttr |  | 
| `DataModel` | Model |  | 
| `OperatorList` | Operations |  | 
| `QueryParamList` | Params |  | 
| `PropertyInfo` | PropInfo |  | 
| `String` | PropName |  | 
| `Int64` | Size |  | 
| `Boolean` | UseInConditions |  | 
| `Boolean` | UseInResult |  | 
| `Boolean` | UseInSorting |  | 
| `Object` | UserData |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | AddParamsTo(`QueryParamList` prms) |  | 
| `void` | CheckModel() |  | 
| `void` | CopyFrom(`EntityAttr` attr) |  | 
| `void` | ExtractParams() |  | 
| `void` | FillOperatorsWithDefaults(`DataModel` model) |  | 
| `String` | GetDataAttrFullExpr() |  | 
| `Operator` | GetDefaultOperator() |  | 
| `ValueEditor` | GetValueEditor(`Operator` op, `Int32` operandIndex) |  | 
| `Boolean` | HasParams() |  | 
| `void` | LoadAttribute(`String` propname, `String` propvalue) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | LoadNodes(`XmlReader` reader) |  | 
| `void` | OnModelAssignment() |  | 
| `void` | ProcessVirtualExpr() |  | 
| `void` | SaveToJsonDict(`JsonDict` dict) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 
| `void` | SaveXmlAttributes(`XmlWriter` writer) |  | 
| `void` | SaveXmlNodes(`XmlWriter` writer) |  | 
| `void` | SetDefaultOperator(`Operator` op) |  | 


### Static Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `EntAttrKind` | StrToEntAttrKind(`String` s) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="57837ce5-b87b-4b96-90a7-2a26b8dbce15" title="Common SQL queries - how to build them with EasyQuery">
    <Content>					&lt;p&gt;
						Here we are going to give you several examples of SQL queries and describe how to achieve the same result with EasyQuery.
						&lt;br&gt; All examples are built over well-known Northwind sample database (you know: Customers, Orders, Orders Details, Products, Employees).
						&lt;br&gt; Here you can take a look at the &lt;a href="http://merc.tv/img/fig/Northwind_mdb_physical.gif" target="_blank"&gt;diagram of Norithwind DB&lt;/a&gt; if you didn’t encounter it before.
					&lt;/p&gt;
					&lt;p&gt;
						All EasyQuery implementations will be performed on our &lt;a href="http://demo.easyquerybuilder.com/asp-net-mvc/" target="_blank"&gt;EasyQuery ASP.NET MVC live demo&lt;/a&gt; - so you will be able to replicate all described examples by yourself.
					&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul class="c-content-list-1 c-theme c-separator-dot c-square krh-blog-post-list"&gt;
    @foreach(var post in Post.Blog.Posts.Where(p =&gt; p.ParentPostId == Post.Id).OrderBy(p =&gt; p.Index)) {
        &lt;li&gt;
            &lt;a href="@Post.Blog.GetPostPath(post)"&gt;@post.Title&lt;/a&gt;
            &lt;p&gt;@post.Excerpt&lt;/p&gt;
        &lt;/li&gt;        
    }
&lt;/ul&gt;</Content>
    <Tags>,tables,connection,dme,</Tags>
  </Article>
  <Article id="5b33c09d-0202-4906-ad96-f26925553fcf" title="SimpleCondition class">
    <Content>```csharp
public abstract class Korzh.EasyQuery.SimpleCondition
    : Condition

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `EqExpression` | BaseExpr |  | 
| `Operand` | DefaultOperand |  | 
| `SimpleCondExprList` | Expressions |  | 
| `Operator` | Operator |  | 
| `String` | TypeName |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | AdjustOperator() |  | 
| `void` | AttachExpr(`EqExpression` expr) |  | 
| `EqExpression` | CreateValueExpr(`Int32` index) |  | 
| `EqExpression` | CreateValueExprByOperand(`Operand` opnd) |  | 
| `void` | DetachExpr(`EqExpression` expr) |  | 
| `void` | DoExprContentChanged(`Object` sender, `EventArgs` e) |  | 
| `EntityAttr` | GetBaseAttr() |  | 
| `Operand` | GetOperand(`Int32` index) |  | 
| `String` | GetText(`QueryTextFormats` formats, `String` levelSpace, `String` prefix) |  | 
| `IEnumerable&lt;Entity&gt;` | GetUsedEntities() |  | 
| `void` | LoadFromJsonDict(`JsonDict` dictCond) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `EqExpression` | RecreateValueExpr(`Int32` index) |  | 
| `void` | SetOperator(`Operator` newOperator) |  | 
| `void` | SetOperatorSilent(`Operator` newOperator) |  | 
| `void` | SetValueExpr(`Int32` index, `EqExpression` expr) |  | 
| `void` | WriteContent(`XmlWriter` writer) |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeName |  | 


</Content>
    <Tags />
  </Article>
  <Article id="5d5d768b-591e-4e4e-a2cf-9e71a70dad15" title="Using MS SQL instead of Access in WebDemo sample project">
    <Content>Here you will find the detailed instructions how to modify our sample applications (WebDemoCS or WebDemoAjaxCS) to make it work with SQL Server instead of Access.

**1)** Change the following line in using section of Default.aspx.cs file:

`using System.Data.OleDb;`

to

`using System.Data.SqlClient;`

**2)** After that change the type of your DbConnection object. Just search for all inclusions of DbConnection variable and change it's declaration if necessary. You will need to change the connection string accordingly.

Here is the new code: 

```
private System.Data.SqlClient.SqlConnection DbConnection = null;
    . . . . . .
DbConnection = new SqlConnection();
DbConnection.ConnectionString = "Data Source=DEVPC1\\SQLEXPRESS;Initial Catalog=nwind;Integrated
Security=True";
```
**3)** Then change the type of OleDbDataAdapter to SqlDataAdapter in QueryPanel1_SqlExecute and other methods where it exists. For example the following line of code:

`OleDbDataAdapter resultDA = new OleDbDataAdapter(e.SQL, DbConnection);`

should be replaced with:

`SqlDataAdapter resultDA = new SqlDataAdapter(e.SQL, DbConnection);`

**4)** Find the following line of code in your Default.aspx.cs file:

`query.Formats.SetDefaultFormats(FormatType.MsAccess);`

and replace it to this one:

`query.Formats.SetDefaultFormats(FormatType.MsSqlServer);`

**5)** Finally you will need to change `&lt;asp:AccessDataSource …&gt;` tag in Default.aspx file to SqlDataSource. Here is an example how it may look like: 

```
&lt;asp:SqlDataSource ID="ResultDS" runat="server" ConnectionString="Data Source=DEVPC1\SQLEXPRESS;Initial
Catalog=nwind;Integrated Security=True"&gt;&lt;/asp:SqlDataSource&gt;
```</Content>
    <Tags>,asp-net,webforms,sql-server,oledb,code-sample,</Tags>
  </Article>
  <Article id="5d811b58-d7bb-449d-988c-0ecf10c43e9c" title="CustomListValueEditor class">
    <Content>```csharp
public class Korzh.EasyQuery.CustomListValueEditor
    : ListValueEditor

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | IDBase |  | 
| `String` | ListName |  | 
| `DataType` | ResultType |  | 
| `String` | TypeName |  | 
| `String` | XmlDefinition |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | LoadAttribute(`String` attrName, `String` attrValue) |  | 
| `void` | SaveAttributesToXmlWriter(`XmlWriter` writer) |  | 
| `void` | SaveContentToJsonDict(`JsonDict` dict) |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeCaption |  | 
| `String` | STypeName |  | 


</Content>
    <Tags />
  </Article>
  <Article id="5dc306b7-b419-4e34-b713-383256f8aee1" title="EqExpression class">
    <Content>```csharp
public abstract class Korzh.EasyQuery.EqExpression

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | text |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | CustomFunc |  | 
| `DataType` | DataType |  | 
| `String` | Hint |  | 
| `Boolean` | IsAggregate |  | 
| `DataKind` | Kind |  | 
| `Type` | SystemType |  | 
| `String` | Text |  | 
| `String` | TypeName |  | 
| `String` | Value |  | 


### Events

| Type | Name | Description | 
| --- | --- | --- | 
| `EventHandler` | ContentChange |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | AssignExpr(`EqExpression` expr) |  | 
| `void` | ContentChanged() |  | 
| `void` | LoadFromJsonDict(`JsonDict` dict) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | OnContentChange(`EventArgs` e) |  | 
| `void` | SaveToJsonDict(`JsonDict` dict) |  | 
| `void` | SaveToJsonDictCore(`JsonDict` dict) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer, `String` tagName) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 
| `void` | SetContent(`String` val, `String` txt) |  | 
| `void` | SetContentSilent(`String` val, `String` txt) |  | 
| `void` | WriteXmlTagStart(`XmlWriter` writer) |  | 
| `void` | WriteXmlTagStart(`XmlWriter` writer, `String` tagName) |  | 


### Static Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `Dictionary&lt;String, IExpressionCreator&gt;` | Creators |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeName |  | 
| `String` | XmlTagName |  | 


### Static Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | ApplyCustomFunc(`String` func, `String` expr) |  | 
| `EqExpression` | Create(`String` exprType, `DataModel` model) |  | 
| `Boolean` | RegisterType(`String` type, `IExpressionCreator` creator) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="5ecbe347-557b-4644-a17d-ae67ec6e4530" title="EntityStore class">
    <Content>```csharp
public class Korzh.EasyQuery.EntityStore
    : EntityList, IList&lt;Entity&gt;, ICollection&lt;Entity&gt;, IEnumerable&lt;Entity&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;Entity&gt;, IReadOnlyCollection&lt;Entity&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | InsertItem(`Int32` index, `Entity` item) |  | 
| `void` | OnEntityInsertion(`Entity` entity, `Int32` index) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="608a1c3e-e4b4-4d1c-8bf6-3dc5ef4977cf" title="Query class">
    <Content>```csharp
public class Korzh.EasyQuery.Query

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `ColumnStore` | columns |  | 
| `String` | filePath |  | 
| `ColumnStore` | justSortedColumns |  | 
| `String` | queryDescription |  | 
| `String` | queryName |  | 
| `Predicate` | root |  | 
| `String` | serializationQueryXml |  | 
| `SortedColumnList` | sortedColumns |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `ColumnStore` | Columns |  | 
| `String` | ExtraColumns |  | 
| `Predicate` | ExtraConditions |  | 
| `String` | FilePath |  | 
| `String` | ID |  | 
| `Boolean` | IsEmpty |  | 
| `ColumnStore` | JustSortedColumns |  | 
| `DataModel` | Model |  | 
| `Query` | Parent |  | 
| `String` | QueryDescription |  | 
| `String` | QueryName |  | 
| `Predicate` | Root |  | 
| `SortedColumnList` | SortedColumns |  | 
| `Boolean` | StoreModelPath |  | 
| `Boolean` | StoreOptions |  | 
| `Boolean` | SyncColSortOrder |  | 
| `TextStorage` | Texts |  | 


### Events

| Type | Name | Description | 
| --- | --- | --- | 
| `ColumnsChangedEventHandler` | ColumnsChanged |  | 
| `ColumnsChangingEventHandler` | ColumnsChanging |  | 
| `ConditionsChangedEventHandler` | ConditionsChanged |  | 
| `EventHandler` | ModelChanged |  | 
| `SortOrderChangedEventHandler` | SortOrderChanged |  | 
| `ConditionsChangedEventHandler` | SubQueryConditionsChanged |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Predicate` | AddPredicate(`Predicate` group, `Int32` index = -1) |  | 
| `Column` | AddSimpleColumn(`String` attrId, `String` caption = null, `SortDirection` sorting = None) |  | 
| `SimpleCondition` | AddSimpleCondition(`Predicate` predicate, `Int32` index, `EntityAttr` attribute) |  | 
| `SimpleCondition` | AddSimpleCondition(`String` attrId, `String` operatorId, `String[]` values) |  | 
| `SimpleCondition` | AddSimpleCondition(`Predicate` predicate, `String` attrId, `String` operatorId, `String[]` values) |  | 
| `void` | CheckDataModel() |  | 
| `void` | CheckModelObject(`DataModel` model) |  | 
| `void` | Clear() |  | 
| `void` | CoreClear() |  | 
| `AggrFuncExpr` | CreateAggrFuncExpr(`DataModel` model, `String` funcID, `EqExpression` argExpr) |  | 
| `Column` | CreateColumn() |  | 
| `Column` | CreateColumn(`EntityAttr` attr) |  | 
| `Column` | CreateColumn(`String` attrId, `String` caption = null, `SortDirection` sorting = None) |  | 
| `EntityAttrExpr` | CreateEntityAttrExpr(`DataModel` model, `EntityAttr` attr) |  | 
| `EntityAttrExpr` | CreateEntityAttrExpr(`DataModel` model, `String` attrId) |  | 
| `QueryFormats` | CreateFormats() |  | 
| `EntityAttrExpr` | CreateParentEntityAttrExpr(`DataModel` model, `EntityAttr` attr) |  | 
| `Predicate` | CreatePredicate() |  | 
| `Predicate` | CreateRootPredicate() |  | 
| `Predicate` | CreateSilentPredicate() |  | 
| `SimpleCondition` | CreateSimpleCondition() |  | 
| `SimpleCondition` | CreateSimpleCondition(`String` attrId, `String` operatorId, `String[]` values) |  | 
| `SimpleCondition` | CreateSimpleCondition(`EntityAttr` attr, `Operator` op, `EqExpression[]` exprs) |  | 
| `Query` | CreateSubQuery() |  | 
| `String` | GetConditionsText(`QueryTextFormats` formats) |  | 
| `QueryFormats` | GetFormats() |  | 
| `String` | GetOneValueForAttr(`EntityAttr` attr) |  | 
| `Entity` | GetParentQueryRootEntity() |  | 
| `void` | InnerSortOrderChanged(`SortOrderChangedEventArgs` e) |  | 
| `void` | LoadFromFile(`String` path) |  | 
| `void` | LoadFromFile(`String` path, `RWOptions` rwOptions) |  | 
| `void` | LoadFromJsonDict(`JsonDict` dict) |  | 
| `void` | LoadFromJsonDict(`JsonDict` dict, `RWOptions` rwOptions) |  | 
| `void` | LoadFromStream(`Stream` stream) |  | 
| `void` | LoadFromStream(`Stream` stream, `RWOptions` rwOptions) |  | 
| `void` | LoadFromString(`String` xml, `RWOptions` rwOptions) |  | 
| `void` | LoadFromString(`String` xml) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader, `RWOptions` rwOptions) |  | 
| `void` | LoadNode(`XmlReader` reader, `RWOptions` rwOptions) |  | 
| `DataModel` | NewModel() |  | 
| `void` | OnColumnsChanged(`ColumnsChangeEventArgs` e) |  | 
| `void` | OnColumnsChanging(`ColumnsChangingEventArgs` e) |  | 
| `void` | OnConditionsChanged(`ConditionsChangeEventArgs` e) |  | 
| `void` | OnSortOrderChanged(`SortOrderChangedEventArgs` e) |  | 
| `void` | OnSubQueryConditionsChanged(`ConditionsChangeEventArgs` e) |  | 
| `void` | ResyncSortingList(`Boolean` changeInnerIndex) |  | 
| `void` | SaveNodes(`XmlWriter` writer, `RWOptions` rwOptions) |  | 
| `void` | SaveToFile(`String` path) |  | 
| `void` | SaveToFile(`String` path, `RWOptions` Options) |  | 
| `JsonDict` | SaveToJsonDict() |  | 
| `void` | SaveToStream(`Stream` stream) |  | 
| `void` | SaveToStream(`Stream` stream, `RWOptions` options) |  | 
| `String` | SaveToString() |  | 
| `String` | SaveToString(`RWOptions` Options) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer, `RWOptions` rwOptions) |  | 
| `void` | Validate() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="616996a8-aff2-4fa7-bab1-cfda9481981e" title="Create a query with sub-query by code">
    <Content>Here is an example:

```c#
DbEntityAttr attr = (DbEntityAttr)model.EntityRoot.FindAttribute(EntityAttrProp.Expression, "Cust.Country");
 
//first we create a Query object that will represent a sub-query
Query subQuery = query.CreateSubQuery();
 
//add one column to it
DbColumn col1 = new DbColumn();
col1.Expr = new DbEntityAttrExpr(model, attr);
subQuery.Columns.Add(col1);
 
//and one condition
SimpleCondition subCond = subQuery.CreateSimpleCondition(model);
subCond = query.CreateSimpleCondition(model);
subCond.BaseExpr = new DbEntityAttrExpr(model, attr);
subCond.Operator = model.Operators.FindByID("StartsWith");
subCond.SetValueExpr(1, new ConstExpr(Korzh.EasyQuery.DataType.String, "U"));
subQuery.Root.Conditions.Add(subCond);
 
 
query.Clear();
 
//Then we add one condition with "in sub query" operator to the main query 
SimpleCondition cond = query.CreateSimpleCondition(model);
 
cond.BaseExpr = new DbEntityAttrExpr(model, attr);
cond.Operator = model.Operators.FindByID("InSubQuery");
 
//Second expression in condition is SubQueryExpr with an XML representation of sub query as a value
SubQueryExpr subQueryExpr = new SubQueryExpr(model);
subQueryExpr.Value = subQuery.SaveToString();
cond.SetValueExpr(1, subQueryExpr);
 
query.Root.Conditions.Add(cond);
```</Content>
    <Tags>,code,code-sample,sub-query,data-model,entity-framework,</Tags>
  </Article>
  <Article id="64d5a4e1-356a-41b4-8085-696d90691ba2" title="AggrFunctionList class">
    <Content>```csharp
public class Korzh.EasyQuery.AggrFunctionList
    : Collection&lt;AggrFunction&gt;, IList&lt;AggrFunction&gt;, ICollection&lt;AggrFunction&gt;, IEnumerable&lt;AggrFunction&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;AggrFunction&gt;, IReadOnlyCollection&lt;AggrFunction&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `AggrFunction` | FindByID(`String` id) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="650c9350-aa13-48d0-aac3-376a710d128d" title="SqlSyntax class">
    <Content>```csharp
public enum Korzh.EasyQuery.SqlSyntax
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | SQL1 |  | 
| `1` | SQL2 |  | 
| `2` | Oracle |  | 
| `3` | EntitySQL |  | 


</Content>
    <Tags />
  </Article>
  <Article id="68d26d8c-5871-484a-ac07-8f29a1e26146" title="Add a new aggregate function">
    <Content>## 1. Problem Overview

EasyQuery supports several aggregate functions (like SUM, COUNT, AVG, etc.) out-of-the-box. 
However, sometimes you may need to add some other aggregate function to your model and make it appear in visual controls/widget.

## 2. Solution

All aggregate functions available for end-users are stored in 

`AggrFunctions` list of DbModel class.

So, all you need to do is to add a new function to that list. Each function is an object of `AggrFunction` class and has the following main properties:

* **Id** - a unique identifier.

* **Caption** - a user-friendly name of the function which represents it in the drop-down list when the user selects the aggregate function.

* **SqlExpr** - defines the way how a function is used in result SQL statement. We can use `{expr}` variable to specify the function’s argument

* **DisplayFormat** - defines how the function is represented in columns row in ColumnsPanel control/widget. That part in double square brackets [[ … ]] is clickable - it will allow selecting another function (e.g. change it from SUM to COUNT).

## 3. Example

Here is an example of adding new aggregate function into model:

```c#
model.AggrFunctions.Add(new AggrFunction("MyFunc", "MyAggregate Function", "MYFUNC({expr1})", "[[My function]] of {attr1}"));
```
</Content>
    <Tags>,aggregate-function,code-sample,data-model,</Tags>
  </Article>
  <Article id="6935c133-143a-40c4-817b-ed272bf4fc35" title="ExportOptions class">
    <Content>```csharp
public class Korzh.EasyQuery.Services.ExportOptions

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | ContentType |  | 
| `String` | ExportType |  | 
| `String` | FileName |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | LoadFromJsonDict(`JsonDict` dict) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="694ed382-f519-462a-bf8b-8c21e9ba6f88" title="Replace &quot;value&quot; element in QueryPanel's conditions — WinForms">
    <Content>EasyQuery library provides you with several different controls which are used in conditions in QueryPanel. Most of them represented by a kind of hyperlink which shows an additional control when you click on it. An example of such additional controls can be a simple edit box, a menu which contains the list of available values or a date/time picker element for date/time values. However, sometimes you would like to create your control and use it inside QueryPanel for some conditions. Here is a step-by-step description what you need to achieve this goal.

## 1. Creating an XElement descendant

First of all, you need to create your type of element. This element must be an instance of some class inherited from the XElement class. In our example, we will create a very simple element which can be used for boolean values and will just change it's value from “true” to “false” and vice versa when a user clicks on it.

So here is our new class: 

```js
. . . . . . . . 
using Korzh.WinControls.XControls;
 
. . . . . . . . 
 
  class BoolXElement : LabelXElement {
  protected override void LinkClickedHandler(object sender, LinkLabelLinkClickedEventArgs e) {
  if (ReadOnly) return;
  if (Value == TrueValue)
  Value = FalseValue;
  else
  Value = TrueValue;
  }
 
  private string _trueValue = "true";
  public string TrueValue {
  get { return _trueValue; }
  set {
  _trueValue = value;
  }
  }
 
  private string _falseValue = "false";
  public string FalseValue {
  get { return _falseValue; }
  set {
  _falseValue = value;
  }
  }
 
 
  }
```

## 2. Using new element in conditions

Second step - is actual using our new control inside QueryPanel's conditions. To replace the default XElement by our own you can use CreateValueElement event of QueryPanel controls. Here how it may look in our case: 

```js
private void QPanel_CreateValueElement(object sender, CreateValueElementEventArgs e) {
  // this method demonstrates an ability to change value elelements at run-time
  // for example in this case we change element from ListXElement to EditXElement if list of available values is too long
  if (e.ConditionRow.Condition is Query.SimpleCondition) {
  Query.SimpleCondition simpleCondition = (Query.SimpleCondition)e.ConditionRow.Condition; 
  Expression baseExpr = ((Query.SimpleCondition)e.ConditionRow.Condition).BaseExpr;
  EntityAttr attr = ((EntityAttrExpr)baseExpr).Attribute;
  if (attr.DataType == DataType.Bool) {
  BoolXElement boolElement = new BoolXElement();
  boolElement.Value = simpleCondition.Expressions[1].Value;
  e.Element = boolElement; 
  }
  }
  }
```
That's all. As you can see it was quite simple.</Content>
    <Tags>,winforms,code-sample,query-panel,conditions,data-model,</Tags>
  </Article>
  <Article id="6d12ebf6-609e-46de-b0fc-79d2b7966038" title="ConditionsStore class">
    <Content>```csharp
public class Korzh.EasyQuery.ConditionsStore
    : ConditionList, IList&lt;Condition&gt;, ICollection&lt;Condition&gt;, IEnumerable&lt;Condition&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;Condition&gt;, IReadOnlyCollection&lt;Condition&gt;

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Query` | Query |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | BeginUpdate() |  | 
| `void` | CheckMaxID() |  | 
| `void` | ClearItems() |  | 
| `void` | EndUpdate() |  | 
| `Int32` | GetNewID() |  | 
| `void` | InsertItem(`Int32` index, `Condition` item) |  | 
| `void` | OnAdded(`Condition` condition, `Int32` index) |  | 
| `void` | OnListChange() |  | 
| `void` | OnRemoved(`Condition` condition) |  | 
| `void` | RemoveItem(`Int32` index) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="6d57f67b-dafb-4bcb-9b88-e5c8eb5d449a" title="SortDirection class">
    <Content>```csharp
public enum Korzh.EasyQuery.SortDirection
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | None |  | 
| `1` | Ascending |  | 
| `2` | Descending |  | 


</Content>
    <Tags />
  </Article>
  <Article id="6fc5d8c7-cb87-4074-ae70-71e3b7200d97" title="EntityAttrStore class">
    <Content>```csharp
public class Korzh.EasyQuery.EntityAttrStore
    : EntityAttrList, IList&lt;EntityAttr&gt;, ICollection&lt;EntityAttr&gt;, IEnumerable&lt;EntityAttr&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;EntityAttr&gt;, IReadOnlyCollection&lt;EntityAttr&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | InsertItem(`Int32` index, `EntityAttr` item) |  | 
| `void` | OnEntityAttrInsertion(`EntityAttr` entityAttr, `Int32` index) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="70ef8032-4c5d-4d5e-820c-9ad3b709ffc3" title="Exporting query results">
    <Content>## 1. Problem Overview

After building, executing and getting results from a query, users often may have a need to save their data in another format or transfer it for further processing to another program (e.g. Excel).

Though EasyQuery wasn’t created to implement these functions, we provide some simple functionality for exporting. 

## 2. Korzh.Utils.Db

Exporting functionality is provided by `Korzh.Utils.Db` unit which is available via corresponding assembly (e.g. `Korzh.Utils.Db.NET45.dll`). While this assembly is distributed with EasyQuery, it isn’t directly connected to other EasyQuery modules and can be used separately without any limits. 

The primary functions of this module are provided by the static class `DbExport`. Its functionality allows you to export data from `DataSet` or `DataTable` to CSV (comma-separated file) format or Excel-compatible (more about that later) HTML.

## 3. Examples

### 3.1. Exporting dataset to CSV stream with default formatting:

```c#
DbExport.ExportToCsv(dataset, outputStream, CsvFormats.Default);
```

### 3.2. Exporting DataTable object to CSV text writer with custom formatting:

```c#
var formats = new CsvFormats {
  Separator = ",",
  DateFormat = "yyyy-MM-dd",
  ShowColumnNames = true,
  QuoteAlways = true
};

DbExport.ExportToCsv(dataTable, textWriter, formats);
```

### 3.3. Exporting dataset to HTML stream with custom formatting:

```c# 
var formats = new HtmlFormats {
  DateFormat = "yyyy-MM-dd", //format for date values
  HeaderBgColor = "#555", //color of header's backgroud (dark-grey)
  HeaderFgColor = "#FFF", //color of header's text (white)
};
DbExport.ExportToExcelHtml(dataset, Response.Output, formats);
```

NB 1: Exporting dataset means that we will export the first DataTable in its Tables list.

NB 2: Although we usually return an .xls file in our demos - that is not a native Excel file actually. It's an HTML file which is specially structured to be imported by Excel as a nicely formatted spreadsheet. We give it .xls extension to make browser to pass it to Excel automatically. However, you may get a security warning from Excel because the format of the file (HTML) does not correspond to file extension (.xls).

## 4. DbExport API

### 4.1. DbExport class

All functions in this class are static

* **ExportToCsv(DataSet dataset, Stream stream)** : *bool*

Exports the content of some DataSet object to CSV file (referenced as a Stream object) with default formatting.
Returns true if export was successful, otherwise - false.

* **ExportToCsv(DataSet dataset, Stream stream, CsvFormats formats)**: *bool*

Exports the content of some DataSet object to CSV file with custom formatting.
Returns true if export was successful, otherwise - false

* **ExportToCsv(DataSet dataset, TextWriter writer, CsvFormats formats)**: *bool*

Changes the content of some DataSet object to CSV file.

* **ExportToCsv(DataTable table, Stream stream)**: *bool*

Transforms some DataTable object to CSV file.

* **ExportToCsv(DataTable table, Stream stream, CsvFormats formats)**: *bool*

Exports the content of some DataTable object to CSV file.

* **ExportToCsv(DataSet dataSet, CsvFormats formats)**: *StringBuilder*

Switches some DataSet object into CSV file.

* **ExportToCsv(DataView view, CsvFormats formats)**: *StringBuilder*

Exports data from DataView object into CSV file.

* **ExportToCsv(DataTable table, CsvFormats formats)**: *StringBuilder*

Changes data from a DataTable object into CSV file.

* **ExportToCsv(DataTable table, TextWriter writer, CsvFormats formats)**: *bool*

Exports data from a DataTable object into CSV file.

* **ExportToExcelHtml(DataSet dataset, TextWriter writer, HtmlFormats formats)**: *bool* 

Exports DataSet content to HTML prepared for using in Excel. 

* **ExportToExcelHtml(DataSet dataSet, HtmlFormats formats)**: *StringBuilder*

Transforms the content of some DataSet object into HTML formatted for using in Excel

* **ExportToExcelHtml(DataTable table, HtmlFormats formats)**: *StringBuilder*

Sets the content up of some DataTable object into HTML formatted for using in Excel 

* **ExportToExcelHtml(DataTable table, TextWriter writer, HtmlFormats formats)**: *bool* 

Exports DataTable content to HTML prepared for using in Excel.

### 4.2. CsvFormats class

There are different options of CsvFormats class which can be used to set up formatting of result CSV file: 

* **Separator**: *string*

Sets the separator. 


* **QuoteAlways**: *bool*

Creates a value indicating whether we should always put quotes around field values. If it's false - quotes will be added only if it's necessary. 


* **DateFormat**: *string*

Sets the format of date values. 

* **TimeFormat**: *string*

Defines the format of time values. 

* **CsvFormats**:

Initializes a new instance of the &lt;see cref="CsvFormats"/&gt; class. 

* **CsvFormats Default** = new CsvFormats

Creates the default formats.

### 4.3. HtmlFormats class 

This class allows defining different formats for result HTML files.


* **FontSize**: *int*

Sets the size of the font

* **FontFamily**: *string*

Sets the font family. 

* **TableBgColor**: *string*

Defines the color of the table debug

* **ThicknessOfBorder**: *int*

Sets the thickness of the border. 

* **TableBorderColor**: *string*

Defines the color of the table border.

* **ThowColumnNames**: *bool*

Sets a value indicating whether column names should be included into an export result.

* **HeaderBgColor**: *string*

Defines the color of the header bg. 

* **HeaderFgColor**: string

Changes the color of the header fg.

* **HeaderFontWeight**: *string*

Sets the header font weight.

* **FixHtmlTags**: *bool*.</Content>
    <Tags>,query-result,exporting,data,excel,csv,database,code-sample,</Tags>
  </Article>
  <Article id="728f8f5e-4e08-4a08-ab1e-435f15524356" title="EntityAttrList class">
    <Content>```csharp
public class Korzh.EasyQuery.EntityAttrList
    : Collection&lt;EntityAttr&gt;, IList&lt;EntityAttr&gt;, ICollection&lt;EntityAttr&gt;, IEnumerable&lt;EntityAttr&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;EntityAttr&gt;, IReadOnlyCollection&lt;EntityAttr&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | SortByCaption() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="72c44a69-6bca-4a6a-bb0d-e4eb851aaf61" title="TextResources class">
    <Content>```csharp
public static class Korzh.EasyQuery.TextResources

```

### Static Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | Get(`String` code) |  | 
| `TextStorage` | GetTexts(`String` storageID = null) |  | 
| `void` | LoadFromFile(`String` path, `TextStorage` storage = null) |  | 
| `void` | LoadFromFileForCulture(`String` baseFileName, `CultureInfo` cultureInfo = null, `String` fileExt = properties) |  | 
| `void` | LoadFromResources(`ResourceManager` resManager) |  | 
| `void` | LoadFromStream(`Stream` stream) |  | 
| `void` | Put(`String` code, `String` value) |  | 
| `void` | ReloadNativeResources(`String` storageId = null) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="758db6b6-96f0-4e46-9e3e-a83f65df2b3d" title="IValueEditorCreator class">
    <Content>```csharp
public interface Korzh.EasyQuery.IValueEditorCreator

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `ValueEditor` | Create() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="786060d5-d51a-495a-bb92-2fdea7aeacd7" title="NotEnoughModelInfo class">
    <Content>```csharp
public class Korzh.EasyQuery.NotEnoughModelInfo
    : Exception, ISerializable

```

</Content>
    <Tags />
  </Article>
  <Article id="790a93ab-9886-4129-8986-6afeb428715b" title="Using EqMvcDemoEF sample with your own DB context">
    <Content>Demo version of EasyQuery contains EqMvcDemoEF sample project which demonstrates how to use our library with Entity Framework (code first approach). This article contains a brief instruction how to modify that sample project to make it work with your own context class (instead of NorthwindContext class used in our sample).

## 1. Add your own DbContext class into the project

Current DBContext is placed in `Models\TestContext.cs` file. Remove that file from the project and add your own context class. Don't forget to change the namespace to `Korzh.EasyQuery.Mvc.Demo.Models` or add `using` for your own namespace into `EasyQueryController.cs` Let's suppose your context class is named `MyContext`

## 2. Modify Web.Config

EqMvcDemoEF uses SQL Server CE provider. If you plan to use another database type - you need to make modifications in `entityFramework` section of `Web.Config` file.

## 3. Changes EasyQueryController class

Finally, you need to modify the constructor of `EasyQueryController` class to make it work with your context instead of Northwind. Simply replace all inclusions of `NorthwindContext` with the name of your context class.

Here is how the modified constructor may look like (we guessed your context class is called `MyContext`): 

```
public EasyQueryController() {
    eqService = new EqServiceProviderDb();
    eqService.ModelLoader = (model, modelName) =&gt; {
        model.Clear();
        model.LoadFromDBContext(typeof(MyContext), DbContextOptions.IncludeComplexTypesInParentEntity);
 
    };
 
    eqService.Paging.Enabled = true;
 
    eqService.SessionGetter = key =&gt; Session[key];
    eqService.SessionSetter = (key, value) =&gt; Session[key] = value;
 
 
 
    var context = new MyContext();
    context.Database.Initialize(false);
 
    //For Entity SQL use the following settings for connection and formats
    var connection = ((System.Data.Entity.Infrastructure.IObjectContextAdapter)context).ObjectContext.Connection;
    eqService.Formats.SetDefaultFormats(FormatType.EntitySql);
 
    eqService.Connection = connection;
}
```</Content>
    <Tags>,asp-net,mvc,entity-framework,dbcontext,code-sample,</Tags>
  </Article>
  <Article id="7cd50223-cee0-48f7-a5ee-e8f32eac3e97" title="How to remove &quot;Powered by...&quot; link (full version only)">
    <Content>After purchasing a full version of EasyQuery library you may want to remove “Powered by EasyQuery” link that appears in the bottom-right corner of QueryPanel.

Here are the instructions.

## 0) Setup full version of EasyQuery

Obvious step but we should mention it. First of all, you need to uninstall the trial version of EasyQuery and install its full version (eqn_asp_full_setup_##_##_##.exe file) that you can download from [Client Area](/account) of Korzh.com web-site.

## 1) Replace EasyQuery assemblies

Replace all EasyQuery assemblies used in your project by their full versions from. You can find those assemblies in `{install dir}\Korzh.NET\Assemblies` folder (in its sub-folders to be precise). By default, it's `C:\Program Files\Korzh.NET\Assemblies`

## 2) Replace JavaScript files

The same with JavaScript files `eq.all.min.js` and `eq.view.basic.js` (or any other `eq.view.something.js` file) - use the ones from full version. You will find them in `{install dir}\Korzh.NET\JS` folder

## 3) Turn off showPoweredBy option

Finally, you need to turn off (set to 'false') `showPoweredBy` option in QueryPanel widget. You can do directly by calling `QueryPanel` method for widget's placeholder element or through `easyQuerySettings` global variable. Example: 

```js
window.easyQuerySettings = {
  serviceUrl: "/EasyQuery",
  modelName: "YourModelName", 
  . . . . . . .
  queryPanel: {
  showPoweredBy: false,
  . . . . . .
  }
  . . . . . .
}
```</Content>
    <Tags>,asp-net,mvc,code-sample,javascript,query-panel,</Tags>
  </Article>
  <Article id="7d10c38a-d091-45c8-8872-ed9b7710e51a" title="OperatorGroup class">
    <Content>```csharp
public class Korzh.EasyQuery.OperatorGroup

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `DataTypeList` | AppliedTypes |  | 
| `String` | Name |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | ToString() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="7f024772-5894-419b-91ba-49c0545f4601" title="Query with OR operators">
    <Content>## Query description

Let's suppose we need to build a query where condition #1 OR condition #2 apply.

For example, we need to find all orders with products from category Beverages or Seafood.

## SQL

Here's how such a query would look like in SQL:

```sql
SELECT Ord.OrderDate AS "Order Date", Ord.Freight AS "Order Freight"
FROM ((Orders AS Ord
  INNER JOIN `Order Details` AS OrdDet ON (OrdDet.OrderID = Ord.OrderID ))
  INNER JOIN Products AS Prod ON (OrdDet.ProductID = Prod.ProductID ))
WHERE
(
  Prod.CategoryID = 1 OR
  Prod.CategoryID = 8 )

```
As you can see this relatively simple query requires a lot of SQL "coding". We have 3 different tables here, and 2 joins between those tables.

## EasyQuery

With EasyQuery this task will be much easier (sorry for the tautology).

You need to perform three simple steps:

 * In columns panel you add "Order Date" and "Order Freight" columns.
 * Then you change all element to any the root condition group in query panel. It must look like "...where any of the followings apply".
 * Finally you add two conditions into columns panel:

  1) Product Category is equal to Beverages
  2) Product Category is equal to Seafood

![Query with OR operators](/files/test/easyquery-dotnet/images/query-or-1.gif)

## Query 2

Now imagine we need to add another condition which will be mandatory: we need to list only paid orders. So the final query will have the following structure:

```sql
Order is paid AND
  (Product Category is Beverages OR Seafood)
```

## SQL 2

The SQL statement for this new query will be the following:

```sql
SELECT Ord.OrderDate AS "Order Date", Ord.Freight AS "Order Freight"
FROM ((Orders AS Ord
  INNER JOIN `Order Details` AS OrdDet ON (OrdDet.OrderID = Ord.OrderID ))
  INNER JOIN Products AS Prod ON (OrdDet.ProductID = Prod.ProductID ))
WHERE
(
  Ord.Paid = true AND (
  Prod.CategoryID = 1 OR
  Prod.CategoryID = 8 ) )
```

## EasyQuery 2

With EasyQuery components, it will take one additional step.

1) As in the previous case, you add "Order Date" and "Order Freight" columns.
2) In query panel add one condition: Order Paid is true.
3) Please note that you don't need to change all to any in this case.
4) After that press {+} button in the first row to add a new group of conditions after the first condition.
5) New condition group will automatically take any linking.
6) EasyQuery will automatically add a condition in the new group. Change the attribute in that condition to "Product Category" and select "Beverages" in the right part of the condition.
7) Add one more condition into the group. Use (+) button in the group row (but not in root row!) to do it. Select "Product Category" as an attribute and "Seafood" as a value for this condition.
  
Product Category is equal to Seafood

Finally you should see something like the following:

![Another query with OR operators](/files/test/easyquery-dotnet/images/query-or-2.gif)


</Content>
    <Tags>,query-example,operator-or,sql,code-sample,</Tags>
  </Article>
  <Article id="86687f86-29ee-424d-81e1-07b8b0053025" title="ListRequestOptions class">
    <Content>```csharp
public class Korzh.EasyQuery.Services.ListRequestOptions

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | editorId |  | 
| `String` | listName |  | 
| `String` | modelId |  | 
| `String` | sql |  | 


</Content>
    <Tags />
  </Article>
  <Article id="8b2e6057-053d-4eed-96d9-5c20782341bd" title="Setting anti-forgery token for AJAX requests from EasyQuery widgets">
    <Content>Starting from version 3.7.0 of EasyQuery there is a possibility to add an anti-forgery token to each AJAX request from visual widgets to the server-side.

Use `antiForgeryToken` option of `easyQuerySettings` variable:

```
window.easyQuerySettings = {
  serviceUrl: "/EasyQuery",
  . . . . . . . .
  antiForgeryToken: document.querySelector('#__AjaxAntiForgeryForm input[name=__RequestVerificationToken]').value

};
```

If it's set - this token will be added to each AJAX request to EasyQueryController.

Of course, you need to add AntiForgeryToken helper somewhere on your page:

```
  @using (Html.BeginForm(null, null, FormMethod.Post, new { id = "__AjaxAntiForgeryForm" }))
  {
  @Html.AntiForgeryToken()
  . . . . . . .
```
</Content>
    <Tags>,asp-net,javascript,mvc,code-sample,ajax-request,</Tags>
  </Article>
  <Article id="8c72f10e-5a01-4aaf-896c-1ce55667bd7d" title="Add columns and conditions by code">
    <Content>Here we suppose that our `Query` object is referenced as **query1** and `DataModel` object as **dataModel1**.


```js
 private void AddColumnsConditionsByCode() {
 
  query1.Clear();
 
  //create simple column
  Column col = query1.CreateColumn( "Customers.Country", "Country", SortDirection.Ascending);
  query1.Columns.Add(col);
 
  //create aggregate column
  EntityAttr attr = dataModel1.EntityRoot.FindAttribute(EntityAttrProp.Expression, "Orders.Freight");
  col = new DbColumn("Total sum", SortDirection.None);
  col.Expr = new DbAggrFuncExpr(dataModel1, "SUM", new DbEntityAttrExpr(dataModel1, attr));
  query1.Columns.Add(col);
 
  //create conditions
  //here we create condition object
  SimpleCondition cond = new DbSimpleCondition(dataModel1);
 
  //then we search for an entity attribute which will be used in the left side of condition
  attr = dataModel1.EntityRoot.FindAttribute(EntityAttrProp.Expression, "Orders.OrderDate");
 
  //after that we add found entity attribute as first (left side) expression of our condition
  cond.BaseExpr = new DbEntityAttrExpr(dataModel1, attr);
 
  //here we set an operator used in condition. In our case it will be "is less than" (&lt; symbol in SQL syntax)
  cond.Operator = dataModel1.Operators.FindByID("LessThan");
 
  //finally we set the rigth side expression which is some constant value in our case.
  cond.SetValueExpr(1, new ConstExpr(DataType.Date, "2005-01-01"));
  cond.ReadOnly = true;
 
  //when all parts of our condition are ready - we add it to query
  query1.Root.Conditions.Add(cond);
 
  //here is more simple and quicker way to add a condition (same attribute, operator and value)
  query1.Root.AddSimpleCondition("Orders.OrderDate", "DateBeforePrecise", "2005-01-01");
 
  //here is one more example: how to add a group of conditions
  var predicate = query.AddPredicate(query1.Root, query1.Root.Conditions.Count);
  predicate.AddSimpleCondition("Customers.City", "Equal", "London");
  predicate.AddSimpleCondition("Customer.City", "Equal", "NewYork");

 
  //generate SQL statement
  SqlQueryBuilder builder = new SqlQueryBuilder(query1);
  builder.BuildSQL();
  string sql = builder.Result.SQL;
 
 }
```</Content>
    <Tags>,code-sample,query,data-model,conditions,columns,</Tags>
  </Article>
  <Article id="8cc0a347-bef3-4264-9c49-d9dc70b1c3eb" title="Dynamically populate lists by information from other conditions — WebForms">
    <Content>We will discuss this problem and its solution by example. Let's say the user can define a condition with city e.g. “City name is equal to LA”. But if the user has already selected a country (or a few countries) in one of their condition lists then the list of cities available for indicated condition must be filled with only the cities in the selected countries.

To implement such functionality you just need to check if the attribute our list depends on is already set in one of the conditions and get its value. We use ’GetOneValueForAttr()’ method to do it.

After that, we just use the value we got when populating our list.

So, here our code sample. 

```js
  protected void QueryPanel1_ListRequest(object sender,
  Korzh.EasyQuery.WebControls.ListRequestEventArgs e) {
  EntityAttr countryAttr =
  query.Model.EntityRoot.FindAttribute(EntityAttrProp.Expression, "Customers.Country");
  if (e.ListName == "RegionList") {
  e.ListItems.Clear();
  string country = query.GetOneValueForAttr(countryAttr);
  
  if (country == "Canada") { 
  e.ListItems.Add("British Columbia", "BC");
  e.ListItems.Add("Quebec", "Quebec");
  }
  else if (country == "USA") {
  e.ListItems.Add("California", "CA");
  e.ListItems.Add("Colorado", "CO");
  e.ListItems.Add("Oregon", "OR");
  e.ListItems.Add("Washington", "WA");
  }
  }


```</Content>
    <Tags>,asp-net,webforms,code-sample,attributes,</Tags>
  </Article>
  <Article id="8db28d6a-2e2c-4f3d-a3e2-aadd398f7a91" title="Introduction">
    <Content>&lt;p&gt;If in short, EasyQuery - a set of components that allow you (as a developer) to implement a functional, user-friendly query builder in your application.
  &lt;/p&gt;
  &lt;p&gt;
  Any modern application typically operates with a certain set of data. Here we are talking about almost any type of applications: the classic desktop programs, web applications or applications for different mobile platforms.
  &lt;/p&gt;
  &lt;p&gt;
  All functionality of any program can be divided into two main components: either it is data entry or retrieval. If the first part is more or less clear, the second involves many different aspects: it is searching, sorting, filtering, reporting, statistics, etc. One thing unites all these subsystems: the users usually require some way to specify what data they need. For example: for what period, for which client, product, employee, etc. Most often, program data are stored in a kind of relational database (SQL Server, MySQL, Access, SQLite, etc.) and support the SQL query language, or some variation of it (HQL, Entity SQL, etc.). Besides, in recent years so-called No-SQL databases become very popular. Many of them have their query languages.
  &lt;/p&gt;
  &lt;p&gt;
  Regardless of the database type and the query language is a programmer’s task to implement a convenient UI for search and filtering data in the program.
  &lt;br&gt; Usually it looks like the following:
  &lt;/p&gt;
  &lt;ul&gt;
  &lt;li&gt;The user enters some values which will define the search criteria. For example, a phone number or a client’s ZIP code.&lt;/li&gt;
  &lt;li&gt;The program builds a query using these values, executes the query and displays the result to the user.&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;
  In this scheme, a set of fields on which to search and query itself remains the same. Only the values of some query parameters can be changed. If you need to add in a search some new attributes (for example, to search additionally by client’s email or address), then it will be necessary to make some changes in the program - add fields on the form, modify the SQL statement in the code, etc.
  &lt;/p&gt;
  &lt;p&gt;
  The solution of the problem is obvious: you need to give your users a possibility to build their queries, with any attributes and search criteria.
  &lt;/p&gt;
  &lt;p&gt;
  There is a class of programs, called "query builders" which solve this problem. However, most such programs are not suitable for regular users since they require some understanding database principles (tables, joins, primary/foreign keys, etc.). Also, these solutions usually offered as standalone programs that require installation and can not be called from your application.
  &lt;/p&gt;
  &lt;p&gt;
  To solve the above problems we developed EasyQuery library.
  &lt;br&gt; It is a set of components that you can embed in your program. At the moment, there are several editions of EasyQuery for different platforms: Windows Forms, ASP.NET WebForms, ASP.NET MVC, WPF, Silverlight. EasyQuery components offer a user-friendly, and (also crucial) unified query builder UI for your applications.
  &lt;br&gt; Saying "user-friendly" for query builder we mean the following:
  &lt;/p&gt;
  &lt;ul&gt;
  &lt;li&gt;
  Users operate the concepts that are familiar to them. For example: "Company name" instead of "customer.com_name" or "start with ..." instead LIKE 'A%'
  &lt;/li&gt;
  &lt;li&gt;
  For each search attribute, you can specify a set of valid values. The user will only need to select the value (s) from this list, instead of typing it manually.
  &lt;/li&gt;
  &lt;li&gt;
  The query itself is presented to the user as a phrase in a natural language, which he/she can modify visually (add a new statement or modify the existing ones).
  &lt;/li&gt;
  &lt;li&gt;
  Any query condition can be temporarily disabled (without removing) to see how the result data set will change after that.
  &lt;/li&gt;
  &lt;li&gt;
  And a lot of other little things that make it easier for users to find the data they need.
  &lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;
  EasyQuery is easily configured to work with any database and with a plurality of different query languages. Any query built by users with EasyQuery can be easily saved to a file or database and then loaded back when necessary.
  &lt;/p&gt;
</Content>
    <Tags>,asp-net,</Tags>
  </Article>
  <Article id="8e4e9e60-314f-43ae-a404-c1562aeedfd2" title="Query with OR operators">
    <Content>&lt;div class="row"&gt;
  &lt;div class="col-md-12 c-content-media-1 krh-blogpost"&gt;
  &lt;h2&gt;Query description&lt;/h2&gt;
  &lt;p&gt;Let's suppose we need to build a query where condition #1 OR condition #2 apply. &lt;/p&gt;
  &lt;p&gt;For example, we need to find all orders with products from category Beverages or Seafood.&lt;/p&gt;
  &lt;h2&gt;SQL&lt;/h2&gt;
  &lt;p&gt;Here's how such a query would look like in SQL:&lt;/p&gt;
  &lt;pre&gt;
&lt;code class="sql"&gt;SELECT Ord.OrderDate AS "Order Date", Ord.Freight AS "Order Freight"
FROM ((Orders AS Ord
  INNER JOIN `Order Details` AS OrdDet ON (OrdDet.OrderID = Ord.OrderID ))
  INNER JOIN Products AS Prod ON (OrdDet.ProductID = Prod.ProductID ))
WHERE
(
  Prod.CategoryID = 1 OR
  Prod.CategoryID = 8 )
&lt;/code&gt;
&lt;/pre&gt;
  &lt;p&gt;As you can see this relatively simple query requires a lot of SQL "coding". We have 3 different tables here and 2 joins between those tables.
  &lt;/p&gt;
  &lt;h2&gt;EasyQuery&lt;/h2&gt;
  &lt;p&gt;With EasyQuery this task will be much easier (sorry for the tautology).&lt;/p&gt;
  &lt;p&gt;You need to perform 3 simple steps:&lt;/p&gt;
  &lt;ol&gt;
  &lt;li&gt;In columns panel you add "Order Date" and "Order Freight" columns.&lt;/li&gt;
  &lt;li&gt;Then you change all element to any the root condition group in query panel. It must look like "...where any of the following apply".&lt;/li&gt;
  &lt;li&gt;Finally you add two conditions into columns panel:
  &lt;p&gt;Product Category is equal to Beverages&lt;/p&gt;
  &lt;p&gt;Product Category is equal to Seafood&lt;/p&gt;
  &lt;/li&gt;
  &lt;/ol&gt;
  &lt;div class="c-center"&gt;
  &lt;div class="krh-blog-ss-block"&gt;
  &lt;a href="~/static/easyquery/usecases/query-or-1.gif" class="fancybox" data-fancybox-group="gallery" title="EasyQuery example: query with OR operators"&gt;
  &lt;img src="~/static/easyquery/usecases/query-or-1.gif" alt="EasyQuery example: query with OR operators"&gt;
  &lt;/a&gt;
  &lt;/div&gt;
  &lt;/div&gt;
  &lt;h2&gt;Query 2&lt;/h2&gt;
  &lt;p&gt;Now imagine we need to add another condition which will be mandatory: we need to list only paid orders. So the final query will have the following structure:&lt;/p&gt;
  &lt;pre&gt;
&lt;code class="sql"&gt;Order is paid AND
  (Product Category is Beverages OR Seafood)&lt;/code&gt;
&lt;/pre&gt;
  &lt;h2&gt;SQL 2&lt;/h2&gt;
  &lt;p&gt;The SQL statement for this new query will be the following:&lt;/p&gt;
  &lt;pre&gt;
&lt;code class="sql"&gt;SELECT Ord.OrderDate AS "Order Date", Ord.Freight AS "Order Freight"
FROM ((Orders AS Ord
  INNER JOIN `Order Details` AS OrdDet ON (OrdDet.OrderID = Ord.OrderID ))
  INNER JOIN Products AS Prod ON (OrdDet.ProductID = Prod.ProductID ))
WHERE
(
  Ord.Paid = true AND (
  Prod.CategoryID = 1 OR
  Prod.CategoryID = 8 ) )
&lt;/code&gt;
&lt;/pre&gt;
  &lt;h2&gt;EasyQuery 2&lt;/h2&gt;
  &lt;p&gt;With EasyQuery components it will take one additional step.&lt;/p&gt;
  &lt;ol&gt;
  &lt;li&gt;As in previous case you add "Order Date" and "Order Freight" columns.&lt;/li&gt;
  &lt;li&gt;In query panel add one condition: Order Paid is true.&lt;/li&gt;
  &lt;li&gt;Please note that you don't need to change all to any in this case.&lt;/li&gt;
  &lt;li&gt;After that press {+} button in the first row to add a new group of conditions after first condition.&lt;/li&gt;
  &lt;li&gt;New condition group will automatically take any type of linking.&lt;/li&gt;
  &lt;li&gt;EasyQuery will automatically add a condition in new group. Change the attribute in that condition to "Product Category" and select "Beverages" in the right part of the condition.&lt;/li&gt;
  &lt;li&gt;Add one more condition into the group. Use (+) button in the group row (but not in root row!) to do it. Select "Product Category" as attribute and "Seafood" as a value for this condition.
  &lt;br&gt;Product Category is equal to Seafood&lt;/li&gt;
  &lt;/ol&gt;
  &lt;p&gt;Finally you should see something like the following:&lt;/p&gt;
  &lt;div class="c-center"&gt;
  &lt;div class="krh-blog-ss-block"&gt;
  &lt;a href="~/static/easyquery/usecases/query-or-2.gif" class="fancybox" data-fancybox-group="gallery" title="EasyQuery example: query with OR operators"&gt;
  &lt;img src="~/static/easyquery/usecases/query-or-2.gif" alt="EasyQuery example: query with OR operators"&gt;
  &lt;/a&gt;
  &lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</Content>
    <Tags>,data-model,code-sample,operator-or,sql,entity-framework,</Tags>
  </Article>
  <Article id="8eafd64d-5a87-44f2-8cf0-45096f782d00" title="EntityGraph class">
    <Content>```csharp
public class Korzh.EasyQuery.EntityGraph
    : ObjectGraph&lt;Type&gt;

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Type` | ContextType |  | 
| `Boolean` | IsEmpty |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | GetCollectionName(`Type` type) |  | 
| `EdgeInfo` | GetEdgeInfo(`ObjectModelType` t1, `ObjectModelType` t2) |  | 
| `String` | GetNavigationPropertyName(`Type` from, `Type` to) |  | 
| `void` | SetCollectionName(`Type` type, `String` name) |  | 
| `void` | SetNavigationPropertyName(`Type` from, `Type` to, `String` name) |  | 
| `void` | UpdateEntityJoinInfo(`Type` outerType, `Type` innerType, `String` outerPropertyName, `String` innerPropertyName) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="90114c07-be93-4264-9138-2083c3138650" title="OperatorList class">
    <Content>```csharp
public class Korzh.EasyQuery.OperatorList
    : Collection&lt;Operator&gt;, IList&lt;Operator&gt;, ICollection&lt;Operator&gt;, IEnumerable&lt;Operator&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;Operator&gt;, IReadOnlyCollection&lt;Operator&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | AddByIDs(`DataModel` model, `String` ids) |  | 
| `void` | CopyFrom(`OperatorList` operators) |  | 
| `Operator` | FindByID(`String` OpID) |  | 
| `Int32` | IndexByID(`String` OpID) |  | 
| `void` | RemoveByIDs(`DataModel` model, `String` ids) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="90ec3558-b322-4257-b8d0-a1805b967273" title="Customizing common SQL clauses">
    <Content>## 1. Problem Overview
Working with EasyQuery, sometimes you need to add to generated SQL some additional clauses, which are common for the whole query (DISTINCT, TOP, etc)

## 2. Setting DISTINCT clause

To implement this you need to use `Options.SelectDistinct` property of a DbQuery object:

```
query.Options.SelectDistinct = true;
```

## 3. Setting LIMIT and/or TOP clauses
You can add TOP or LIMIT clause into result SQL statement using the following commands:
```
query.Options.SelectTop = "100";
```
Or

```
query.Options.LimitClause = "20";

```
</Content>
    <Tags>,clauses,distinct,code-sample,sql,</Tags>
  </Article>
  <Article id="9244d3f7-94a4-488d-b896-b64981c8fc92" title="ValueEditorEntry class">
    <Content>```csharp
public class Korzh.EasyQuery.ValueEditorEntry

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `ValueEditor` | Editor |  | 
| `OperatorList` | Operators |  | 
| `DataType` | Type |  | 


</Content>
    <Tags />
  </Article>
  <Article id="936413cb-3c82-4152-b6a6-9e57c50e9a2f" title="Building data model dynamically by information from DataTable">
    <Content>`DataModel` class has a special method `FillByDataTable()` which you can use to add a table, an entity and its attributes into your data model by some `DataTable` object. You can call it several times to add more tables and entities. After that, you will possibly need to add links between tables.

Here is an example which adds into data model all default operators, two tables (Customers and Orders), corresponding entities and a link between those tables: 

```
 //clear current model
  model.Clear();
 
  //add default operators
  model.AddDefaultOperators();
 
  //create necessary DataTable objects (here we suppose connection is an instance of some DbConnection descendant type)
  DataSet tempDS = new DataSet();
  OleDbDataAdapter custDA = new OleDbDataAdapter("SELECT * FROM CUSTOMERS", DbConnection);
 
  custDA.Fill(tempDS, "Customers");
  DataTable custTable = tempDS.Tables["Customers"];
 
  //add Customer table into data model. Correponding entity is also created (second parameter is true)
  model.FillByDataTable(custTable, true);
 
  OleDbDataAdapter ordDA = new OleDbDataAdapter("SELECT * FROM ORDERS", DbConnection);
 
  ordDA.Fill(tempDS, "Orders");
  DataTable ordTable = tempDS.Tables["Orders"];
 
  //add Orders table into data model.
  model.FillByDataTable(ordTable, true);
 
  //After that we need to add links between those tables:
  TableLink newLink = new TableLink();
  newLink.Table1 = model.Tables.FindByAlias("Customer");
  newLink.Table2 = model.Tables.FindByAlias("Orders");
  newLink.Type = TableLink.LinkType.Inner;
 
  TableLink.Condition newCond = new TableLink.Condition(newLink);
  newCond.Expr1 = "CustNo";
  newCond.Expr2 = "CustNo";
  newCond.Operator = "=";
  newLink.Conditions.Add(newCond);
 
  model.Links.Add(newLink);
```</Content>
    <Tags>,data-model,code-sample,data-table,tables,links,entity-framework,</Tags>
  </Article>
  <Article id="939b8384-29d1-4115-b30f-96c856f9e102" title="Query with table joins">
    <Content>Let’s make our example more interesting. Suppose we would like to see all orders for USA customers. For each order, we want to see the name of customer, order date and sum. All result rows must be sorted by the order date.

To get this data by SQL, we need to join two tables (Customers and Orders), list necessary columns in SELECT clause and add ORDER By clause:

```sql
SELECT Ord.OrderDate, Cust.CompanyName, Ord.Freight
FROM Customers AS Cust
  JOIN Orders AS Ord ON (Ord.CustomerID = Cust.CustomerID ))
WHERE
  Cust.Country = 'USA'
ORDER BY Ord.OrderDate
```

Here is the point where you can see how EasyQuery can simplify the process of query construction. All you need to do - is to add necessary columns into Columns panel and set the sorting order for Order date column. EasyQuery will take care of the rest: tables joins, correct aliases for tables and columns, etc.

So, just click on “[Add column]” link, select Order | Date from the menu. Then repeat this operation for Customer | Company Name and Order | Freight attributes. Finally, click on the first button in Order Date column row and select “Ascending” from the drop-down list.

Here is a screenshot what you will get in the result - an example of a query with a tables' join:

![Query with table joins](/files/test/easyquery-dotnet/images/query-example-02.png)</Content>
    <Tags>,query-example,sql,table-join,code-sample,</Tags>
  </Article>
  <Article id="93b52735-9ea4-4e03-b262-23946d05a832" title="QueryListItem class">
    <Content>```csharp
public class Korzh.EasyQuery.Services.QueryListItem

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | description |  | 
| `String` | id |  | 
| `String` | name |  | 


</Content>
    <Tags />
  </Article>
  <Article id="949ab0fb-8659-4eda-9817-987377c61116" title="About product key">
    <Content>## 1. What is it
The product key is a kind of digital key that stores information about your license for EasyQuery and allows you to unlock all the features of this library that are not available in the trial version.

## 2. How to use
To use the product key, you just need to add the following piece of code somewhere at the beginning of your program (before using EasyQuery for the first time):
 
```c#
Korzh.EasyQuery.License.Key = “Your key goes here”;
```
 
The product key works within one minor version of EasyQuery. For example, the key created for version 4.0.0 will be valid for versions 4.0.1 or 4.0.5, but will not work with version 4.1.0.
 
Therefore, when updating the version of the library used in your project, remember to replace the key in your program (in the piece of code described above).
 
To generate a new key, you need:

* Log in to your account at [Client's Area](https://korzh.com/account) on Korzh.com
* Go to the Details page for your EasyQuery license (link Details in the license description line)
* Click the "Get Key" button for the version you need
 
If there is no the version you need in the list - it means that your software maintenance subscription has expired already and you need to renew it. You can do it on the same page by clicking on the Renew link.</Content>
    <Tags>,product-key,license,code-sample,</Tags>
  </Article>
  <Article id="94c6d267-264e-4765-a486-eaa2151c7968" title="Date/time values formatting">
    <Content>While working with EasyQuery and Data Models, you will need to set up your own format of date &amp; time. There are several types of formatting you may need: 

* date/time values in generated SQL
* date/time values in visual controls/widgets
* date/time values in the grid which displaying the result set on client’s side

Here we are going to take a look more closely at all these cases and provide code examples for each of them.

## 1. SQL 
There is `Formats` property in SqlQueryBuilder class which allows you to set up generated SQL, in which you can choose needed formats for date/time values via `Formats.DateFormat`, `Formats.TimeFormat` or `Formats.DateTimeFormat` sub-properties. 
In a case of MVC project - this property can be accessed through `Formats` of and using EqServiceProviderDb class.

So here are the code examples:

MVC:

```c#
public EasyQueryController() {
  eqService = new EqServiceProviderDb();
  
  . . . . . . . . 

  //setting default formats for some type of SQL Server
  eqService.Formats.SetDefaultFormats(FormatType.MsSqlServer);
  eqService.Formats.DateFormat = “MM/dd/yyyy”;
  eqService.Formats.TimeFormat = “HH:mm:ss”;
  eqService.Formats.DateTimeFormat = “MM/dd/yyyy HH:mm:ss”;
 
  . . . . . . . . 

}
```

For other editions:

```c#
. . . . . . . .
SqlQueryBuilder builder = new SqlQueryBuilder(query);
eqService.Formats.DateFormat = “yyyy-MM-dd”;
builder.BuildSQL();
. . . . . . . .
```

More information about SQL formats you can find in the following [article](https://korzh.com/easyquery/docs/how-to/customizing-sql-query-formats)




## 2. Visual controls / Widgets

Date/time formatting in visual controls or widgets can differ in various editions of EasyQuery. 

### 2.1. ASP.NET MVC
Use `dateFormatValue` and `dateFormatDisplay` options of QueryPanel widgets.
You can find date/time formatting settings in this [article](https://korzh.com/easyquery/docs/tutorials/how-to-set-up-javascript-widgets-mvc-version), items 2.1 and 2.2.

### 2.2. ASP.NET WebForms and WinForms
In these editions, you can use `Apperance.DateFormat` and `Appearance.TimeFormat` properties of QueryPanel control. The format of date+time values is set as a concatenation of these two formats. 
Example:
```c#
QueryPanel1.Appearance.DateFormat = "MM/dd/yyyy";
QueryPanel1.Appearance.TimeFormat = "HH:mm";
```

### 2.3. WPF and Silverlight
Both these editions do not have any additional options which would allow you to change date/time values format in visual controls. Instead, they use the formats defined in `CurrentCuluture` property for a current thread.
Here is how you can change current culture setting for your application:

 ```c#
//set current culture to Ukrainian
System.Threading.Thread.CurrentThread.CurrentCulture = new System.Globalization.CultureInfo("uk-UA");
```


## 3. Displaying date/time values in result grid

Although this part is not covered by EasyQuery components directly, we are often asked about formatting date/time values in the table or grid that display the result set you got after query execution. 
Here we collected the most useful recommendations on this topic: 

### 3.1. ASP.NET/MVC 
You can find date/time formatting settings in this [article](https://korzh.com/easyquery/docs/tutorials/managing-result-grid-client-side) 

### 3.2. ASP.NET WebForms edition
Here we guess that you use GridView control to show the result set. In such case, you can use BoundField element together with its DataFormatString property for formatting date/time values.
For more information about BoundField, please read MSDN [article](https://msdn.microsoft.com/en-us/library/system.web.ui.webcontrols.boundfield.aspx)

Here is an example of defining date column with formatting:

```c#
&lt;asp:BoundField DataField="OrderDate" HeaderText="Order Date" 
  DataFormatString="{0:MM/dd/yyyy hh:mm tt}" /&gt;
```

### 3.3 WinForms edition
You can use DefaultCellStyle.Format property for a particular column in your data grid:

```c#
dataGrid.Columns[2].DefaultCellStyle.Format = "MM/dd/yyyy HH:mm:ss";
```


### 3.4. WPF and Silverlight
In our examples, we use DataGrid control to show the result sets.
To set proper date/time format for DataGrid columns you can use AutoGeneratingColumn event handler:

```xml
&lt;DataGrid AutoGeneratingColumn="OnAutoGeneratingColumn" ... /&gt;
```

And then in behind code do something like this:

```c#
private void OnAutoGeneratingColumn(object sender, DataGridAutoGeneratingColumnEventArgs e)
{
  if (e.PropertyType == typeof(System.DateTime))
  (e.Column as DataGridTextColumn).Binding.StringFormat = "dd/MM/yyyy";
}
```</Content>
    <Tags>,formats,date-time,sql,grid,code-sample,</Tags>
  </Article>
  <Article id="954ea337-3588-45fc-8eac-308cd7a8da02" title="ListItemComparer class">
    <Content>```csharp
public class Korzh.EasyQuery.Services.ListItemComparer
    : IEqualityComparer&lt;ListItem&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | Equals(`ListItem` x, `ListItem` y) |  | 
| `Int32` | GetHashCode(`ListItem` obj) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="9578c204-a063-4087-8879-97481150f342" title="BaseQueryBuilder class">
    <Content>```csharp
public abstract class Korzh.EasyQuery.BaseQueryBuilder
    : IQueryBuilder

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | condFieldName |  | 
| `Boolean` | paramMode |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `QueryFormats` | Formats |  | 
| `DataModel` | Model |  | 
| `Query` | Query |  | 
| `Type` | ResultType |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | CalcScalarExpr(`Condition` cnd, `String` value, `DataType` dataType, `ScalarExprOptions` exprOptions) |  | 
| `QueryFormats` | CreateQueryFormats() |  | 
| `QueryBuilderResult` | CreateResult() |  | 
| `String` | GetParamExpr(`String` id) |  | 
| `QueryBuilderResult` | GetResult() |  | 
| `void` | ProcessDefaultMacros(`StringBuilder` sb, `Boolean` quoting = False) |  | 
| `void` | ProcessMacros(`Condition` cnd, `StringBuilder` s, `DataType` dataType, `Boolean` quoting = False) |  | 
| `String` | ProcessScalarValue(`Condition` cnd, `String` value, `DataType` dataType, `ScalarExprOptions` exprOptions) |  | 
| `String` | ToString() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="96681c46-52c8-4551-a049-0d8b3493c1d8" title="License class">
    <Content>```csharp
public static class Korzh.EasyQuery.License

```

### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | IsRegistered |  | 
| `String` | Key |  | 


</Content>
    <Tags />
  </Article>
  <Article id="96684910-aa77-47a3-9c87-f184060c0fd9" title="Version 4.2.0 release notes">
    <Content> ## 1. Core library

 * Some improvements in `FillByDbGate` method of DbModel class: new `options` parameter and a possibility to turn on/off DB views from scanning
* A possibility to use indexing in operator expressions for "List" kind of values. For example: `{expr1} BETWEEN {expr2[0]} AND {expr2[1]}

## 2. JavaScript

* onError and onLoadQuery callbacks in easyQuerySettings
* setDescription() method in Query object

## 3. Angular sample

* Now we have a sample project which demonstrates you how to use EasyQuery to set up an advanced search page in an Angular application.

**NB:** All EasyQuery samples (including the new one) are available on [GitHub repository](https://github.com/easyquery/AspNetCoreSamples)

## 4. Custom value editor example

* We have added an example of defining a custom value editor in our EqAspNetCoreDemo01 sample project. You can check how it works by adding a condition with "Product | Units in stock" attribute and "In range" operator.

## 5. Fixes

* AlphaAlias and QuoteColumnAlias settings now work separately from each other
* Collection navigation properties are now supported in DbModel.LoadFromEntityType and IQueryable.DynamicQuery extension methods.</Content>
    <Tags>,asp-net-core,javascript,</Tags>
  </Article>
  <Article id="97b2db8d-0b98-4ccc-aad8-237017192385" title="ChangeType class">
    <Content>```csharp
public enum Korzh.EasyQuery.ChangeType
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | Total |  | 
| `1` | Addition |  | 
| `2` | Removal |  | 
| `3` | Update |  | 


</Content>
    <Tags />
  </Article>
  <Article id="983aac3c-eb61-4c23-9b37-f4d3d83f0e3e" title="Version 3.0 release notes">
    <Content>## **New in version 3.0**

### 1. New structure of EasyQuery assemblies and namespaces

In version 3.0 we have removed all database-related functionality from the core classes in Korzh.EasyQuery namespace (like DataModel and Query). So now it's possible to use EasyQuery for querying not only databases but in general almost any type of data. As an example, you can see our new service [Advangle](http://advangle.com) which allows you to build web-search queries for Google and Bing. Database-related implementation of the core classes was moved into another namespace: Korzh.EasyQuery.Db. Here you will find such classes as DbQuery (inherited from Query) and DbModel (inherited from DataModel). Use these classes to set up an old good SQL query builder in your application.

### 2. "Builder" classes

Query class (as well as its descendant DbQuery) does not implement any “SQL generation” functionality now. It just a container that holds the structure of the query (condition tree, a list of columns, etc.). To build an SQL statement, you need to use a special builder class (SqlQueryBuilder in this case). In general, you can use several different builders for the same query. We already have an implementation of builder class for SQL (SqlQueryBuilder) and plan to implement other classes for different query languages (like HQL, XQuery, etc.).

### 3. JavaScript UI library

For web applications, we created a JavaScript edition of our visual components (like QueryPanel or ColumnsPanel). They are implemented as JQuery widgets and can be used with any kind of back-ends (not only ASP.NET). As an example of such approach, we created MVC sample project which is available at http://demo.easyquerybuilder.com/asp-net-mvc/ and is also included in the installation package of EasyQuery for ASP.NET.
</Content>
    <Tags>,javascript,data-model,entity-framework,</Tags>
  </Article>
  <Article id="9a0341a6-4783-44fd-80cd-3071f7e60c67" title="PagingSettings class">
    <Content>```csharp
public class Korzh.EasyQuery.Services.PagingSettings
    : IPaging

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | Enabled |  | 
| `Int64` | PageCount |  | 
| `Int64` | PageIndex |  | 
| `Int64` | PageSize |  | 
| `Int64` | TotalRecords |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `JsonDict` | SaveToJsonDict() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="9aa3a2a0-49fa-4349-85fc-e18e68a34c12" title="Version 3.8.0 release notes">
    <Content>## 1. New functions in EasyQuery (actual for all versions)

We've added support for parameters in virtual attribute expressions and also support for parameterized conditions. Read more about two methods of using parameters in query conditions in this [article](https://korzh.com/easyquery/docs/how-to/parameters-in-query-conditions).

Beginning from the version EasyQuery 3.8.0 there is a possibility to set format of date values during exporting: CsvFormats.DateFormat, ExcelFormats.DateFormat.

Pay attention, that column data type information is added into DataTable JSON passed from server to client.

Also, we'd like to note, that ExcelFormats was renamed from Korzh.Utils.Db to **HtmlFormats**.

## 2. New options for JavaScript widgets

* All elements in EasyQuery widgets now have their IDs.
* New methods in Query object: `addSimpleCondition`, `removeColumns`, `addPredicate`. You can "process" events in Query object: they are fired on process start and finish, like model loading or adding a bunch of columns from Entities panel.
* New EasyChart widget.
* New options in EntitiesPanel widget: `autoClearSelection`, `syncWithColumns`.
* New options in QueryPanel widget: `yearRange`, `allowDragDrop`, `attrPlacement`, `sortEntities`. There is also new `allowParameterization` option in QueryPanel widget in JavaScript edition.
* New options in ColumnsPanel widget: `titleElementFormat` option.</Content>
    <Tags>,javascript,widgets,data-model,entity-framework,</Tags>
  </Article>
  <Article id="9b7ea7e0-fb7f-4934-8cb5-2c8c499c2122" title="ObjectModelType class">
    <Content>```csharp
public class Korzh.EasyQuery.ObjectModelType
    : IEquatable&lt;ObjectModelType&gt;

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Type` | Type |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | Equals(`ObjectModelType` other) |  | 
| `Boolean` | Equals(`Object` obj) |  | 
| `Int32` | GetHashCode() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="9c35366b-546e-428e-ae18-ac1ba142719b" title="Simple query over one table">
    <Content>&lt;div class="row"&gt;
  &lt;div class="col-md-12 c-content-media-1 krh-blogpost"&gt;
  &lt;p&gt;Let’s suppose we need just a list of customers from one particular country (e.g. USA). In terms of SQL this query will look like:&lt;/p&gt;
  &lt;pre&gt;&lt;code class="sql"&gt;SELECT * 
FROM Customers
WHERE Country = 'USA'
&lt;/code&gt;
&lt;/pre&gt;
  &lt;p&gt;With EasyQuery this simple query become even easier. Just click “Add new condition” link, select Customer | Country in menu. Then click on the third element in a new condition ([Select value]) and choose the USA from drop down list that appear. Check SQL statement that appeared in the bottom-left panel and click “Execute” button to see the result of your query.&lt;/p&gt;
  &lt;div class="c-center"&gt;
  &lt;div class="krh-blog-ss-block"&gt;
  &lt;a href="~/static/easyquery/usecases/query-example-01.png" class="fancybox" data-fancybox-group="gallery" title="EasyQuery example of simple SQL query over one table"&gt;
  &lt;img src="~/static/easyquery/usecases/query-example-01.png" alt="EasyQuery example of simple SQL query over one table"&gt;
  &lt;/a&gt;
  &lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</Content>
    <Tags>,data-model,entity-framework,conditions,query-example,</Tags>
  </Article>
  <Article id="9d81d5b1-c958-4c40-990a-5ca33bb42f98" title="DataType class">
    <Content>```csharp
public enum Korzh.EasyQuery.DataType
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | Unknown |  | 
| `1` | String |  | 
| `2` | Byte |  | 
| `3` | Word |  | 
| `4` | Int |  | 
| `5` | Int32 |  | 
| `6` | Int64 |  | 
| `7` | Bool |  | 
| `8` | Float |  | 
| `9` | Currency |  | 
| `10` | BCD |  | 
| `11` | Date |  | 
| `12` | Time |  | 
| `13` | DateTime |  | 
| `14` | Autoinc |  | 
| `15` | Memo |  | 
| `16` | Blob |  | 
| `17` | FixedChar |  | 
| `18` | Guid |  | 
| `19` | Geometry |  | 
| `20` | Geography |  | 


</Content>
    <Tags />
  </Article>
  <Article id="9d85d5b1-9483-40cc-8b58-ac2ea042c35f" title="Version 4.0 release notes">
    <Content>Version 4.0 of EasyQuery includes a lot of changes. Here is the list of the most significant ones.
 
## 1. Support for .NET Core 
From the version 4.0 and further on, we add support for the .NET Core. All basic EasyQuery assemblies now target .NET Standard version 1.3 (or 1.5 for some assemblies) - so they can be used both in .NET Core and .NET 4.5.2 (or higher) projects.
 
## 2. New edition: EasyQuery for ASP.NET Core
Currently, version 4.0 is available only for the new edition of EasyQuery - **EasyQuery for ASP.NET Core** (short version: **EasyQuery ANC** ).    
As the name implies, this edition can be used in new ASP.NET Core projects only. All current license owners of EasyQuery for ASP.NET can get the license for EasyQuery ANC with 80% discount (limited time offer).

## 3. Version 3.x branch
As we stated above, at the moment, version 4.0 can only be used in ASP.NET Core applications. For the rest of the .NET platforms (Windows Forms, ASP.NET 4, WPF) you can still use version 3.x of EasyQuery which we are going to develop and maintain for the next 2 years at least.

During this time, we are going to transfer the rest of the editions (except EasyQuery Silverlight) to version 4.x.
 
## 4. New distribution model

.NET Core projects only support referencing Nuget packages but not binary assemblies. So, that’s why we changed our distribution model both for trial version users and for license owners. 

Here are the main principles:

* Nuget only.    
No installation is needed. 
All EasyQuery assemblies are distributed as Nuget packages now.   
The only exception from this rule is Data Model Editor utility which is available for [free download](/download/dme_setup.exe) as a separate setup file.

* Product key for license owners.    
Instead of downloading and installing the full version of EasyQuery - you will now need a unique product key and one line of code to remove all trial version limitations.    
Here how it looks:

```
Korzh.EasyQuery.License.Key = "YourProductKeyCodeGoesHere";  
```
The product key will be available on your [Client’s Area](https://korzh.com/account) page of our web-site. If it's not generated yet - just click on "Get key" button for the version you would like to use.
  
## 5. Version 4.0 samples 
All sample projects for EasyQuery 4.0 are available on [GitHub] (https://github.com/easyquery/AspNetCoreSamples) now.
 
## 6. Upgrade from version 3.x
There are many changes in EasyQuery API version 4.x in comparison with version 3.x.
Here you will find the [detailed list of them and the instructions](/easyquery/release-notes/upgrade-from-3.x-to-4.0) for upgrading your projects.

 
</Content>
    <Tags>,asp-net,code-sample,asp-net-core,</Tags>
  </Article>
  <Article id="9df6dc6d-1ebf-41d7-8f8c-7ab65f54095e" title="EqListValueEditorAttribute class">
    <Content>```csharp
public class Korzh.EasyQuery.EqListValueEditorAttribute
    : Attribute

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | Id |  | 
| `String` | ListName |  | 
| `String` | SQL |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | ProcessEntityAttr(`EntityAttr` attr) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="9e2ea501-aa03-4e51-bc14-d9b39f0a78c0" title="SimpleMacroValue class">
    <Content>```csharp
public class Korzh.EasyQuery.SimpleMacroValue
    : IMacroValue

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Int32` | Count |  | 
| `DataType` | DataType |  | 
| `String` | ID |  | 
| `String` | Value |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | GetValue(`Int32` index) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="a0220401-0c6a-459b-848e-d7a2e2098d99" title="EqServiceError class">
    <Content>```csharp
public class Korzh.EasyQuery.Services.EqServiceError
    : Exception, ISerializable

```

</Content>
    <Tags />
  </Article>
  <Article id="a02f521e-b46b-4907-9270-a23ed206b85b" title="Edit link dialog">
    <Content>In this dialog, you can define the following properties for some link between tables:

* **Table1** and **Table2** combo box - can be used to choose the linked tables.
* **Join type** group of radio buttons allows you to specify the type of join (inner, left outer, right outer or full join).
* **Join conditions** panel - allows you to specify the conditions of the link.

The “Join conditions” panel consists of two main parts. Firs part (at the top) is the list of conditions, second (at the bottom) contains different control which allows to define the new condition and add it to the list.

**Delete** button at the right of condition list deletes a selected condition. **Clear** button - clears all conditions completely.

To add a new condition, you need to do the following:

1) Select the type of each condition part (left and right)

2) Select table field (in case of “Field” type) or enter a constant expression (for “Constant” type) for each condition part

3) Select operator (”=” by default)

4) Press “Add Condition” button

</Content>
    <Tags>,data-model,tables,conditions,</Tags>
  </Article>
  <Article id="a1612680-6650-4d53-bc94-39d3ba06fd4b" title="Getting started for Windows Forms">
    <Content>1) Run Data Model Editor application in wizard mode (“Create Data Model” program icon) and follow the instructions to create a new data model that describes the data in your database. You will define database tables you want to use in your future queries, links between them and entities with their attributes (mostly the fields in already added tables).

2) Save created data model to some file on your hard-drive (let it be model1.xml for example);

3) Drop DbModel, DbQuery and QueryPanel components on a form. You need to add these components to a Visual Studio toolbox first if you have not done this before.

4) Link DbQuery component to DbModel through Model property;

5) Link QueryPanel component to DbQuery component through Query property.

6) Add the following code into your form initialization procedure (e.g. in form's constructor): `DataModel.LoadFromFile` method call to load previously created data model file;
`QueryPanel.Activate` method call to activate the query panel.

Example: 

```
public MainForm()   
 {   
    InitializeComponent();   
 
    dataModel1.LoadFromFile("model1.xml");   
 
    queryPanel1.Activate();   
 }
```
7) You can also drop on your form QueryColumnsPanel control to allow your users to define the result columns. Link QueryColumnsPanel with DbQuery object exactly like for QueryPanel control.
After the steps described above your users can add query conditions and result columns;

8) When it's necessary to generate an SQL statement - create an instance of SqlQueryBuilder class and call its BuildSQL() method. Usually, this method is called on some user action (e.g. pressing “Build” button). After that read generated SQL from Result.SQL property of a SqlQueryBuild object.

9) Finally,  you can pass the generated SQL statement to some DataSource for execution or use it in any other possible way.

Example: 

```
protected void BuildBtn_Click(object sender, EventArgs e) { 
    SqlQueryBuilder builder = new SqlQueryBuilder(query1);
    if (builder.CanBuild) {
        builder.BuildSQL();
        string sql = builder.Result.SQL;
        //clear previous result data if exist 
        ResultDS.Tables[0].Rows.Clear(); 
        ResultDS.Tables[0].Columns.Clear(); 
        try { 
            OleDbDataAdapter resultDA = new OleDbDataAdapter(query1.Result.SQL, DbConnection); 
            resultDA.Fill(ResultDS, "Result"); 
        }  
        catch (Exception error) { 
            //if some error occurs just show the error message  
            MessageBox.Show(error.Message);       
        }  
    }
} 
```</Content>
    <Tags>,winforms,dbquery,query-panel,get-start,dme,code-sample,</Tags>
  </Article>
  <Article id="a1bdd248-1224-4697-acc6-d25d5c48b7bd" title="Getting started for EasyQuery ASP.NET Core">
    <Content>## 1. Getting started with our demos

To understand the whole process of working with EasyQuery, we recommend installing demo projects from the [EasyQuery Samples repository on GitHub](https://github.com/easyquery/AspNetCoreSamples). You will be able to try different scenarios and find out how the functionality works.

You can find detailed instructions on how to set up and start demo projects in the ReadMe document on this GitHub repository.

## 2. Install EasyQuery into your ASP.NET Core project   
aaaaaaaaaaaaa   bbbbbbbbbbbbb   ccccccccccccccc
Here we suppose that we have ASP.NET Core web project with MVC/Razor as a view engine and EntityFramework Core used for data access. The described approach will work well (with some changes) for Razor Pages.

### 2.1. Add EasyQuery packages
Here are the packages you will need to add to your project:
 * `Korzh.EasyQuery.AspNetCore`
 * `Korzh.EasyQuery.EntityFrameworkCore.Relational`
 * `Korzh.DbExport` (optional, only if you plan to use exporting functionality)

You can do it either using Nuget Package Manager or Nuget Package Console in Visual Studio. You can also use `dotnet` command from the console.
Here is the example of adding packages using .NET Core CLI (please note that you have to run these command from the project's folder):

```console
dotnet add package Korzh.EasyQuery.AspNetCore
dotnet add package Korzh.EasyQuery.EntityFrameworkCore.Relational
```

### 2.2. Install EasyQuery templates package
.NET Core has a new and convenient template system. So, we prepared a special template package which allows you to scaffold an EasyQuery controller and view very quickly.

First, you need to install that template package.
```console
dotnet new --install  Korzh.EasyQuery.AspNetCoreTemplates::*
```

### 2.3. Scaffold an advanced search page using new template
Now, when the template package is installed you can add EasyQuery controller, view, and JavaScript files to your project using the following command:

```console
dotnet new  eq.view.advsearch --DbContextName YourDbContextClassName
```
(as on the step #1 - this command must be run from the project's folder).

The new EasyQueryController.cs file (you can rename it later) will be created in Controllers folder, and the new EasyQuery.cshtml view file - in Views\EasyQuery folder.
The controller is almost ready to run - you just need to add `using` statement to your DbContext namespace to make it compilable.   
For example:
```c#
using MyProjectName.Data;
```

### 2.4. Add EasyQuery services to DI container
The final step will be to register EasyQuery services in the dependency injection container in your project.
Just open your Startup.cs file and add the following line at the end of `ConfigureServices` method:

```c#
services.AddEasyQuery();
```

That's it. Build and run your project. When it's started - open `/EasyQuery` URL to test new page for advanced search.

</Content>
    <Tags />
  </Article>
  <Article id="a3aa9c10-3f4d-43b6-96d4-486b8c5778fb" title="IConditionCreator class">
    <Content>```csharp
public interface Korzh.EasyQuery.IConditionCreator

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Condition` | Create(`DataModel` model) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="a4a8ee2a-dd8c-4138-8bb1-3117c1cf7f98" title="MacroList class">
    <Content>```csharp
public class Korzh.EasyQuery.MacroList
    : Collection&lt;IMacroValue&gt;, IList&lt;IMacroValue&gt;, ICollection&lt;IMacroValue&gt;, IEnumerable&lt;IMacroValue&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;IMacroValue&gt;, IReadOnlyCollection&lt;IMacroValue&gt;

```

</Content>
    <Tags />
  </Article>
  <Article id="a575a215-4331-4a4d-be9e-01ca8ba1b747" title="ConstValueList class">
    <Content>```csharp
public class Korzh.EasyQuery.ConstValueList
    : Collection&lt;ConstValueItem&gt;, IList&lt;ConstValueItem&gt;, ICollection&lt;ConstValueItem&gt;, IEnumerable&lt;ConstValueItem&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;ConstValueItem&gt;, IReadOnlyCollection&lt;ConstValueItem&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Int32` | Add(`String` id, `String` text) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="a72c3269-ffa5-462f-bb86-4c4b6b61e6e5" title="MacroRequestEventArgs class">
    <Content>```csharp
public class Korzh.EasyQuery.MacroRequestEventArgs

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `DataType` | DataType |  | 
| `String` | MacroId |  | 
| `String` | Value |  | 


</Content>
    <Tags />
  </Article>
  <Article id="aa251fc3-2925-4a22-b9be-9b8832e576ca" title="Customizing SQL query formats">
    <Content>## Problem Overview

Working with EasyQuery, you can use different DB systems, such as MS SQL Server, My SQL, Oracle, etc. All these systems support SQL,
but can use slightly different syntax for table joins, different quoting symbol or different formats for some particular types of values (date/time, boolean and so on). 

Sometimes you need to define some special requirements, for example, you may want to make all columns in generated query have clear and readable titles.

All such requirement can be controlled by special `Formats` property exposed in `SqlQueryBuilder` and `EqServiceProviderDb` classes.

## Default Formats

There is `SetDefaultFormats` method in EasyQuery which gives an opportunity to set formats for the most popular DB systems into defaults. The primary parameter for this method is enumeration `FormatType`. These are possible values:

* MsAccess
* MsSqlServer
* Oracle
* MySQL

Example for MVC projects:

```
eqService.Formats.SetDefaultFormats(FormatType.MsSqlServer);
```

## Formatting date/time values

You can set different Date/Time Formats, according to settings you are used to in your country, or even according to your practice.

If you need to format the date/time values in result SQL, then you can do it via `Formats.DateFormat` and `Formats.DateTimeFormat` properties of a DbQuery object. Additionally, you may specify if date/time values should be quoted via `QuoteTime` property.

Here is an example of setting date/time formats in MVC application (via EqServiceProviderDb object in EasyQueryController's constructor):

```
var eqService = new EqServiceProviderDb();
. . . . . . .
eqService.Formats.DateFormat = "dd/MM/yyyy";
eqService.Formats.DateTimeFormat = "dd/MM/yyyy HH:mm:ss";
```

For other versions you should use this code:

```
var builder = new SqlQueryBuilder(query);
builder.Formats.DateFormat = "MM/dd/yyyy";
builder.Formats.DateTimeFormat = "MM/dd/yyyy HH:mm:ss";
builder.Formats.TimeFormat = "HH:mm:ss";
builder.QuoteTime = true;
builder.BuildSQL();
```

## Boolean values

To format boolean values you can use `QuoteBool` property (with obvious meaning) and `FalseValue` and `TrueValue` properties to specify the constants that will be used as 'false' and 'true' correspondingly:

```c#
  ...Formats.QuoteBool = false;
  ...Formats.FalseValue = "0";
  ...Formats.TrueValue = "1";
```

## Column aliases formatting
Sometimes it is necessary to make user-friendly column aliases (since they can be used as column headers when showing query result in some grid).
In other cases, there can be a requirement to use alphanumeric names for column aliases. 
`Formats` has few sub-properties which allow you to control such things:

**UseColumnAliases** : *ColumnAliasesUsage* 
This property allows you to turn column aliases on/off. Possible values are:
 - *Never* - EasyQuery will not add column aliases. This option is useful only when you generate a filter string for one table/data set.
 - *IfNecessary* - default value. Column aliases will be added only if it's necessary: either there is an ambiguity between columns from different tables or the aliases is necessary for other statement clauses.
 - *Always* - aliases will be generated for all columns

**QuoteColumnAlias** : *bool* 
If true - all column aliases will be taken into quotes whether it's necessary or not.

**AlphaAlias** : *bool*
Specifies whether column aliases should be alphanumeric only. So no spaces or other symbols in alias names.

Here is an example of code for (MVC project) which turns on aliases for all columns and allows to use more "friendly" aliases (with spaces and other symbols):

```c#
eqService.Formats.QuoteColumnAlias = true;
eqService.Formats.UseColumnAliases = ColumnAliasesUsage.Always;
eqService.Formats.AlphaAlias= false;
```

## Other Options

Here is the set of additional options for DB Query Formats:

* **EOL**: *public* 
Determines the end-of-line symbol(s).

* **EscapeSymbol**: *string* 
Allows to set up the escape symbol.

* **FilterMode**: *bool* 
Specifies a value indicating whether we should generate the query for a filter (e.g. without table names in field representations). 

* **LowerFuncName**: *string* 
Assigns the name of the LOWER function.

* **MaxIdentLen**: *public int* 
Determines a maximum length of identifiers (e.g. table or column aliases) in generated queries. 0 - means that this option is ignored.

* **MoneySuffix**: *string* 
Gets or sets the suffix for the values with "money" or "currency" types.

* **OrderByStyle**: *public* 
Defines the style of ORDER BY clause.

* **WildSymbol**: *char* 
Specifies the wild symbol used in LIKE SQL operator (% by default).</Content>
    <Tags>,sql,formats,data-model,code-sample,mvc,date-time,boolean-values,</Tags>
  </Article>
  <Article id="acd0258f-067a-4d8a-b990-dfaaf394de48" title="JavaScript widgets formats and settings (MVC version)">
    <Content>Sometimes you may need to set up individual settings for EasyQuery JavaScript widgets. In this article, we describe the most common issues and give examples of code to implement.

## 1. ColumnsPanel options

The widget allows you to make some operations with a list of query result columns and manipulate with that list: add/remove a column, change its type, set column's sorting, etc.
All options of ColumnsPanel widgets can be set through `columnsPanel` property of `easyQuerySettings` global variable. Also, you can set options and call methods of ColumnsPanel in a usual for jQuery widgets way.

Here is an example how to set ColumnsPanel options when you initialize `easyQuerySettings` variable: 

```
window.easyQuerySettings = {
  serviceUrl: "/EasyQuery",
  modelName: "YourModelName", //put the name of your model here
  . . . . . . .
  columnsPanel: {
  allowAggrColumns: true,
  attrElementFormat: "{attr}", 
  showColumnCaptions: true,
  . . . . . .
  }
  . . . . . .
}
```
Some of the most popular ColumnsPanel options:

* 1.1 showColumnCaptions allows to turn on/off column titles. Gets or sets a value indicating whether columns panel must show an editable caption for each column (i.e. “SELECT ColumnName AS ColumnCaption…”).
* 1.2 showHeader is responsible for turning on/off header row. Gets or sets a value indicating whether columns panel must show a header at the top.
* 1.3 showAddRow is about turning on/off adding row. Gets or sets a value indicating whether columns panel must show a special [add column] link at the bottom. 

Other ColumnsPanel options listed [here](http://docs.korzh.com/easyquery/js/columnspanel-widget)

### Display format for columns 

To set up individual names or labels for columns in an MVC project you need to use `attrElementFormat` and `titleElementFormat'` options of QueryPanel and ColumnsPanel widgets. By default they are set to '{entity} {attr}'. You need to change them to just "{attr}".

Here is an example how to set ColumnsPanel options when you initialize `easyQuerySettings` variable: 

```
window.easyQuerySettings = {
  serviceUrl: "/EasyQuery",
  modelName: "YourModelName", //put the name of your model here
  . . . . . . .
  columnsPanel: {
  attrElementFormat: "{attr}", //set this to show only attribute`s name in Expression column, instead of [entity name] [attribute name] used by default
  titleElementFormat: "{attr}", //set this to show only attribute`s name in Title column, instead of [entity name] [attribute name] used by default
  . . . . . .
  }
  . . . . . .
}
```

## 2. QueryPanel options

You can use this widget for operations and manipulations with the list of query conditions: add a new condition or condition group, remove an existing condition, enable/disable conditions, etc. All options of QueryPanel widgets can be set through a queryPanel property of the easyQuerySettings global variable. Also, you can set options and call methods of QueryPanel in a usual for jQuery widgets way.

Here is an example how to set QueryPanel options when you initialize `easyQuerySettings` variable:

```
window.easyQuerySettings = {
  serviceUrl: "/EasyQuery",
  modelName: "YourModelName", //put the name of your model here
  . . . . . . .
  queryPanel: {
  showCheckBoxes: true,
  attrElementFormat: "{attr}",
  dateFormatValue: "mm/dd/yy",
  . . . . . .
  }
  . . . . . .
}
```

Some of the most popular QueryPanel options:

* 2.1 *dateFormatValue* is about changing formats of date/time values. This string represents the format of date values used in date/time picker widget. For a full list of the possible formats see documentation for JQuery UI Datepicker Widget http://api.jqueryui.com/datepicker/#utility-formatDate

* 2.2 *dateFormatDisplay* - allows specifying the format of date values used in condition rows (not during editing)

* 2.3 *showRootRow* and how to turn root row on/off. Gets or sets a value indicating whether query panel must show a root row which represents the main group of conditions.
* 2.4 *showAddRow* is about adding row on/ off. Gets or sets a value indicating whether query panel must show a special [add condition] link at the bottom.
* 2.5 *showConjunctions* or and/or Conjunctions on/off. If true QueryPanel widget will show conjunction elements (“and” or “or”) at the beginning of each condition.

Other QueryPanel options listed [here](http://docs.korzh.com/easyquery/js/querypanel-widget)


## 3. EntitiesPanel options

With this widget, one can add a column or columns to the ColumnsPanel and add a condition or conditions to QueryPanel. It also includes drag-and-drop support. 

Here is code example:

```
var EPDiv = $('#EntitiesPanel');
if (EPDiv.length &amp;gt; 0) {
  EPDiv.EntitiesPanel({
  showAddColumnButton: false,
  showAttributes: { usedInConditions: true, usedInColumns: false, usedInSorting: false }
  });
}
```

Some of the most common options:

* 3.1. showToolbar. Gets or sets a value indicating whether entities panel should show a toolbar with buttons at the bottom.
* 3.2. queryPanelId. Gets or sets an ID of the query panel on the same page that will be used to add conditions too. 
* 3.3. columnsPanelId. Gets or sets an ID of the columns panel on the same page that will be used to add columns too.
* 3.4. clickableAttributes. Gets or sets a value defining what should happen when user clicks on the attribute node. Values:

```
0 - nothing happen. Default behaviour.
1 - attibute is added to conditions.
2 - attribute is added to columns.
```

“draggableAttributes” option should be set to “false” in order to get values 1 and 2 worked.

Other EntitiesPanel options listed [here](http://docs.korzh.com/easyquery/js/entitiespanel-widget)

## 4. ColumnsBar widget
</Content>
    <Tags>,mvc,javascript,widgets,query-panel,entities-panel,columns-panel,asp-net,</Tags>
  </Article>
  <Article id="adb293b4-4b6d-4c8d-bae8-de01f9cd66c7" title="Managing result grid on client-side">
    <Content>## 1. Problem
Quite often it's required to modify the content and/or appearance of the client-side grid which shows the result of query execution.

Here some examples:

  * Set a format for the values in a particular column.

  * Change the content and/or style of data for certain values. For example, to show negative numbers in red, and positive - black.

  * add a column or row.

  * Turn the values in some column into links to other pages.
 

In this article, we will show you how to implement such tasks.

  

## 2. Tools
To set up needed grid interface, you can use special callback functions of global variable `easyQueryViewSettings`:

```js
&lt;script&gt;

  window.easyQueryViewSettings = {
      beforeTableRendering: function(dataTable) {
      
      },

      formatColumnHeader: function(dataTable, colIndex, label) {

      },

      formatGridCell: function (dataTable, rowIndex, colIndex, value) {

      }
  }; 
  . . . . . .
&lt;/script&gt;
```

The first parameter for all functions will be an object of DataTable "class" from the library [Google Visualization API](https://developers.google.com/chart/interactive/docs/reference#datatable-class). You can manage grid's content, using methods of this "class".
More about each callback function:
  
  * `beforeTableRendering`
  This one you should use before rendering the grid. You can change meanings of titles and other data, add columns or rows, set up different formats for certain columns.

  * `formatColumnHeader`
  This tool is the best one for editing titles of columns. `colIndex` determines the index of the column, and then `label` determines actual meaning of the title. This function puts the new title of the column back.

  * `formatGridCell`
  This function is to be used before rendering every cell at the grid. `rowIndex` and `colIndex` determine the index of the row and column, and `value`determines actual meaning of the cell. Function puts the new meaning back (even with the HTML settings)

  
Please note that the script section listed above (an assignment of `easyQueryViewSetting` variable must be placed before the inclusion of `eq.all.min.js` and `eq.view.grid.js` files in your HTML (.cshtml) page.

## 3. Use-cases

### 3.1 Formatting values in result grid

To set format values in result grid, you can use callback function `beforeTableRendering`, which is evaluated in global variable `window.easyQueryViewSettings`. 
To set needed format in a **separate column** you can use a special class formatters, described in detail [here](https://developers.google.com/chart/interactive/docs/reference#formatters).

Here is an example of the format for columns with data type date and number. Formatting other data types is implemented in a similar way.

```
  window.easyQueryViewSettings = {
  beforeTableRendering: function (dataTable) {

  var dateFormatter = new google.visualization.DateFormat({ pattern: "yyyy-MM-dd" }); //setting special pattern for date value
		var intFormatter = new google.visualization.NumberFormat({ groupingSymbol: "", fractionDigits : 0}); //removing grouping symbol and decimal part for integer values

  var colCount = dataTable.getNumberOfColumns();
  for (var i = 0; i &lt; colCount; i++) {
  var colType = dataTable.getColumnType(i);
  var colProps = dataTable.getColumnProperties(i); 
  if (colType == "date") { //using DataTable column type for choosing formatter
  dateFormatter.format(dataTable, i);
  }
  else if (colProps.dataType == "Int32" || colProps.dataType == "Int64") { //using C# data type for decision
  intFormatter.format(dataTable, i);
  }

  }

  },
  . . . . . . . .
  }
```

### 3.2. Changing the values in a column to links

Sometimes it's necessary to render the values in some column of result grid as links to some "Details" page. You can do it using `formatGridCell` callback function. This function is called for each cell in result data grid. The list of parameters contains:

* dataTable - a reference to DataTable object (from Google Visualization library)
* rowIndex - row's index
* colIndex - column's index
* value - current value for this cell. You can change that value in any way you need (e.g. wrap it into some `a` tag to make a hyperlink).

In the following example, we convert all values in "Order ID" column into links to "Order Details" page for a particular order:

```
window.easyQueryViewSettings = {
  . . . . . . . .
  formatGridCell: function (dataTable, rowIndex, colIndex, value) {
  var colId = dataTable.getColumnId(colIndex);
  var props = dataTable.getColumnProperties(colIndex);
  if (colId == "OrderID" || (props &amp;&amp; props.table == "Orders" &amp;&amp; props.field == "OrderID")) {
  var uri = "/Order/Details/" + value;
  value = '&lt;a href="' + uri + '" &gt;' + value + '&lt;/a&gt;';
  }
  return value;
  }
};
```

### 3.3. Setting a column with checkboxes

Sometimes it's necessary to add column with checkboxes into result grid - so users will be able to select several rows and pass them for some additional processing (for example to export only selected rows). We can use `beforeTableRendering` and `formatGridCell` callbacks to get the necessary result:

```html
&lt;script&gt;
  . . . . . . .
  window.easyQueryViewSettings = {
  beforeTableRendering: function(dataTable) {
  dataTable.insertColumn(0, "string", " ");
  },

  formatGridCell: function (dataTable, rowIndex, colIndex, value) {

  if (colIndex == 0) {
  return '&lt;input type="checkbox" name="selectedRows" value="' + rowIndex + '" /&gt;';
  }
  else
  return value;
  }
  };
&lt;/script&gt;
```
  
&lt;br /&gt; 
  

### 3.4. Showing "No record" message for empty result set
It would be good to show some message (e.g. "No record found") when the query returns an empty result set.
Like in the previous example we can use `beforeTableRendering` callback to perform this task. 

The basic idea will be to define an additional panel hidden panel which shows necessary message right near the result panel and then show it when the result set is empty.

Here is the code:
 
```html
&lt;script&gt;
  . . . . . . .
		
  window.easyQueryViewSettings = {
  beforeTableRendering: function(dataTable) {
  var resultPanel = $("#ResultPanel");
  var emptyResultPanel = $("#EmptyResultPanel");
  if (dataTable.getNumberOfRows() == 0) {
  resultPanel.hide();
  emptyResultPanel.show();
  }
  else {
  emptyResultPanel.hide();
  resultPanel.show();
  }
  }

  };
&lt;/script&gt;

 . . . . . . .

&lt;div id="EmptyResultPanel" style="display:none"&gt;&lt;p&gt;Record no found&lt;/p&gt;&lt;/div&gt;
&lt;div id="ResultPanel" class="result-panel-content"&gt;

 . . . . . . .
		
```
 

</Content>
    <Tags>,asp-net,javascript,mvc,client-side,results,data-type,code-sample,</Tags>
  </Article>
  <Article id="adf805e2-5694-4164-a2a5-2e9f371503f6" title="IDefaultValuesStorage class">
    <Content>```csharp
public interface Korzh.EasyQuery.IDefaultValuesStorage

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `ConstValueList` | DefaultValues |  | 


</Content>
    <Tags />
  </Article>
  <Article id="ae821bf0-aba3-45b3-b627-49fd583580ce" title="ValueEditor class">
    <Content>```csharp
public class Korzh.EasyQuery.ValueEditor

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | DefaultText |  | 
| `String` | DefaultValue |  | 
| `String` | Id |  | 
| `String` | IDBase |  | 
| `Boolean` | IsDefault |  | 
| `DataType` | ResultType |  | 
| `String` | TypeName |  | 
| `String` | XmlDefinition |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | CheckInModel(`DataModel` model) |  | 
| `Boolean` | LoadAttribute(`String` attrName, `String` attrValue) |  | 
| `void` | LoadContentFromXmlReader(`XmlReader` reader) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | SaveAttributesToXmlWriter(`XmlWriter` writer) |  | 
| `void` | SaveContentToJsonDict(`JsonDict` dict) |  | 
| `void` | SaveContentToXmlWriter(`XmlWriter` writer) |  | 
| `JsonDict` | SaveToJsonDict() |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer, `String` tagName) |  | 


### Static Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `Dictionary&lt;String, IValueEditorCreator&gt;` | Creators |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeCaption |  | 
| `String` | STypeName |  | 


### Static Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `ValueEditor` | Create(`String` type) |  | 
| `Int32` | GetNextID() |  | 
| `Boolean` | RegisterType(`String` type, `IValueEditorCreator` creator) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="af7f4e9e-2a19-45a5-972e-a53db20d2fbb" title="Condition class">
    <Content>```csharp
public class Korzh.EasyQuery.Condition

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | _isSilent |  | 
| `Predicate` | parent |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `EntityAttr` | BaseAttr |  | 
| `Boolean` | Enabled |  | 
| `String` | FullNum |  | 
| `Int32` | ID |  | 
| `Int32` | Index |  | 
| `Boolean` | IsHaving |  | 
| `Boolean` | IsInJoin |  | 
| `Boolean` | IsParameterized |  | 
| `Boolean` | IsReadOnly |  | 
| `Boolean` | IsSilent |  | 
| `Int32` | Level |  | 
| `DataModel` | Model |  | 
| `Predicate` | Parent |  | 
| `Query` | Query |  | 
| `String` | TypeName |  | 
| `Boolean` | UseDefaultValues |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | BeginUpdate() |  | 
| `void` | Changed() |  | 
| `void` | CheckDataModel() |  | 
| `void` | CheckQuery() |  | 
| `void` | EndUpdate() |  | 
| `EntityAttr` | GetBaseAttr() |  | 
| `Boolean` | GetHaving() |  | 
| `String` | GetText(`QueryTextFormats` formats, `String` levelSpace, `String` prefix) |  | 
| `String` | GetText(`QueryTextFormats` formats) |  | 
| `String` | GetText() |  | 
| `IEnumerable&lt;Entity&gt;` | GetUsedEntities() |  | 
| `void` | InnerSetEnabled(`Boolean` newValue) |  | 
| `void` | InnerSetReadOnly(`Boolean` newValue) |  | 
| `void` | LoadFromJsonDict(`JsonDict` dictCond) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | LoadXmlAttributes(`XmlReader` reader) |  | 
| `void` | MoveDown() |  | 
| `void` | MoveUp() |  | 
| `void` | Refresh() |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 
| `void` | SetEnabled(`Boolean` newValue) |  | 
| `void` | SetParameterized(`Boolean` parameterized) |  | 
| `void` | SetQuery(`Query` newQuery) |  | 
| `void` | SetReadOnly(`Boolean` newValue) |  | 
| `void` | ShiftLevel(`Boolean` up) |  | 
| `void` | WriteContent(`XmlWriter` writer) |  | 


### Static Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `Dictionary&lt;String, IConditionCreator&gt;` | ConditionCreators |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeName |  | 
| `String` | XmlTagName |  | 


### Static Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Condition` | Create(`String` type, `DataModel` model) |  | 
| `String` | LinkTypeToStr(`LinkType` lt) |  | 
| `Boolean` | RegisterType(`String` condType, `IConditionCreator` creator) |  | 
| `LinkType` | StrToLinkType(`String` s) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="afcbaae7-23c8-47af-89e3-8417361bf5ed" title="EqResultSetError class">
    <Content>```csharp
public class Korzh.EasyQuery.Services.EqResultSetError
    : Exception, ISerializable

```

</Content>
    <Tags />
  </Article>
  <Article id="b0240b6b-a7fd-412f-a4e9-26a1964099ef" title="Version 3.4.0 release notes">
    <Content>Version 3.4 of EasyQuery ASP.NET contains several changes in JavaScript widgets and EasyQuery controller.

Here are the essential ones:

## 1. CDN for JavaScript and CSS files

Now you can get the latest versions of EasyQuery's JavaScript and CSS files from our CDN: 

```js
  &lt;script src="http://cdn.korzh.com/eq/eq.all.min.js" type="text/javascript"&gt;&lt;/script&gt;
  &lt;script src="http://cdn.korzh.com/eq/eq.view.js" type="text/javascript"&gt;&lt;/script&gt;
 
  &lt;link href="http://cdn.korzh.com/eq/themes/default/easyquery.css" rel="stylesheet" type="text/css" /&gt;
  &lt;link href="http://cdn.korzh.com/eq/themes/default/eqview.css" rel="stylesheet" type="text/css" /&gt;
```

## 2.Default "look and feel" for query builder view page

The new version includes eqview.css and eq.view.js files which define the default style and behavior of query builder page. The same as you can on our [live demo](http://demo.easyquerybuilder.com/asp-net-mvc/) page. Both files can be accessed through CDN (you can see the links above). To apply the default behavior, you need to do the following:

1. Set the default IDs (QueryPanel, ColumnsPanel, etc.) for EasyQuery widget placeholders and other elements of your “advanced search” view page. See an example below.

2. Call EQ.view.init() function on page initialization.

Example: 

```js
 . . . . .
  &lt;script&gt; 
  $(document).ready(function () {
 
  EQ.client.init({
  . . . . .
  });
  EQ.view.init();
  });
  &lt;/script&gt; 
  . . . . .
&lt;body&gt;
  . . . . . .
  &lt;!-- Entities panel placeholder --&gt;
  &lt;div id="EntitiesPanel"&gt;&lt;/div&gt;
  . . . . .
  &lt;!-- Columns panel placeholder --&gt;
  &lt;div id="ColumnsPanel"&gt;&lt;/div&gt;
  . . . . . .
  &lt;!-- Query panel placeholder --&gt;
  &lt;div id="QueryPanel"&gt;&lt;/div&gt;
 
  . . . . . .
  &lt;!-- Buttons (names are self-explanatory) --&gt;
  &lt;div id="ClearQueryButton" class="eqv-button clear-button"&gt;Clear query&lt;/div&gt;
  &lt;div id="LoadQueryButton" class="eqv-button load-query-button"&gt;Load query&lt;/div&gt;
  &lt;div id="SaveQueryButton" class="eqv-button save-query-button"&gt;Save query&lt;/div&gt;
  &lt;div id="ExecuteQueryButton" class="eqv-button execute-button"&gt;Execute&lt;/div&gt; 
  . . . . . .
  &lt;!-- A placeholder for SQL statement text. --&gt;
  &lt;div id="SqlPanel" class="sql-block"&gt;&lt;/div&gt;
  . . . . . .
  &lt;!-- Result panel. Grid and charts will be rendered here --&gt;
  &lt;div id="ResultPanel" class="result-panel-content"&gt;
  &lt;/div&gt; 
 
&lt;/body&gt;
```

Of course, you don't need to define all placeholders listed above. Any element can be omitted. EQ.view script will render the elements it can find and simply ignore all others.

## 3. Google Visualization library support

EasyQueryController class now returns result sets in JSON format compatible with [DataTable](https://developers.google.com/chart/interactive/docs/reference#DataTable) class from [Google Visualization library](https://developers.google.com/chart/interactive/docs/reference). It allows you easily connect the result sets returned by EasyQuery with [Google Charts](https://developers.google.com/chart/interactive/docs/gallery). You can see an example of such integration in our [live demo](http://demo.easyquerybuilder.com/asp-net-mvc/). To see a pie chart just add one string column (e.g. “Customer Company Name”) and one numeric column (Order Freight) and click on “Execute” button.

Please note: You don't need to include Google Visualization scripts just to render a result grid. The eq.view.js script contains code which implements such rendering. However, it will be more convenient and secure to use “native” DataTable components. And of course, such inclusion will allow you to draw charts for result data. 

```js
&lt;script type="text/javascript" src="https://www.google.com/jsapi"&gt;&lt;/script&gt;
  . . . . . . . .
  &lt;script type="text/javascript"&gt;
  // Load the Visualization API and the piechart package.
  google.load('visualization', '1.0', { 'packages': ['corechart'] });
 
  // Set a callback to run when the Google Visualization API is loaded.
  google.setOnLoadCallback(GoogleVisualizationLoaded);
 
  function GoogleVisualizationLoaded() {
  //Visualization loaded!
  }
 
  . . . . . . . .
  &lt;/script&gt; 
```
Upgrading from previous versions

If your project uses version 3.3 (or less) of EasyQuery you need to make the following changes:

1. Include the latest versions of EasyQuery script files and CSS. Use our CDN as it mentioned in paragraph #1
2. Remove from your page's initialization part all JavaScript code which make AJAX calls for query building and execution and performs result grid rendering (if any). All these operations are implemented eq.view.js script now - so you need to replace all previous code by one call: EQ.view.init().
3. Change the IDs of placeholders for EasyQuery widgets and other page elements (Result panel, buttons, etc.) as it's described in paragraph #2 above.
4. (Optional) Add Google Visualization library to your page. Follow the instructions in paragraph #3 above.


</Content>
    <Tags>,asp-net,code-sample,javascript,widgets,controllers,google-visualization,</Tags>
  </Article>
  <Article id="b167fce9-0ae8-4621-9331-9c9ebcf8b3e3" title="EqRequestOptions class">
    <Content>```csharp
public class Korzh.EasyQuery.Services.EqRequestOptions

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Int32` | ResultFormat |  | 
| `Boolean` | ReturnStatement |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | LoadFromJsonDict(`JsonDict` dict) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="b1d7a275-c2cc-4ec5-be05-2728dc63bd38" title="SubQueryValueEditor class">
    <Content>```csharp
public class Korzh.EasyQuery.SubQueryValueEditor
    : ValueEditor

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | DefaultText |  | 
| `String` | DefaultValue |  | 
| `String` | IDBase |  | 
| `String` | QueryXml |  | 
| `String` | TypeName |  | 
| `String` | XmlDefinition |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | LoadContentFromXmlReader(`XmlReader` reader) |  | 
| `void` | SaveContentToJsonDict(`JsonDict` dict) |  | 
| `void` | SaveContentToXmlWriter(`XmlWriter` writer) |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeCaption |  | 
| `String` | STypeName |  | 


</Content>
    <Tags />
  </Article>
  <Article id="b22ad2b9-7d83-4896-a203-e92a07c56876" title="Building dynamic queries with EasyQuery and Entity Framework">
    <Content>&lt;h2&gt;1. Problem overview&lt;/h2&gt;
  &lt;p&gt;Object-relational mapping (ORM) solutions have become a standard for database-related software projects last years. Entities Framework (EF) is an obvious ORM choice in .NET world since it is distributed with .NET framework so all applications built with Entity Framework can run on any computer on which the .NET Framework (starting with version 3.5 SP1) is installed.&lt;/p&gt;
  &lt;p&gt;EasyQuery suits quite well for any project which use Entity Framework. There are some peculiar features in such “collaboration” which we are going to discuss further. So, to use EasyQuery components with Entity Framework you need to solve only two tasks:&lt;/p&gt;
  &lt;ul&gt;
  &lt;li&gt;Fill your EasyQuery data model by your Entity Framework model.&lt;/li&gt;
  &lt;li&gt;Generate query statement which can be executed over your EF model.&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;Let's look at each issue separately.&lt;/p&gt;
  &lt;h2&gt;2. Model loading&lt;/h2&gt;
  &lt;p&gt;There are two possible ways to load your EF model into DataModel (DbModel) object.&lt;/p&gt;
  &lt;h3&gt;2.1 Loading model from .edmx file&lt;/h3&gt;
  &lt;p&gt;If you still use Entity Data Model (EDM) stored in some .edmx file (so-called "database first" approach) - you can use LoadFromEdmx() method of DataModel class to fill it by EDM. &lt;/p&gt;
  &lt;p&gt;Here is an example:&lt;/p&gt;
  &lt;pre&gt;
&lt;code class="cs"&gt;DbModel myModel = new DbModel();
myModel.LoadFromEdmx(“MyEntityFrameworkModel.edmx”);
DbQuery query = new DbQuery();
query.Model = myModel;
&lt;/code&gt;
&lt;/pre&gt;
  &lt;h3&gt;2.2. Loading model directly from DbContext.&lt;/h3&gt;
  &lt;p&gt;With new “code first” style of Entity Framework you don’t have any .edmx files in your project. In such case you can load your model directly from DbContext class. Here is a code sample:&lt;/p&gt;
  &lt;pre&gt;
&lt;code class="cs"&gt;
using Korzh.EasyQuery.EF;
. . . . . . . .
DbModel myModel = new DbModel();
 
var dbContext = new NorthwindContext()
myModel.LoadFromDBContext(dbContext);
&lt;/code&gt;
&lt;/pre&gt;
  &lt;p&gt;So you just need to pass the type of your DbContext object as first parameter and some options in the second one (IncludeComplexTypesInParentEntity option used in the sample is quite self-descriptive).&lt;/p&gt;
  &lt;p&gt;We should note also that the second method of model loading can be used for the projects which use old EDM approach as well. You can use the DbContext class auto-generated for .edmx file.&lt;/p&gt;
  &lt;h2&gt;3. Generating SQL&lt;/h2&gt;
  &lt;p&gt;While EasyQuery allows you to generated Entity SQL or query via LINQ but the most efficient way will be to use good old T-SQL. Just create an instance of SqlQueryBuilder class, set default formats for generated statements (MsSqlServer in our case) and call BuildSQL method to get the result. &lt;/p&gt;
  &lt;p&gt;Code:&lt;/p&gt;
&lt;pre&gt;
DbQuery dbQuery = new DbQuery();
dbQuery.Model = myModel;
  . . . . . . . . . .
SqlQueryBuilder builder = new SqlQueryBuilder(dbQuery);
builder.Formats.SetDefaultFormats(FormatType.MsSqlServer);
string sql = builder.BuildSQL();
&lt;/pre&gt;

  &lt;p&gt;Finally here is an example how to execute generated SQL statement over your DbContext (this task is not related directly to EasyQuery functionality but it's worth mentioning in this article):&lt;/p&gt;

&lt;pre&gt;
  try {
  DataSet resultDataSet = new DataSet("myDataSet");
  DataTable resultTable = new DataTable("Result");
  resultDataSet.Tables.Add(resultTable);
  List&lt;string&gt; columnNames = new List&lt;string&gt;();
  using (NorthwindContext context = new NorthwindContext()) {
  var connection = context.Database.Connection;
  if (connection.State == ConnectionState.Closed)
  connection.Open();
  var command = connection.CreateCommand();
  command.CommandText = sql;
  command.CommandType = CommandType.Text;
  resultTable.Load(command.ExecuteReader());
  }
  //now you can use resultDataSet to show data in a GridView control 
  //or pass them into some report
  }
  catch (Exception e) {
  // Something wrong happened
  }
 
&lt;/pre&gt;
</Content>
    <Tags>,sql,entity-framework,data-model,database,dbcontext,code-sample,</Tags>
  </Article>
  <Article id="b519e88d-883b-4a88-b549-cc1b5b196b90" title="IPagedList`1 class">
    <Content>```csharp
public interface Korzh.EasyQuery.Services.IPagedList&lt;T&gt;
    : IEnumerable&lt;T&gt;, IEnumerable, IPaging

```

</Content>
    <Tags />
  </Article>
  <Article id="b603e2e9-a50f-44a7-902e-792acf96a5ca" title="RootEntity class">
    <Content>```csharp
public class Korzh.EasyQuery.RootEntity
    : Entity, IComparable&lt;Entity&gt;

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `DataModel` | Model |  | 


</Content>
    <Tags />
  </Article>
  <Article id="b62ede5e-34f8-4b7f-b057-b86fb4d3ab7c" title="AggrFuncExpr class">
    <Content>```csharp
public abstract class Korzh.EasyQuery.AggrFuncExpr
    : EqExpression

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | distinct |  | 
| `AggrFunction` | function |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `EqExpression` | Argument |  | 
| `String` | CustomFunc |  | 
| `DataType` | DataType |  | 
| `Boolean` | Distinct |  | 
| `AggrFunction` | Function |  | 
| `String` | Text |  | 
| `String` | Value |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | AssignExpr(`EqExpression` expr) |  | 
| `void` | AttachArgument(`EqExpression` argument) |  | 
| `void` | DetachArgument(`EqExpression` argument) |  | 
| `void` | LoadFromJsonDict(`JsonDict` dict) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | SaveToJsonDictCore(`JsonDict` dict) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer, `String` tagName) |  | 
| `void` | SetContentSilent(`String` val, `String` txt) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="b68001b5-21e1-48d7-82e9-64a4c3b77f8f" title="AggrFunction class">
    <Content>```csharp
public class Korzh.EasyQuery.AggrFunction

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | Caption |  | 
| `String` | DisplayFormat |  | 
| `Boolean` | Enabled |  | 
| `String` | ID |  | 
| `Boolean` | IsDefault |  | 
| `String` | MainText |  | 
| `Int32` | ParamCount |  | 
| `String` | SqlExpr |  | 


</Content>
    <Tags />
  </Article>
  <Article id="b6cc6da8-2b79-4907-b609-ad14085be113" title="ConditionList class">
    <Content>```csharp
public class Korzh.EasyQuery.ConditionList
    : Collection&lt;Condition&gt;, IList&lt;Condition&gt;, ICollection&lt;Condition&gt;, IEnumerable&lt;Condition&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;Condition&gt;, IReadOnlyCollection&lt;Condition&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Condition` | FindByAttr(`EntityAttr` attr) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="b70dd02f-83c8-4cec-b2da-e7b3a42c8943" title="IExpressionCreator class">
    <Content>```csharp
public interface Korzh.EasyQuery.IExpressionCreator

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `EqExpression` | Create(`DataModel` model) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="b8211e85-5b45-4fd1-87a2-b311cf656987" title="How to setup SQL LIST value editor in WinForms app">
    <Content>EasyQuery allows you to define SQL LIST value editor in WinForms apps for some attribute and then create your UI to edit condition values for this attribute. Here are the step-by-step instructions:

1. Run Data Model Editor (DME) and open your model file.
2. Go to Entities tab and find necessary attribute.
3. At the right panel for this attribute open “Value Editors” tab and select "SQL LIST" in “Default value editor” combo-box.
4. Save your model and close DME.
5. Open your project in Visual Studio and select QueryPanel component on form designer.
6. Add an event handler for ValueRequest event (use Events tab in Properties panel).

In WinForms edition, you will need to handle `ListRequest` event, execute the query passed in parameters and return the result in XML format.

Here is an example of such handler from our demo project (WinDemoCS):

```
Somewhere among form's initialization code:

this.QPanel.ListRequest += new Korzh.EasyQuery.WinControls.ListRequestEventHandler(this.QPanel_ListRequest);
```

Later in form's code:

```
private void QPanel_ListRequest(object sender, ListRequestEventArgs e) {
	if (e.ListName == "SQL") { 
                //processing SQL LIST value editors
		string sql = e.Data.ToString();
		DataSet tempDS = new DataSet();
        	SqlDataAdapter tempDA = new SqlDataAdapter(sql, sqlConnection);
		tempDA.Fill(tempDS, "Temp");
		
		StringWriter strWriter = new StringWriter();
		tempDS.WriteXml(strWriter);
		e.ResultXml = strWriter.ToString();
	}
	else if (e.ListName == "RegionList") { 
                //processing some other custom list
		e.ListItems.Clear();
		e.ListItems.Add("California", "CA");
		e.ListItems.Add("Colorado", "CO");
        	e.ListItems.Add("Oregon", "OR");
		e.ListItems.Add("Washington", "WA");

	}

}
```</Content>
    <Tags>,winforms,code-sample,sql,dme,entity-framework,attributes,</Tags>
  </Article>
  <Article id="b9daeeb2-5e9d-4b7b-b88e-b21d76dc05ff" title="EntityAttrProp class">
    <Content>```csharp
public enum Korzh.EasyQuery.EntityAttrProp
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | ID |  | 
| `1` | Caption |  | 
| `2` | Expression |  | 


</Content>
    <Tags />
  </Article>
  <Article id="baae03a3-4db6-420d-83ca-301e0baf0bc1" title="Query with subquery">
    <Content>&lt;div class="row"&gt;
  &lt;div class="col-md-12 c-content-media-1 krh-blogpost"&gt;
  
&lt;p&gt;Sometimes the query conditions are so complex that you can’t express them using plain WHERE clause with AND, OR and NOT. In this case, you need to use subqueries.&lt;/p&gt;

&lt;p&gt;For instance, let’s calculate &lt;b&gt;total lifetime count of paid orders for those countries that have at least one paid order made in September of 2012.&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Expected SQL:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sql"&gt;SELECT Cust.Country AS [Customer Country], COUNT(Ord.OrderID) AS [Order OrderID Count] 
FROM (Customers AS Cust
  RIGHT OUTER JOIN Orders AS Ord ON (Ord.CustomerID = Cust.CustomerID ))
WHERE
(
  Cust.Country IN
  (SELECT CustSQ1.Country 
  FROM (Customers AS CustSQ1
  RIGHT OUTER JOIN Orders AS OrdSQ1 ON (OrdSQ1.CustomerID = CustSQ1.CustomerID ))
  WHERE
  (
  OrdSQ1.OrderDate BETWEEN #2012-09-01# AND #2012-09-30# 
  AND OrdSQ1.Paid = true
  )
  ) 
  AND Ord.Paid = true
)
GROUP BY Cust.Country&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;Here “those countries that have at least one paid order made in September of 2012” condition is implemented as sub-query.&lt;/p&gt;

&lt;p&gt;First, add columns - click on “[Add column]” link, select “Customer | Country” menu item, then - [Add column] -&gt; “Order | OrderID”.&lt;br&gt;
Now aggregate the OrderID column - click the Function button on the right side of the column and select “Count” menu item.&lt;/p&gt;

&lt;p&gt;Add a condition with a subquery. Click “Add Condition”, select “Customer | Country” from the menu. Then change the operator - click on “is equal to” link and select “in subquery”. Then click “Edit subquery” link.&lt;/p&gt;

&lt;p&gt;The sub-query editing dialog appears.&lt;/p&gt;

&lt;p&gt;You need to select the single attribute of the same type as our “Customer | Country” attribute.&lt;/p&gt;

&lt;p&gt;The “Conditions” area have the same user interface as regular EasyQuery. Here you add the following conditions:
&lt;/p&gt;
&lt;p&gt;“Order | Date” -&gt; select “custom period” operator -&gt; set start and end date via date picker&lt;/p&gt;

&lt;p&gt;“Order | Paid” -&gt; select “is true”.&lt;/p&gt;

&lt;p&gt;Click “OK” button to submit the sub-query.&lt;/p&gt;

&lt;p&gt;At last, add “Order | Paid is true” condition to the main query.&lt;/p&gt;

&lt;div class="c-center"&gt;
&lt;div class="krh-blog-ss-block"&gt;
&lt;a href="~/static/easyquery/usecases/subquery.gif" class="fancybox" data-fancybox-group="gallery" title="EasyQuery example: using sub-query"&gt;
&lt;img src="~/static/easyquery/usecases/subquery.gif" alt="EasyQuery example: using sub-query"&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;

  &lt;/div&gt;
 &lt;/div&gt;
</Content>
    <Tags>,data-model,entity-framework,query-sample,subquery,code-sample,</Tags>
  </Article>
  <Article id="badea215-5b31-4dd3-84b9-c4a0f2cc2fd1" title="SortOrderChangedEventArgs class">
    <Content>```csharp
public class Korzh.EasyQuery.SortOrderChangedEventArgs
    : EventArgs

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Column` | Column |  | 
| `Int32` | Info |  | 
| `Boolean` | SyncColSortOrder |  | 
| `ChangeType` | What |  | 


### Events

| Type | Name | Description | 
| --- | --- | --- | 
| `SortOrderChangedEventHandler` | SortOrderChanged |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | InnerSortOrderChanged(`SortOrderChangedEventArgs` e) |  | 
| `void` | OnSortOrderChanged(`SortOrderChangedEventArgs` e) |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `SortOrderChangedEventArgs` | Default |  | 


</Content>
    <Tags />
  </Article>
  <Article id="bf8d2ec0-e93d-4eef-b275-cb59f22b6c93" title="EqVersionInfo class">
    <Content>```csharp
public static class Korzh.EasyQuery.EqVersionInfo

```

### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Int32` | MajorNum |  | 
| `Int32` | MinorNum |  | 
| `Int32` | UpdateNum |  | 
| `String` | Version |  | 


</Content>
    <Tags />
  </Article>
  <Article id="c0b5f9ea-255a-461d-8635-35000e3e83dc" title="ColumnStore class">
    <Content>```csharp
public class Korzh.EasyQuery.ColumnStore
    : ColumnList, IList&lt;Column&gt;, ICollection&lt;Column&gt;, IEnumerable&lt;Column&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;Column&gt;, IReadOnlyCollection&lt;Column&gt;

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `Query` | parentQuery |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | IsJustSorting |  | 
| `Boolean` | IsUpdating |  | 
| `DataModel` | Model |  | 
| `Query` | ParentQuery |  | 
| `SortedColumnList` | SortedColumns |  | 


### Events

| Type | Name | Description | 
| --- | --- | --- | 
| `ColumnsChangedEventHandler` | ColumnsChanged |  | 
| `ColumnsChangingEventHandler` | ColumnsChanging |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | BeginUpdate() |  | 
| `void` | ClearItems() |  | 
| `void` | CoreRefreshParams() |  | 
| `void` | EndUpdate() |  | 
| `void` | InsertItem(`Int32` index, `Column` item) |  | 
| `Boolean` | IsColumnsChangeAccepted(`ChangeType` what, `Column` column, `Int32` info) |  | 
| `void` | LoadFromJsonDict(`IEnumerable` colList) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | Move(`Int32` index, `Int32` newIndex) |  | 
| `void` | OnColumnsChanged(`ColumnsChangeEventArgs` e) |  | 
| `void` | OnColumnsChanging(`ColumnsChangingEventArgs` e) |  | 
| `void` | RefreshParams() |  | 
| `void` | RemoveItem(`Int32` index) |  | 
| `void` | ResyncSortingList(`Boolean` changeInnerIndex) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer, `String` tagName) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="c173264c-efd8-4177-b75a-26df84812fd3" title="Getting started for Silverlight">
    <Content>To apply EasyQuery.NET to your application please perform the following steps:

1. Run Data Model Editor application in wizard mode (“Create Data Model” program icon) and follow the instructions to create a new data model that describes the data in your database. You will define database tables you want to use in your future queries, links between them and entities with their attributes (mostly the fields in already added tables).

2. Save created data model to some file on your hard-drive (let it be model1.xml for example);

3. Drop QueryPanel components on a form. You need to add this component to a Visual Studio toolbox first if you have not done this before.

4. Create DbDataModel and DbQuery objects in your form's initialization procedure. Connect DbQuery to DbModel through its Model property and QueryPanel to DbQuery through Query property.

Example: 

```
 public MainWindow()   
 {   
    InitializeComponent();   
 
    //Create new query and data model objects, connect them with one another and with QueryPanel  
    Query query = new DbQuery();      
 
    query.Model = new DbDataModel();   
    queryPanel.Query = query;  
 
    //Configure query's format according to the database you use.  
    queryPanel.Query.Formats.SqlQuote1 = '[';  
    queryPanel.Query.Formats.SqlQuote2 = ']';  
    queryPanel.Query.Formats.DateFormat = "#MM/dd/yyyy#";  
    //... etc.  
 
    //Load the data model you created on steps 1-2  
    query.Model.LoadFromFile("model1.xml");   
 }   
```
5. You can also drop on your form QueryColumnsPanel control to allow your users to define the result columns. Link QueryColumnsPanel with DbQuery object exactly like for the QueryPanel control.
After the steps described above your users can add query conditions and result columns;

6. When it's necessary to generate an SQL statement - create an instance of SqlQueryBuilder class and call its BuildSQL() method. Usually, this method is called on some user action (e.g. pressing “Build” button). After that read generated SQL from Result.SQL property of SqlQueryBuilder object.

7. Finally, you can pass the generated SQL statement to some DataSource for execution or use it in any other possible way.

Example: 

```
protected void BuildBtn_Click(object sender, EventArgs e) { 
    SqlQueryBuilder builder = new SqlQueryBuilder(query1);
    if (builder.CanBuild) {
        builder.BuildSQL();
        string sql = builder.Result.SQL;
 
        try {
            DataSet ResultDS = new DataSet(); 
 
            OleDbDataAdapter resultDA = new OleDbDataAdapter(queryPanel.Query.Result.SQL, SomeDbConnection); 
            resultDA.Fill(ResultDS, "Result"); 
            dataGrid.ItemsSource = ResultDS.Tables[0].DefaultView; 
        }  
        catch (Exception error) { 
            //if some error occurs just show the error message  
            MessageBox.Show(error.Message);       
        } 
    }
} 
```</Content>
    <Tags>,silverlight,data-model,query-panel,get-start,dme,code-sample,</Tags>
  </Article>
  <Article id="c1d76af1-b620-4c67-a81b-07f2ca6f1671" title="Setup custom value editor — WinForms">
    <Content>EasyQuery allows you to define custom value editor for some attribute and then create your UI to edit condition values for this attribute. Here are the step-by-step instructions:

1. Run Data Model Editor (DME) and open your model file.
2. Go to Entities tab and find necessary attribute.
3. At the right panel for this attribute open “Value Editors” tab and select “Custom (user defined)” in “Default value editor” combo-box.
4. Save your model and close DME.
5. Open your project in Visual Studio and select QueryPanel component on form designer.
6. Add an event handler for ValueRequest event (use Events tab in Properties panel).

Here is an example of ValueRequest event handler: 

```js
private void QPanel_ValueRequest(object sender, ValueRequestEventArgs e) {
  //checking if this condition row is associated with some SimpleCondition object
  if (((QueryPanel)sender).ActiveRow is QueryPanel.SimpleConditionRow) {
  SimpleCondition cond = (SimpleCondition)e.Condition;
 
  //if we need our entity attribute - we can get it from BaseAttr property of SimpleCondition object
  EntityAttr attr = cond.BaseAttr;
 
  //bring your own dialog to edit condition value
  //you can use event parameter properties Value and Text to get current value
  . . . . . . . .
  //after the dialog is closed - return new value and (if necessary) text via event's parameter
  e.Value = "&lt;new value&gt;";
  e.Text = "&lt;new text&gt;"; //you can omit this
  }
}
```</Content>
    <Tags>,winforms,code-sample,dme,entity-framework,data-model,</Tags>
  </Article>
  <Article id="c41af8f6-5b17-4ba6-aa0f-d9fd0184aa3c" title="CustomValueEditor class">
    <Content>```csharp
public class Korzh.EasyQuery.CustomValueEditor
    : ValueEditor

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | Data |  | 
| `String` | DefaultText |  | 
| `String` | DefaultValue |  | 
| `String` | TypeName |  | 
| `String` | XmlDefinition |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | LoadAttribute(`String` attrName, `String` attrValue) |  | 
| `void` | LoadContentFromXmlReader(`XmlReader` reader) |  | 
| `void` | SaveContentToJsonDict(`JsonDict` dict) |  | 
| `void` | SaveContentToXmlWriter(`XmlWriter` writer) |  | 
| `void` | SetTypeName(`String` typeName) |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeCaption |  | 
| `String` | STypeName |  | 


</Content>
    <Tags />
  </Article>
  <Article id="c592eff0-f357-47b5-b540-94c14b75e6d3" title="DataModel class">
    <Content>```csharp
public class Korzh.EasyQuery.DataModel

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `AggrFunctionList` | AggrFunctions |  | 
| `String` | customInfo |  | 
| `String` | defQueryFilePath |  | 
| `String` | description |  | 
| `Dictionary&lt;String, String&gt;` | DMEOptions |  | 
| `Entity` | entityRoot |  | 
| `String` | filePath |  | 
| `Int32` | formatVersion |  | 
| `MacroList` | Macros |  | 
| `Int32` | maxEntAttrID |  | 
| `String` | modelName |  | 
| `Int32` | modelVersion |  | 
| `Boolean` | useResourcesForOperators |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | CustomInfo |  | 
| `ValueEditor` | DefaultPreciseDateEditor |  | 
| `ValueEditor` | DefaultPreciseTimeEditor |  | 
| `ValueEditor` | DefaultTextEditor |  | 
| `String` | DefQueryFilePath |  | 
| `String` | Description |  | 
| `ValueEditorsList` | Editors |  | 
| `EntityGraph` | EntityGraph |  | 
| `Entity` | EntityRoot |  | 
| `String` | FilePath |  | 
| `Int32` | FormatVersion |  | 
| `String` | ID |  | 
| `Boolean` | IsEmpty |  | 
| `String` | ModelName |  | 
| `Int32` | ModelVersion |  | 
| `EntityAttr` | NullAttribute |  | 
| `Operator` | NullOperator |  | 
| `OperatorList` | Operators |  | 
| `IProgressIndicator` | ProgressIndicator |  | 
| `TextStorage` | Texts |  | 
| `Boolean` | UseResourcesForOperators |  | 


### Events

| Type | Name | Description | 
| --- | --- | --- | 
| `AggrFuncListChangedEventHandler` | AggrFuncListChanged |  | 
| `MacroRequestEventHandler` | MacroRequest |  | 
| `EventHandler` | ModelChanged |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | AddDefaultEditors() |  | 
| `void` | AddDefaultOperators() |  | 
| `void` | AddOperatorToEntity(`Operator` op, `Entity` ent) |  | 
| `void` | AddOperatorToSuitedAttributes(`Operator` op) |  | 
| `Operator` | AddUpdateOperator(`String` id, `String` caption, `String` expr, `String` format, `DataKind` kind = Scalar, `OperatorGroup` group = null) |  | 
| `void` | AssignEntityAttrID(`EntityAttr` attr) |  | 
| `void` | Clear() |  | 
| `Entity` | CreateEntity() |  | 
| `EntityAttr` | CreateEntityAttr() |  | 
| `EntityAttr` | CreateGhostAttribute(`String` id) |  | 
| `EntityAttr` | CreateNullAttribute() |  | 
| `Operator` | CreateNullOperator() |  | 
| `Operator` | CreateOperator() |  | 
| `Operator` | CreateOperator(`String` id, `String` caption, `String` expr, `String` format) |  | 
| `Entity` | CreateRootEntity() |  | 
| `void` | DeleteOperator(`Operator` op) |  | 
| `void` | DeleteOperatorFromEntity(`Entity` ent, `Operator` op) |  | 
| `void` | EnsureEditorExistance(`ValueEditor` editor) |  | 
| `Entity` | FindEntity(`String` entityName) |  | 
| `EntityAttr` | FindEntityAttr(`String` attrDef) |  | 
| `EntityAttr` | GetAttributeByID(`String` attrID, `Boolean` useNullAttr) |  | 
| `OperatorList` | GetDefaultOperatorsForDataType(`DataType` dataType) |  | 
| `EntityAttr` | GetDefaultUICAttribute() |  | 
| `EntityAttr` | GetDefaultUIRAttribute() |  | 
| `EntityAttr` | GetDefaultUIRAttribute(`Boolean` needUseInSorting) |  | 
| `IMacroValue` | GetMacroValue(`String` macroId) |  | 
| `Int32` | GetNextEntityAttrID() |  | 
| `void` | IncreaseModelVersion() |  | 
| `void` | InitModelLoading() |  | 
| `void` | ListDefaultOperatorsForDataType(`OperatorList` operats, `DataType` dataType) |  | 
| `void` | LoadFromFile(`String` path) |  | 
| `void` | LoadFromFile(`String` path, `RWOptions` rwOptions) |  | 
| `void` | LoadFromStream(`Stream` stream) |  | 
| `void` | LoadFromStream(`Stream` stream, `RWOptions` rwOptions) |  | 
| `void` | LoadFromString(`String` xml, `RWOptions` rwOptions) |  | 
| `void` | LoadFromString(`String` xml) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader, `RWOptions` rwOptions) |  | 
| `void` | LoadNode(`XmlReader` reader, `RWOptions` rwOptions) |  | 
| `String` | LoadValueEditorNode(`ValueEditor` editor, `XmlReader` reader) |  | 
| `void` | OnAggrFuncListChanged() |  | 
| `void` | OnMacroRequest(`MacroRequestEventArgs` e) |  | 
| `void` | OnModelChanged() |  | 
| `void` | OnModelLoaded() |  | 
| `void` | RefillAggrFunctionList() |  | 
| `void` | RefreshResources() |  | 
| `void` | SaveAttributes(`XmlWriter` writer, `RWOptions` options) |  | 
| `void` | SaveCustomInfoNode(`XmlWriter` writer) |  | 
| `void` | SaveNodes(`XmlWriter` writer, `RWOptions` options) |  | 
| `void` | SaveToFile(`String` path) |  | 
| `void` | SaveToFile(`String` path, `RWOptions` options) |  | 
| `JsonDict` | SaveToJsonDict() |  | 
| `void` | SaveToStream(`Stream` stream) |  | 
| `void` | SaveToStream(`Stream` stream, `RWOptions` options) |  | 
| `String` | SaveToString() |  | 
| `String` | SaveToString(`RWOptions` options) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer, `RWOptions` options) |  | 
| `void` | SetProgress(`Int32` pos) |  | 
| `void` | SetProgressMinMax(`Int32` min, `Int32` max) |  | 
| `void` | SortEntities() |  | 
| `void` | SortEntityContent(`Entity` entity) |  | 
| `void` | UpdateOperatorsTexts() |  | 
| `void` | UpdateOperatorTexts(`Operator` op) |  | 


### Static Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `OperatorGroup` | AnyOperatorGroup |  | 
| `OperatorGroup` | BoolOperatorGroup |  | 
| `OperatorGroup` | CommonOperatorGroup |  | 
| `Int32` | LastFormatVersion |  | 
| `OperatorGroupList` | OperatorGroups |  | 
| `OperatorGroup` | OtherOperatorGroup |  | 
| `OperatorGroup` | StringOperatorGroup |  | 
| `OperatorGroup` | TimeOperatorGroup |  | 


</Content>
    <Tags />
  </Article>
  <Article id="c7169a9b-36a5-45a3-9077-3aa611a6d0bd" title="DataTypeList class">
    <Content>```csharp
public class Korzh.EasyQuery.DataTypeList
    : Collection&lt;DataType&gt;, IList&lt;DataType&gt;, ICollection&lt;DataType&gt;, IEnumerable&lt;DataType&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;DataType&gt;, IReadOnlyCollection&lt;DataType&gt;

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | CommaText |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | AddRange(`IEnumerable&lt;DataType&gt;` types) |  | 
| `void` | InsertItem(`Int32` index, `DataType` item) |  | 
| `void` | InsertRange(`Int32` index, `IEnumerable&lt;DataType&gt;` types) |  | 


### Static Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `DataTypeList` | BoolDataTypes |  | 
| `DataTypeList` | CommonDataTypes |  | 
| `DataTypeList` | IntegerDataTypes |  | 
| `DataTypeList` | RangeDataTypes |  | 
| `DataTypeList` | StringDataTypes |  | 
| `DataTypeList` | TimeDataTypes |  | 


</Content>
    <Tags />
  </Article>
  <Article id="c86aed5b-7e45-4940-9979-387bbcd24fb3" title="Simple query over one table">
    <Content>Let’s suppose we need just a list of customers from one particular country (e.g. USA). Regarding SQL this query will look like:

```sql
SELECT * 
FROM Customers
WHERE Country = 'USA'
```

With EasyQuery this simple query becomes even simpler. Just click “Add new condition” link, select Customer | Country in a menu. Then click on the third element in new condition ([Select value]) and choose the USA from the drop-down list that appears. Check SQL statement that appeared in the bottom-left panel and click on “Execute” button to see the result of your query.

Here is EasyQuery example of simple SQL query over one table:

![Simple query over one table](/files/test/easyquery-dotnet/images/query-example-01.png)</Content>
    <Tags>,query-example,sql,tables,code-sample,</Tags>
  </Article>
  <Article id="c8f936b7-a89a-41db-bf41-c86b666663ac" title="ObjectGraph`1 class">
    <Content>```csharp
public class Korzh.EasyQuery.ObjectGraph&lt;T&gt;

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Dictionary&lt;T, T&gt;` | Parent |  | 
| `T` | Root |  | 
| `IEnumerable&lt;T&gt;` | Vertices |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | AddEdge(`T` vertexFrom, `T` vertexTo) |  | 
| `void` | AddVertex(`T` vertex) |  | 
| `IDictionary&lt;T, T&gt;` | BreadthFirstSearch(`T` vertex) |  | 
| `void` | Clear() |  | 
| `Boolean` | ContainsVertex(`T` vertex) |  | 
| `T` | LCA(`T` vertex1, `T` vertex2, `IEnumerable&lt;T&gt;` usedVertices) |  | 
| `void` | RemoveVertex(`T` vertex) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="c9038a06-14cb-4efa-8e8c-f8c611ea9df5" title="Introduction to value editors">
    <Content>Each condition in query consists of 3 parts: attribute (field), operator and values (one or more). By default when a user clicks on ”[enter value]” link in a condition he/she is presented with an edit box actually to type the value. EasyQuery allows you to assign a value editor for each attribute or operator in your model - so your users will be able to use other methods of entering values instead of just typing in a text box. For example, value editor allows you to define a list of available values - so your users will be able to select the value from a drop-down list. 

## **Value editor types**

* **Auto** (or no value editor defined) - EasyQuery will automatically use the most appropriate editor for that attribute.
* Text editor - simple text box where a user can type needed value. It's possible to define the kind of entered values for pre-validation
* Date/time editor - textbox combined with a date/time picker dialog
* List of constants - you can define the list of available items, and a user will be able to select from that list when build query. Each item has 'id' and 'text' properties. The values of 'text' property will be shown to users in a drop-down list. The value of 'id' for selected item will be placed into generated SQL.
* Custom list - works the similar way as previous but the list of elements is defined at run-time in ListRequest event handler according to list name (can be specified in data model via Data Model Editor).
* SQL List - works the same way as “Custom list”. This value editor has special name “SQL” and can hold some SQL expression in additional property. ListRequest event handler is responsible for executing that SQL statement and returning the result list back to visual control (widget).
* Custom - raises CustomValue event. You can handle this event, show some special dialog and return a pair “value-text” according to data entered by a user in that dialog. This value editor is not processed in MVC edition of EasyQuery.

## **How to define value editor**

You can define value editor for some attribute in your model using one of the following methods

### 1. Via Data Model Editor (at design time)

  * Run Data Model Editor (DME)
  * Open your model XML file
  * Go to “Entities” tab and select the entity attribute for which you what to define an editor.
  * On the right panel for selected attribute open “Value Editors” tab
  * Select the type of editor from drop-down list
  * Press “Settings…” button to define additional parameters for selected editor.
  * Save your model and close DME

### 2. Using EasyQuery API (at run-time)

Here is an example how you can specify CustomList value editor for some attribute in your model: 
```
//find entity attribute
EntityAttr attr = model.EntityRoot.FindAttribute(EntityAttrProp.Expression, "Customers.Country");
 
//create editor object
var editor = new CustomListValueEditor();
editor.ListName = "MyCustomList";
 
//assign new editor to attribute
attr.DefaultEditor = editor;
```
## **Processing ListRequest event in MVC**

"Custom list" and “SQL list” value editor raises ListRequest event to get the list of available values. In a case of MVC application, this event can be processed both on client and server side. To handle it on the client side you need to assign a function to `listRequestHandler` property in `easyQuerySettings` object: 

```
window.easyQuerySettings = {
  serviceUrl: "/EasyQuery",
  loadDefaultModel: true,
  . . . . . . . 
  listRequesHandler: function (params, onResult) {
  var processed = true;
  if (params.listName == "RegionList") {
  var query = EQ.client.getQuery();
  var country = query.getOneValueForAttr(query, "Customer.Country");
  if (country == "Canada") {
  onResult([
  { id: "BC", text: "British Columbia" },
  { id: "Quebec", text: "Quebec" }
  ]);
 
  }
  else {
  onResult([
  { id: "CA", text: "California" },
  { id: "CO", text: "Colorado" },
  { id: "OR", text: "Oregon" },
  { id: "WA", text: "Washington" }
  ]);
  }
  }
  else
  processed = false;
 
  return processed;
  }
 
};
```

The code above is quite straightforward and self-explanatory. The only note we should make is about the returned value. If it's `true` the list request is considered as “processed”, and no further actions are performed. Otherwise - EasyQuery.JS will initiate `GetList` AJAX request to the server passing list name and other value editor properties (if necessary) as request parameters. To process this request the default template of EasyQueryController has `GetList` action method. This action handler just calls corresponding `GetList` method of an EqServiceProviderDb object and returns the result back to the client: 

```
[HttpPost]
public ActionResult GetList(ListRequestOptions options) {
  return Json(eqService.GetList(options));
}
```
## **Processing ListRequest event in other editions of EasyQuery**

All other editions of EasyQuery (WinForms, WebForms, WPF or Silverlight) has `ListRequest` event in `QueryPanel` control which is raised when a user adds an attribute (or operator) with `Custom List` or `SQL list` value editor assigned to that attribute/operator. You need to handle that event and return the list of available values via event's parameters (according to a list name and/or SQL statement). Here is an example of such event handler: 

```
private void QPanel_ListRequest(object sender, ListRequestEventArgs e) {
  if (e.ListName == "SQL") {
  CheckConnection();
  string sql = e.Data.ToString();
  OleDbDataAdapter resultDA = new OleDbDataAdapter(sql, DbConnection);
 
  DataSet tempDS = new DataSet();
  try {
  resultDA.Fill(tempDS, "Result");
 
  StringWriter strWriter = new StringWriter();
  tempDS.WriteXml(strWriter);
  e.ListItems.LoadFromXml(strWriter.ToString());
 
  }
  catch {
  e.ListItems.Clear();
  } 
  }
  else if (e.ListName == "RegionList") {
  e.ListItems.Clear();
  countryAttr = model.EntityRoot.FindAttribute(EntityAttrProp.Expression, "Customers.Country");
  string country = query.GetOneValueForAttr(countryAttr);
 
  if (country == "Canada") { 
  e.ListItems.Add("British Columbia", "BC");
  e.ListItems.Add("Quebec", "Quebec");
 
 
  }
  else if (country == "USA") {
  e.ListItems.Add("California", "CA");
  e.ListItems.Add("Colorado", "CO");
  e.ListItems.Add("Oregon", "OR");
  e.ListItems.Add("Washington", "WA");
  }
  else {
  e.ListItems.Add("California", "CA");
  e.ListItems.Add("Colorado", "CO");
  e.ListItems.Add("Oregon", "OR");
  e.ListItems.Add("Washington", "WA");
  }
 
  }
  else if (e.ListName == "YesNoList") {
  e.ListItems.Add("Yes", "1");
  e.ListItems.Add("No", "2");
  }
}
```

The example above is defined for WinForms edition but it will look very similar for other editions as well. First section of this handler processes the requests for “SQL List” value editors. We just execute SQL statement passed in event's parameter and return the result set (in a special format). All other `else if` sections return lists for particular lists according to the list names.

Please take a look at first `else if` section which populates items for “RegionList”. Here we show how you can filter the returned list according to the value specified for some other attribute. In this example we search our query for a condition like “Customer country is equal to {Some Country}”. If such condition is defined - we get the value (country code) from it and use that value as a filter for the list of regions. 

For more information about this approach please read: [Dynamically populating lists by information from other conditions (WinForms)](http://docs.korzh.com/easyquery/how-to/dynamically-populating-list-winforms)</Content>
    <Tags>,data-model,dme,code-sample,</Tags>
  </Article>
  <Article id="c9968a78-61a3-4b09-b88f-1ab221f15002" title="EntAttrKind class">
    <Content>```csharp
public enum Korzh.EasyQuery.EntAttrKind
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | Data |  | 
| `1` | Virtual |  | 


</Content>
    <Tags />
  </Article>
  <Article id="c9e968b7-16e1-4adb-8a39-5101e874eb34" title="Navigate through query conditions">
    <Content>Sometimes you need to run through all conditions in your query to perform some operation for each condition or to find a particular one. Here is a code snippet which demonstrates this operation: 

```c#
private void RunThroughConditions(Predicate predicate) {
  foreach (Condition cond in predicate.Conditions) {

    if (cond is SimpleCondition) {
  
      SimpleCondition scond = (SimpleCondition)cond;
    
      if (scond.BaseExpr is EntityAttrExpr) {
        EntityAttrExpr attrExpr = (EntityAttrExpr)scond.BaseExpr;
      
        //here is the attribute of this condition
        EntityAttr attr = attrExpr.Attribute;
      
        //here is condition operator
        Operator op = scond.Operator;
      
        //now we run through all expressions in this condition (except the first one) and check their values
        for (int i = 1; i &lt; scond.Expressions.Count; i++) {
            var expr = scond.Expressions[i];
            string value = expr.Value;
            string text = expr.Text;
        }
      }
    }

    else if (cond is Predicate) {
      RunThroughConditions((Predicate)cond);
    }
  }
}

```
 
//to start the process just call this function for the Root predicate in your Query
RunThroughConditions(query1.Root);
```</Content>
    <Tags>,api,query,conditions,code-sample,data-model,</Tags>
  </Article>
  <Article id="ca10c7b0-cec5-47eb-8cbd-057f7664a2a3" title="How to make field to field comparison">
    <Content>## Problem
Currently, EasyQuery allows you to build only one type of conditions by default: {SomeField} {Operator} {Constant value}. 
For example: `Customers.Birthday &lt; '2000-01-01'`
However, sometimes you need to compare a field against another field in the same or another table of your DB. 
E.g. `License.ExpirationDate &gt; Order.OrderDate`


## Solution
Each data model contains a lot of default operators (like "equals", "greater than", "less than", etc). But all of them allows you to compare some field against a constant value. However, it's quite easy to add a new operator which accept another entity attribute (field) in the right part of the condition.

Here are the instructions how to do it:

### 1) Open your model file

Run Data Model Editor utility (DME) and open your model (.xml) file (Model | Open… menu item).

### 2) Add new operator

Go to Operators tab and select “Operators | Add Operator” menu item. New operator with default ID “NewOp” will appear at the bottom of the list of operators.

![Data Model Editor - add new operator](/files/test/easyquery-dotnet/images/dm-new-operator-01.png)

After that, we need to define all properties for a new operator.

### 3) Setting operator's properties

#### ID: "GreaterThanAttr"

This is mostly an internal property. EasyQuery will use to reference this operator in attributes and query conditions.

#### Caption: "Greater than another attribute"

This value will be shown to users in a drop-down list when they select operator

#### Display format: 
```
{expr1} [[is greater than]] {expr2}
```

This field defines how your operator (actually the whole condition with this operator) will look in a condition row in query panel. The part within [[ and ]] will be clickable.

#### Expression: 
```
{expr1} &gt; {expr2}
```

The most important property for an operator. It defines the result expression which will come into generated SQL statement. {expr1} and {expr2} parts specify the operands. The first operand is always an attribute, second - some value entered by a user. In our case, it will be another entity attribute as well.

#### Applied types: 

Since this operator can be used with any types of data - we can check all options in “Applied types” field.

Here is how Operators tab in DME looks like after all changes described above:

![Data Model Editor - operator properties](/files/test/easyquery-dotnet/images/dm-field-to-field-operator-02.png)

### 4) Setting operand's properties

Each operator has one or more operands. We have "default operand" item there. The options set for this item will be applied to all operands.  
The parameter we need to change here is Kind. By default, it's set to "Scalar" but we need to change it to "Attribute".

![Data Model Editor - operand properties](/files/test/easyquery-dotnet/images/dm-field-to-field-operator-03.png)

### 5) Associate new operator with attribute(s)

Finally, we need to associate new operator with one or more attributes for which it may be used in query conditions. To do it:

* open “Entities” tab
* select necessary attribute
* open its “Operators” tab
* click on “Add” button, check new operator and click OK.

![Data Model Editor - associate operator with attributes](/files/test/easyquery-dotnet/images/dm-field-to-field-operator-04.png)

### 6) Done!

Finally, save your model and run the project which uses this model to test new operator:

![Data Model Editor - new operator in the query panel](/files/test/easyquery-dotnet/images/dm-field-to-field-operator-05.png)</Content>
    <Tags>,data-model,operator,field-to-field,dme,code-sample,operators,conditions,</Tags>
  </Article>
  <Article id="cafe9c67-2a86-48d4-8836-2257d319cd94" title="OperandList class">
    <Content>```csharp
public class Korzh.EasyQuery.OperandList
    : Collection&lt;Operand&gt;, IList&lt;Operand&gt;, ICollection&lt;Operand&gt;, IEnumerable&lt;Operand&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;Operand&gt;, IReadOnlyCollection&lt;Operand&gt;

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `DataModel` | Model |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | InsertItem(`Int32` index, `Operand` item) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="cb457809-93f6-4739-9152-43ffabdb998c" title="Gridview filtering with EasyQuery ASP.NET (WebForms)">
    <Content>&lt;p&gt;A very common use-case for ASP.NET WebForms application: you have a webpage with a GridView control populated from a database.&lt;/p&gt;
  &lt;p&gt;Now let’s imagine you want to have a form or some web-control that users can use to filter the results presented in the GridView. Moreover, it would be great to give them a possibility to define several filter conditions and a quick way to turn each condition on/off and see what happens with result dataset instantly.&lt;/p&gt;
  &lt;p&gt;This is the point where EasyQuery’s QueryPanel web-control comes to help. Take a look at the following GridView filtering form example:&lt;/p&gt;
  &lt;div class="c-center"&gt;
  &lt;div class="krh-blog-ss-block"&gt;
  &lt;a href="~/static/easyquery/usecases/eq-grid-filtering01.png" class="fancybox" data-fancybox-group="gallery" title="GridView filtering form"&gt;
  &lt;img src="~/static/easyquery/usecases/eq-grid-filtering01.png" alt="GridView filtering form"&gt;
  &lt;/a&gt;
  &lt;/div&gt;
  &lt;/div&gt;
  &lt;p&gt;Here is a step-by-step description how to implement this functionality in your own project:&lt;/p&gt;
  &lt;h2&gt;0. Download and install EasyQuery&lt;/h2&gt;
  &lt;p&gt;(of course, only if you didn't do it before)&lt;/p&gt;
  &lt;h2&gt;1. Add QueryPanel control to your .aspx file&lt;/h2&gt;
  &lt;p&gt;We suppose that you have a GridView component connected with some DataSource control. All you need to add - is a QueryPanel control (preferably before the GridView):&lt;/p&gt;
  &lt;pre&gt;
&lt;code class="html"&gt;&amp;lt;keqwc:querypanel id="QueryPanel1" runat="server" scrollbars="Auto"&amp;gt;
&amp;lt;/keqwc:querypanel&amp;gt;
 
 . . . . . . . 
 
&amp;lt;asp:gridview id="ResultGrid" runat="server" datasourceid="ResultDS" cellpadding="4" cellspacing="2" gridlines="Vertical"&amp;gt;
&amp;lt;/asp:gridview&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
  &lt;h2&gt;2. Add EasyQuery initialization code&lt;/h2&gt;
  &lt;p&gt;We need to create DbQuery and DbModel component and assign Query object to QueryPanel control.
  &lt;/p&gt;
  &lt;pre&gt;
&lt;code class="cs"&gt;private DbQuery query = null;
private DataView resultView;
  
//Here is a function which loads data from the database.
//For demonstration purposes, we show a content of one table here
//but it may be a more complicated query of course.
protected void RefreshResultView(string tableName, string filterExpr) {
  ResultDS.SelectCommand = "Select * From " + tableName;
  ResultDS.FilterExpression = filterExpr;
  resultView = (DataView)ResultDS.Select(DataSourceSelectArguments.Empty);
}
 
//This function fills DbModel object by information from DataTable
protected void LoadModelData(DbModel model, string tableName) {
  RefreshResultView(tableName, "");
  DataTable tbl = resultView.ToTable();
  model.FillByDataTable(tbl, false);
}
  
private void InitQuery() {
  //we store our query in the Session storage
  query = (DbQuery)Session["EQ-GRIDFILTER-DEMO-QUERY"];
 
  //if there is no current query - we create a new one
  if (query == null) {
  DbModel model = new DbModel();
  model.UseResourcesForOperators = true;
  model.AddDefaultOperators();
 
  LoadModelData(model, "Customers");
 
  query = new DbQuery();
  query.Model = model;
  query.Formats.SetDefaultFormats(FormatType.MsAccess);
  Session["EQ-GRIDFILTER-DEMO-QUERY"] = query;
  }
}
 
//Now modify our Page_Load handler to do all initialization procedures
protected void Page_Load(object sender, EventArgs e) {
  //initialize Query and DataModel objects first 
  InitQuery();
  
  //assign Query object to QueryPanel
  QueryPanel1.Query = query;
 
  //add a handler for ConditionsChanged event - to modify our filter according to user's changes in QueryPanel
  query.ConditionsChanged += new Korzh.EasyQuery.ConditionsChangedEventHandler(query_ConditionsChanged);
 
  . . . . . . . . 
}
&lt;/code&gt;
&lt;/pre&gt;
  &lt;h2&gt;3. Update filter on every query change&lt;/h2&gt;
  &lt;p&gt;Finally we need to build new filter expression on every user's modification in QueryPanel control and update our result accordingly&lt;/p&gt;
  &lt;pre&gt;
&lt;code class="cs"&gt;//ConditionsChange event handler. All we do here - call a function which updates our result set
protected void query_ConditionsChanged(object sender, Korzh.EasyQuery.ConditionsChangeEventArgs e) {
  UpdateResultset();
}
 
 
protected void UpdateResultset() {
  FilterExpressionBuilder builder = new FilterExpressionBuilder(query);
  builder.BuildFilter();
  string filterExpr = builder.Result.FilterExpr;
  RefreshResultView("Customers", filterExpr);
}
&lt;/code&gt;
&lt;/pre&gt;
  &lt;h2&gt;Additional benefits&lt;/h2&gt;
  &lt;p&gt;You can wrap these components into a new UserConrol and use the same approach for filtering in other web pages (.aspx), of your web-application, so that the look and feel, layout and behavior remains unified across the whole web-site.&lt;/p&gt;
</Content>
    <Tags>,asp-net,webforms,code-sample,filters,query-panel,tables,data-model,</Tags>
  </Article>
  <Article id="cd87f819-fa03-429e-ac13-d2068dabf78c" title="IProgressIndicator class">
    <Content>```csharp
public interface Korzh.EasyQuery.IProgressIndicator

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | SetMinMax(`Int32` min, `Int32` max) |  | 
| `void` | SetPosition(`Int32` pos) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="ce952fc1-3a37-4b71-9898-9220485b2b5d" title="Building data model dynamically by code">
    <Content>To accomplish the described task, we need to perform several steps in consecutive order. First, we should add the tables our model will be based on and links between those tables. Then we add entities and attributes and connect our attributes to the tables we added before.

In result of the execution of the code below, we will get a data model which consists of two tables (Customers and Orders), two entities which correspond to these tables and few attributes for each entity.

Below we suppose that we already have correctly initialized `DbModel` and `DbQuery` objects (referenced as “model” and “query” correspondingly).

```
  //clear current model
  model.Clear();
 
  //add default operators
  model.AddDefaultOperators();
 
  //add two tables
  DbTable table1 = new DbTable();
  table1.Name = "Customers";
  table1.Alias = "Cust";
 
  DbTable table2 = new DbTable();
  table2.Name = "Orders";
  table2.Alias = "Ord";
  model.Tables.Add(table1);
  model.Tables.Add(table2);
 
  //then we add a link between our tables
  TableLink link1 = new TableLink();
  link1.Table1 = table1;
  link1.Table2 = table2;
 
  //add a condition of linking (Cust.CustNo = Ord.CustNo)
  link1.AddCondition(LinkCondType.FieldField, "CustNo", "CustNo", "=");
  model.Links.Add(link1);
 
 
  //now we proceed with adding entities and their attributes
  Entity ent1 = model.CreateEntity();
  ent1.Name = "Customer";
 
  Entity ent2 = model.CreateEntity();
  ent2.Name = "Order";
 
  model.EntityRoot.SubEntities.Add(ent1);
  model.EntityRoot.SubEntities.Add(ent2);
 
  DbEntityAttr attr = new DbEntityAttr();
  attr.Caption = "Company Name";
  attr.Tables.Add(table1);
  attr.Expr = "CompanyName";
  attr.DataType = DataType.String;
  attr.Size = 50;
  attr.FillOperatorsWithDefaults(model);
  model.AssignEntityAttrID(attr);
  ent1.Attributes.Add(attr);
 
  attr = new DbEntityAttr();
  attr.Caption = "Company Address";
  attr.Tables.Add(table1);
  attr.Expr = "Address";
  attr.DataType = DataType.String;
  attr.Size = 80;
  attr.FillOperatorsWithDefaults(model);
  model.AssignEntityAttrID(attr);
  ent1.Attributes.Add(attr);
 
  attr = new DbEntityAttr();
  attr.Caption = "Country";
  attr.Tables.Add(table1);
  attr.Expr = "CountryID";
  attr.DataType = DataType.String;
  attr.Size = 3;
 
  //Assign SQLLIST value editor for Country attribute
  SqlListValueEditor sqlValueEditor = new SqlListValueEditor();
  sqlValueEditor.SQL = "SELECT CountryID, CountryName FROM Countries";
  attr.DefaultEditor = sqlValueEditor;
 
  attr.FillOperatorsWithDefaults(model);
  model.AssignEntityAttrID(attr);
  ent1.Attributes.Add(attr);
 
  attr = new DbEntityAttr();
  attr.Kind = EntAttrKind.Virtual;
  attr.Caption = "Full Region Code";
  attr.Tables.Add(table1);
  attr.UseInConditions = true;
  attr.Expr = "CountryID + ' ' + RegionCode";
  attr.Size = 40;
  attr.DataType = DataType.String;
 
  //Assign CUSTOMLIST value editor for Region attribute
  CustomListValueEditor regionValueEditor = new CustomListValueEditor();
  regionValueEditor.ListName = "RegionList";
  attr.DefaultEditor = regionValueEditor;
 
  attr.FillOperatorsWithDefaults(model);
  model.AssignEntityAttrID(attr);
  ent1.Attributes.Add(attr);
 
 
  attr = new DbEntityAttr();
  attr.Caption = "Order Date";
  attr.Tables.Add(table2);
  attr.Expr = "OrderDate";
  attr.DataType = DataType.Date;
  attr.FillOperatorsWithDefaults(model);
  model.AssignEntityAttrID(attr);
  ent2.Attributes.Add(attr);
 
  attr = new DbEntityAttr();
  attr.Caption = "Order Freight";
  attr.Tables.Add(table2);
  attr.Expr = "Freight";
  attr.DataType = DataType.Currency;
  attr.FillOperatorsWithDefaults(model);
  model.AssignEntityAttrID(attr);
  ent2.Attributes.Add(attr);
 
  attr = new DbEntityAttr();
  attr.Caption = "Shipping Address";
  attr.Tables.Add(table2);
  attr.Expr = "ShipAddress";
  attr.DataType = DataType.String;
  attr.FillOperatorsWithDefaults(model);
  model.AssignEntityAttrID(attr);
  ent2.Attributes.Add(attr);
 
 
  //Refresh all model-related information in visual controls
  QPanel.UpdateModelInfo();
  QCPanel.UpdateModelInfo();
 
 
  //Finally, try to build some query to check if our model is a correct
  query.Clear();
 
  //create one simple condition: Customer Address contains "str"
 
  //here we create condition object
  attr = (DbEntityAttr)model.EntityRoot.FindAttribute(EntityAttrProp.Expression, "Cust.Address");
  SimpleCondition cond = query.CreateSimpleCondition(model);
 
  cond = query.CreateSimpleCondition(model);
  cond.BaseExpr = new DbEntityAttrExpr(model, attr);
  cond.Operator = model.Operators.FindByID("Contains");
  cond.SetValueExpr(1, new ConstExpr(DataType.String, "str"));
  query.Root.Conditions.Add(cond);
 
  //build query to check if it works
  SqlQueryBuilder sqlBuilder = new SqlQueryBuilder(query);
  sqlBuilder.BuildSQL();
  MessageBox.Show(sqlBuilder.Result.SQL);
```</Content>
    <Tags>,data-model,code-sample,tables,links,connection,</Tags>
  </Article>
  <Article id="d3ff2d7b-1096-402a-beb3-a04ea7e92243" title="Column class">
    <Content>```csharp
public class Korzh.EasyQuery.Column

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | _caption |  | 
| `Boolean` | distinct |  | 
| `Int32` | innerSortIndex |  | 
| `Boolean` | needAliasRegeneration |  | 
| `QueryParamList` | Params |  | 
| `ColumnStore` | parent |  | 
| `SortDirection` | sorting |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | Alias |  | 
| `Boolean` | AllowSorting |  | 
| `EntityAttr` | BaseAttr |  | 
| `String` | Caption |  | 
| `Boolean` | Distinct |  | 
| `EqExpression` | Expr |  | 
| `String` | ExprType |  | 
| `Int32` | Index |  | 
| `Boolean` | IsAggregate |  | 
| `Boolean` | IsJustSorting |  | 
| `DataModel` | Model |  | 
| `ColumnStore` | Parent |  | 
| `Query` | ParentQuery |  | 
| `Boolean` | ReadOnly |  | 
| `Int32` | SortIndex |  | 
| `SortDirection` | Sorting |  | 
| `Type` | SystemType |  | 
| `String` | UserData |  | 


### Events

| Type | Name | Description | 
| --- | --- | --- | 
| `EventHandler` | ColumnChanged |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | CheckDataModel() |  | 
| `void` | CheckForParams() |  | 
| `void` | ExprChangeHandler(`Object` sender, `EventArgs` e) |  | 
| `EntityAttr` | GetAttribute() |  | 
| `Int32` | GetHashCode() |  | 
| `void` | LoadFromJsonDict(`JsonDict` colDict) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | OnColumnChanged(`Int32` part) |  | 
| `Boolean` | OnColumnChanging(`Int32` part) |  | 
| `void` | RecreateExpression(`String` type) |  | 
| `void` | RegenerateCaption() |  | 
| `JsonDict` | SaveToJsonDict() |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="d482d197-d2d2-4da2-9a07-bf760221a999" title="SimpleCondExprList class">
    <Content>```csharp
public class Korzh.EasyQuery.SimpleCondExprList
    : ExprList, IList&lt;EqExpression&gt;, ICollection&lt;EqExpression&gt;, IEnumerable&lt;EqExpression&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;EqExpression&gt;, IReadOnlyCollection&lt;EqExpression&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | InsertItem(`Int32` index, `EqExpression` item) |  | 
| `void` | RemoveItem(`Int32` index) |  | 
| `void` | SetItem(`Int32` index, `EqExpression` item) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="d6946f16-4a10-4c43-be59-bca3edfcfd5c" title="EOLSymbol class">
    <Content>```csharp
public enum Korzh.EasyQuery.EOLSymbol
    : Enum, IComparable, IFormattable, IConvertible

```

### Enum

| Value | Name | Description | 
| --- | --- | --- | 
| `0` | None |  | 
| `1` | CRLF |  | 
| `2` | LF |  | 
| `3` | CR |  | 


</Content>
    <Tags />
  </Article>
  <Article id="d6e033c7-3f56-4a8e-9854-2bb1935d9acc" title="Paging in query results">
    <Content>## 1. Problem Overview
It is rather problematic and inconvenient to deal with huge data sets on the web-pages. To make it better you can use paging and divide your data into several pages.

Paging is partially available in EasyQuery, though it is not the basic functionality of our product. We added it to make work with queries more convenient for our users. 

Here you can find instructions how to implement paging in different types of projects.

## 2. Paging in MVC projects (JS grid)
EasyQuery functionality in MVC project is provided by special `EqServiceProviderDb` object usually created in controller’s constructor. To enable paging for returned results you just need to turn on its Paging.Enable property and then properly process and return current paging parameters in ExecuteQuery action:

```c#
public EasyQueryController() {
  eqService = new EqServiceProviderDb();

  eqService.Paging.Enabled = true;

  . . . . . . . .
}


. . . . . . . . .


public ActionResult ExecuteQuery(string queryJson, string optionsJson) {
  var query = eqService.LoadQueryDict(queryJson.ToDictionary());
  var optionsDict = optionsJson.ToDictionary();

  eqService.LoadOptionsDict(optionsDict); //add this line to process paging load paging parameters (page index in particular)

  var resultSet = eqService.ExecuteQuery(query, optionsDict);
  var resultSetDict = eqService.DataSetToDictionary(resultSet, optionsDict);

  Dictionary&lt;string, object&gt; dict = new Dictionary&lt;string, object&gt;();

  dict.Add("resultSet", resultSetDict);
  dict.Add("paging", eqService.Paging.SaveToDictionary()); //add this link to return paging page index and size in result JSON.

  return Json(dict);
}
```

Here is an example how the above code works in our [live demo](http://demo.easyquerybuilder.com/adhoc-reporting).

## 3. Paging in MVC projects (Partial View)

Sometimes in MVC applications, it is easier to build result table with standard partial view approach and then send this fully-formed HTML to the client-side in response to AJAX request.

You can see how this method is used to render the list of Customers or Orders in our “data filtering” [live demo](http://demo.easyquerybuilder.com/data-filtering/Order).

Here is code, which is used in that example:

```c#
//OrderController.cs
using Korzh.EasyQuery.Mvc;

. . . . . . . . . .

public ActionResult ApplyFilter(string queryJson, string optionsJson) {
  var query = eqService.LoadQueryDict(queryJson.ToDictionary());
  var lvo = optionsJson.ToListViewOptions();
  var list = dbContext.Orders.DynamicQuery&lt;Order&gt;(query, lvo.SortBy).ToPagedList(lvo.PageIndex, 20);

  return View("_OrderListPartial", list);

}

```

Here is how _OrderListPartial.cshtml make look like:

```html
@using Korzh.EasyQuery.Mvc

@model Korzh.EasyQuery.Services.IPagedList&lt;Korzh.EasyQuery.Mvc.Demo.Models.Order&gt;
@{
  Layout = null;
}

&lt;table class="table"&gt;
  &lt;tr&gt;
  &lt;th&gt;
  Customer
  &lt;/th&gt;
  &lt;th&gt;
  Order date
  &lt;/th&gt;
  &lt;/tr&gt;

@foreach (var item in Model) {
  &lt;tr&gt;
  &lt;td&gt;
  @item.Customer.Name
  &lt;/td&gt;
  &lt;td&gt;
  @item.OrderDate.ToString()
  &lt;/td&gt;
  &lt;/tr&gt;
}

&lt;/table&gt;

@Html.PageNavigator(Model)
```

The central paging “magic” occurs in `ToPagedList` extension method on the server-side and `PageNavigator` HTML helper.

## 4. Paging in WebForms projects

WebForms edition of EasyQuery does not support paging directly. 

However since usually, we use a standard GradView control to show query results - it is quite easy to setup paging and sorting functionality available there. Here is an [article](https://docs.microsoft.com/en-us/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/sorting-paging-and-filtering-data
) with detailed step-by-step description how to do it.

## 5. DB level paging

By default paging mechanism in EasyQuery still, retrieves the whole record set and just take necessary part of it to return to a client. Such approach reduces the amount of data transferred between client-side and server, but the load on database level stays the same. To reduce it as well - it's possible to use special SQL commands (like OFFSET ... FETCH). 
To turn this functionality on you need to set `Formats.SupportPaging` property of `EqServiceProviderDb` object in EasyQueryController's constructor:

```
eqService.Formats.SupportPaging = true;
```

NB: Currently this option works only on MS SQL Server 2012 or higher.</Content>
    <Tags>,paging,dataset,resultset,code-sample,</Tags>
  </Article>
  <Article id="d926f157-bea2-4dfb-825b-8835620181fe" title="Tables and links page">
    <Content>Use this page to describe tables taking part in the data model.
The page consists of 2 main sections: list of tables on the left side and properties of selected table at the right (the second panel is empty when no table is selected).
The table properties panel is also divided into two panels: the properties themselves on the top and the list of table links at the bottom.

To select the table or link just click on it. Properties of the selected table will be shown in the right panel.
To add or delete tables use the corresponding menu items from “Tables” menu.

## Table properties

**Table alias** is an alias for the table in generated SQL statements (optional but needed if you link the table more than once on different conditions)
NOTE: any particular database table can be added to the data model several times with different aliases. It is necessary to eliminate the ambiguities when some two tables have several link paths from one to another. For more information see [Working with aliases](https://korzh.com/easyquery/docs/data-model-editor/working-with-aliases).

**Table hint(s)** is intended to specify locking method used in MS SQL Server syntax (like NOLOCK, ROWLOCK or READCOMMITED). Please note: this options might not be applied to other database servers (like MySQL).

**Quote table name** check box means if the table name should be put in double quotes in SQL statements - it is useful for table names including spaces and national characters.

## Working with table links

To add a new link for selected table just click on Add button near the list of links. Specify link properties and conditions using [Edit link dialog](https://korzh.com/easyquery/docs/data-model-editor/edit-link-dialog) and press OK. The new link will appear in the list.
To edit existing link - just select in the list and click on Edit button. Press OK when finish editing.
To remove some link - selected it and press Delete button.
</Content>
    <Tags>,data-model,tables,links,</Tags>
  </Article>
  <Article id="da19bbfd-c5ed-49bc-bbbf-37a85afb6d53" title="About Data Model Editor">
    <Content>EasyQuery uses a special repository (so-called “data model”) that allows you to hide the details of your database organization from the end-users. It contains information about tables, links between them, some entities of the data domain and operators which can be used in query conditions (such as “is equal to” or “is more than”).

Data Model Editor (DME) is a GUI tool that allows to create/edit such data models.

Though being easy to use and self-explanatory, data model editing requires some understanding of the relational databases handling. Users totally unfamiliar with database management should better leave this dialog for a database operator or another experienced user.

First of all, you will use DME to create your first data model. Here is a detailed instruction which will guide you through all steps of model creation process:

* [Creating new data model using Data Model Editor](https://korzh.com/easyquery/docs/getting-started/new-data-model)

Once a model is created (or opened), you will see three tabs:

* [Tables and Links](https://korzh.com/easyquery/docs/data-model-editor/tables-links-page) - to describe tables taking part in the data model. You may define an alias for each table, as described in [”Working with table aliases”](https://korzh.com/easyquery/docs/data-model-editor/working-with-aliases) topic.
* [Entities](https://korzh.com/easyquery/docs/data-model-editor/entities-page) - to describe the entities and their attributes which end-user can operate with to build queries.
* [Operators](https://korzh.com/easyquery/docs/data-model-editor/operators-page) - to describe operations (like comparisons) upon the data model's fields. Each operator should have a default value editor set. All available editors are listed in [”Value editors”](https://korzh.com/easyquery/docs/data-model-editor/value-editors) topic.

</Content>
    <Tags>,data-model,dme,database,</Tags>
  </Article>
  <Article id="da7732a2-24a1-48a7-bb22-38fbdcf8fc70" title="SortedColumnList class">
    <Content>```csharp
public class Korzh.EasyQuery.SortedColumnList
    : ColumnList, IList&lt;Column&gt;, ICollection&lt;Column&gt;, IEnumerable&lt;Column&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;Column&gt;, IReadOnlyCollection&lt;Column&gt;, IComparer&lt;Column&gt;

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | Updating |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | BeginUpdate() |  | 
| `void` | ClearItems() |  | 
| `Int32` | Compare(`Column` x, `Column` y) |  | 
| `void` | CoreSortOrderChanged(`SortOrderChangedEventArgs` e) |  | 
| `void` | EndUpdate() |  | 
| `void` | InsertItem(`Int32` index, `Column` item) |  | 
| `void` | Move(`Column` col, `Int32` shift) |  | 
| `void` | Move(`Int32` index, `Int32` newIndex) |  | 
| `void` | PlainInsert(`Int32` index, `Column` item) |  | 
| `void` | PlainRemoveAt(`Int32` index) |  | 
| `void` | RemoveItem(`Int32` index) |  | 
| `void` | Sort() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="dd6b3ab9-4615-47ad-be5c-a10b0cb51d94" title="DisplayFormatParser class">
    <Content>```csharp
public class Korzh.EasyQuery.DisplayFormatParser

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Int32` | ExprNum |  | 
| `TokenType` | Token |  | 
| `String` | TokenText |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | Next() |  | 
| `void` | Start(`String` s) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="ddda9ddc-7cea-4f0c-8e4a-25547eae4705" title="QueryTextFormats class">
    <Content>```csharp
public class Korzh.EasyQuery.QueryTextFormats

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `HtmlFormats` | HtmlFormatting |  | 
| `Boolean` | ShowEntityName |  | 
| `Boolean` | ShowRootPredicate |  | 
| `Boolean` | UseHtml |  | 
| `Boolean` | UseMathSymbolsForOperators |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `QueryTextFormats` | Default |  | 


</Content>
    <Tags />
  </Article>
  <Article id="df21747d-3c22-4f85-8d10-dfa10c54acf5" title="How to save/load queries to/from database">
    <Content>By default, EasyQueryController saves/loads queries as XML files in App_Data folder. You can easily change this default behavior and save/load queries to any other storage (for example a database).

All you need to do - is add your handlers for QueryLoader and QuerySaver procedures in EasyQueryController constructor: 

```c#
public EasyQueryController() {
  eqService = new EqServiceProviderDb();
 
  eqService.QueryLoader = (query, queryName) =&gt; {
  string queryXml = "Get query content from database here"; 
  query.LoadFromString(queryXml);
  };
 
  eqService.QuerySaver = (query, queryName) =&gt; {
  string queryXml = query.SaveToString();
  //save queryXml content into database here
  };
 
  . . . . . . . . .
}
```

On the client side, you just call `EQ.client.loadQuery` function when you need to send "GetQuery" request (which is passed to `QueryLoader` on the server side" and `EQ.client.saveQuery` to call "SaveQuery" request (passed to `QuerySaver` handler).

```js
EQ.client.loadQuery({
    queryId: "MyQueryID",
    success: function (data) {
         //show some notification on success
     },
     error: {
         //show some alert on error
     }
});
```

```js
EQ.client.saveQuery({
	"queryName": "Some new query name",
	"success": function (data) {
            //saved successfully
	},
	error: {
            //error during saving
        }
});
```
</Content>
    <Tags>,entity-framework,asp-net,mvc,query-load,query-save,code-sample,</Tags>
  </Article>
  <Article id="e09aa980-7b50-411b-a203-9d5d87a8022b" title="ConstListValueEditor class">
    <Content>```csharp
public class Korzh.EasyQuery.ConstListValueEditor
    : ListValueEditor

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | DefaultText |  | 
| `String` | DefaultValue |  | 
| `String` | TypeName |  | 
| `ConstValueList` | Values |  | 
| `String` | XmlDefinition |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `ConstValueList` | CreateValueList() |  | 
| `void` | LoadContentFromXmlReader(`XmlReader` reader) |  | 
| `void` | SaveContentToJsonDict(`JsonDict` dict) |  | 
| `void` | SaveContentToXmlWriter(`XmlWriter` writer) |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeCaption |  | 
| `String` | STypeName |  | 


</Content>
    <Tags />
  </Article>
  <Article id="e0d1baa9-45ef-48ea-8c7d-ce4d84ac31e6" title="JavaScript widgets formats and settings (Webforms)">
    <Content>## Display formats for columns 

When you need to change default format for columns, you should implement additional settings. 

For Webforms use `Appearance.AttrElementFormat` property of QueryColumnsPanel control. By default, it's set to `{entity}` `{attr}` value what means that we need to show the entity name and then attribute's name. You can set it to simply `{attr}` to remove the entity name part.

Additionally, you may also want to change the format of the first (Expression) column in Columns Panel - use `EntityAttrExpr.TextFormat` static property for that.

So, combining both these options, here is the code sample:

```
QueryColumnsPanel1.Appearance.AttrElementFormat = "{attr}";
EntityAttrExpr.TextFormat = "{attr}";
```</Content>
    <Tags>,asp-net,entity-framework,webforms,code-sample,</Tags>
  </Article>
  <Article id="e19a459b-ed70-4f94-93ff-e9a34767ed6a" title="Entities page">
    <Content>Entities are intended to hide data storage details from the end user. Instead of operating with tables, views and fields (such as Orders.CustNo, Customers.Addr1) user see some entities from the real world (Order, Customer, Vendor, etc.) and their attributes (Customer Name, Order Ship Date, Vendor Country, etc.).

For large data models, entities can be organized in a hierarchy for more easy manipulation.

There are two main types of entity attributes:

* Data Attribute - it totally corresponds to particular field in some database table (e.g. attribute Order Ship Date corresponds to database field Orders.ShipDate)

* Virtual Attribute - a calculated attribute which is defined by some expression containing several fields, operators (+, -, ||, etc.), constants and even functions or storage procedure calls

**Entities** tree holds a list of all defined entities and their attributes.

## Main operations

* To add a data attribute - select the entity node you would like to add it to and then choose Add Data Attribute item from “Entities” menu. Choose the table, its field in the dialog that appear and click OK button.

* To add a virtual (i.e., calculated) attribute, select the entity node you would like to add it to and choose ”Entities | Add Virtual Attribute” menu item.

* To delete an attribute or entity - select it and choose ”Entities | Delete selected item” menu item.

* To edit an attribute, select it in the tree and change its properties in the editor appearing in the dialog's right part.

* To move the attribute from one entity to another (or to change its appearance order within the entity) - just drag it to the appropriate place.

The attribute's property editor has General, Operators and Value Editors tabs described below.

## General tab

This tab contains the following input field and checkboxes:

* **Caption** field - a string meaning how the attribute name will be displayed for an end-user.

* **Expression** field - contains table and field names for data attributes and full SQL expression for virtual ones. For data attributes this field is read-only.

* **Used tables** panel - contains the list of all tables used in the selected attribute. For data attributes this field is read-only.

* **Data Type** and **Data Size** fields - contain a type of attribute and its size. These values are taken from corresponding field definition for data attributes and should be set manually by data model developer for virtual attributes. See Data types for details.

* **Use in conditions** checkbox allows specifying if this attribute can be used in query conditions. If this option is not checked - a user will not see this attribute in a drop-down list in query panel.

* **Use in result** checkbox allows specifying if this attribute can be used in result columns. If this option is not checked - a user will not see this attribute in a drop-down list in columns panel.

* **Use in sorting** checkbox allows specifying if the user can sort by this attribute.

* **Quote field name in SQL** check box means if the field name should be put in quotes in SQL statements. Useful for field names which include some reserved words. Field names with spaces will be quoted automatically.

* **Use alias** check box specifies if query builder will generate an alias for the result column where this attribute is used.

* **Description** field - allows associating some textual description with an attribute. Entered data can be accessed at run-time.

* **Custom Data** field - allows to associate any information with attribute. Entered data can be accessed at run-time.

## Operators tab

This tab holds list of all operations applicable to the attribute. Add or remove operations by corresponding buttons. Use Clear button to remove all operators from the list.

Use *Defaults* button to reset the list of operators for selected attribute to a default state. The default operator list contains most appropriate operators for attribute's data type.

See [Operators page](https://korzh.com/easyquery/docs/data-model-editor/operators-page) for details about operators used in data models.

## Value Editors tab

This tab allows to define how a user will edit the parameters which the selected attribute is compared to in query conditions. To learn more about available editors see [Value Editors](https://korzh.com/easyquery/docs/data-model-editor/value-editors) topic. To specify editor parameters click on “Settings…” button.
</Content>
    <Tags>,data-model,entity-framework,attributes,</Tags>
  </Article>
  <Article id="e474fdf6-4c1a-45dd-8b51-9c039c7305af" title="How to limit columns from duplication ">
    <Content>Sometimes you need to limit columns from duplication in MVC project, so when you add a column that is already used in a report it won’t be added again. 
 
So here is the way how to do. You can use `allowDuplicates` option of ColumnsPanel here. Just set it in `columnsPanel` section of `easyQuerySettings` variable definition:
 
```
window.easyQuerySettings = {
    serviceUrl: "/EasyQuery",
    loadDefaultModel: true,
    .    .    .   .    .
    columnsPanel: {
        allowDuplicates: false,
         .    .    .   .    .
    },
    .    .    .   .    .
}
```
</Content>
    <Tags>,asp-net,mvc,data-model,code-sample,columns-panel,entity-framework,</Tags>
  </Article>
  <Article id="e4e7078a-bc0f-430f-8c08-09538119cecf" title="How to show descriptive texts in some column instead of numeric values ">
    <Content>It's quite often you have some numeric field in your database table and the numbers stored there have some special meanings.
For example, your Status field and possible values for that field can be: 1 - New, 2 - Reviewed, 3 - In Progress, 4 - Resolved, 5 - Closed

For condition section, you can define a [value editor](/easyquery/docs/fundamentals/about-data-editors) which will show the list of available values as those descriptive meanings (New, Reviewed, ...).

However, when a user adds that field into Columns section of query - it will get only numeric values in a result. 
To get those descriptive meanings instead of numeric values, you need to define a virtual attribute with the expression like `CASE Status WHEN 1 THEN 'New' WHEN 2 ...` and then use that new attribute as a column in your queries.
You can set UseInResult to false for the first attribute (so make it not visible for columns panel) and set UseInConditions = false for the second (virtual) one - so it will not be able to use it in conditions.
Both attributes can have the same caption, so your users will consider them as one.

Here is more detailed description how to achieve needed result:

1) Run Data Model Editor and open your model there.

2) Go to "Entities" tab and select the entity where you would like to see new attribute (most probably it's the same entity where your ID attribute is placed).

3) Right-click on it and select "Add virtual attribute".

4) Set Caption property of new attribute to some user-friendly name (e.g. "Status")

5) Set expression of new attribute to something like 

  CASE Tickets.Status WHEN 1 THEN 'New' WHEN 2 THEN 'Reviewed' WHEN 3 THEN 'In Progress' WHEN 4 THEN 'Resolved' WHEN 5 THEN 'Closed' END

(Here we supposed that Status field belongs to Tickets table). 

6) Turn on "Use In Result" option and turn off "Use in conditions".

7) Save your model. 


Now when user adds new Status virtual attribute as a column - then he can see a descriptive meanings in result set for this column instead of numeric values.</Content>
    <Tags>,data-model,dme,entity-framework,database,</Tags>
  </Article>
  <Article id="e5d114fe-0d35-4780-b3c5-d936582e503b" title="Version 3.5.0 release notes">
    <Content>Version 3.5 of EasyQuery ASP.NET contains several essential changes, especially for MVC projects. 
Here are the most important ones: 

## 1. Zero-configuration approach 

```js
&lt;script&gt; 
  . . . . . . . . 
  $(document).ready(function () {
 
  EQ.client.init({
  //EasyQuery widgets settings
  });
  EQ.view.init();
  });
  . . . . . . . . 
&lt;/script&gt; 
```
Now it's not necessary. You just need to include our script files anywhere in your page (but after inclusion of JQuery and JQuery UI, of course).
You can use the scripts from our CDN: 
```js
&lt;script src="http://cdn.korzh.com/eq/eq.all.min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="http://cdn.korzh.com/eq/eq.view.js" type="text/javascript"&gt;&lt;/script&gt;
```
or local scripts: 
```js
&lt;script src="@Url.Content("~/scripts/eq.all.min.js")" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="@Url.Content("~/scripts/eq.view.js")" type="text/javascript"&gt;&lt;/script&gt;
```
 The code above will use default settings and will search for default placeholder IDs to setup EasyQuery widgets (such as "QueryPanel", "ColumnsPanel", etc.).
If you need to set some options, you may do it using old method (calling EQ.client.init function directly with necessary settings) or a new approach: through special global variable easyQuerySettings.

Example: 
```js
&lt;script&gt; 
  window.easyQuerySettings = {
  serviceUrl: "/EasyQuery",
  modelName: "NWindSQL",
  entitiesPanel: { showCheckboxes: true },
  columnsPanel: { allowAggrColumns: true, attrElementFormat: "{entity} {attr}", showColumnCaptions: true, adjustEntitiesMenuHeight: false },
  queryPanel: { alwaysShowButtonsInPredicates: false, adjustEntitiesMenuHeight: false, menuSearchBoxAfter: 20 },
  syncQueryOptions: {
  sqlOptions: {SelectDistinct:true}
  },
 
  listRequesHandler: function (params, onResult) {
  //your listRequest handler goes here
  }
 
  };
&lt;/script&gt; 
 . . . . . . . . . . 
 
&lt;!-- somewhere at the end of your page --&gt;
&lt;script src="@Url.Content("~/scripts/eq.all.min.js")" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="@Url.Content("~/scripts/eq.view.js")" type="text/javascript"&gt;&lt;/script&gt;
```
## 2. New controller and EqServiceProviderDb class 
 Version 3.4 of EasyQuery includes a base implementation of MVC controller which processes all AJAX request from client-side: EqDbMvcController class. You was needed to inherit your own controller from that class and override some virtual methods to adjust its functionality to your needs. This approach worked well (and still do) however there were two main problems with it:

1. First of all, you don't have full control over controller's actions and the way they processed. Most of functionality was hidden inside EqDbMvcController class.

2. Second, you needed a special assembly (Korzh.EasyQuery.Mvc#) which provided you with necessary functionality. The problem was: that assembly could work only with a particular version of MVC. If you upgrade your project to newer MVC version - it becomes useless.

To avoid these problems in future, we introduced a new approach in version 3.5 of EasyQuery:

- Now you inherit your controller from Controller class (as usual) and should define all necessary actions (such as GetModel, GetQuery, SyncQuery, ExecuteQuery, etc.) in it.
- Your EasyQueryController (or whatever name it has) uses an instance of a special EqServiceProviderDb class which contains all functionality necessary in controller's actions. So, most of the actions now have just 1-2 lines of code: prepare data for EqServiceProvider, call its method and return the result in JSON format.

Of course you don't need to write that controller from scratch. We provide you with several ready-to-use templates which you can copy into your project and adjust if necessary.

Here is an example of a typical EasyQueryController implementation: 

```js
public class EasyQueryController : Controller {
 
  private EqServiceProviderDb eqService;
 
  public EasyQueryController() {
  eqService = new EqServiceProviderDb();
 
  eqService.SessionGetter = key =&gt; Session[key];
  eqService.SessionSetter = (key, value) =&gt; Session[key] = value;
 
  string dataPath = System.Web.HttpContext.Current.Server.MapPath("~/App_Data");
  eqService.DataPath = dataPath; 
  eqService.Connection = new SqlCeConnection("Data Source=" + System.IO.Path.Combine(dataPath, "Northwind.sdf"));
  }
 
  [HttpPost]
  public ActionResult GetModel(string modelName) {
  var result = eqService.GetModel(modelName);
  return Json(result.SaveToDictionary());
  }
 
  [HttpPost]
  public ActionResult GetList(ListRequestOptions options) {
  return Json(eqService.GetList(options));
  }
 
  [HttpPost]
  public ActionResult GetQuery(string queryName) {
  var query = eqService.GetQuery(queryName);
  return Json(query.SaveToDictionary());
  }
 
 
  [HttpPost]
  public ActionResult SaveQuery(string queryJson, string queryName) {
  eqService.QuerySaverDict(queryJson.ToDictionary(), queryName);
  Dictionary&lt;string, object=""&gt; dict = new Dictionary&lt;string, object=""&gt;();
  dict.Add("result", "OK");
  return Json(dict);
  }
 
  [HttpPost]
  public ActionResult ExecuteQuery(string queryJson, string optionsJson) {
  var statement = eqService.GetSqlByQueryJson(queryJson.ToDictionary());
  var resultSet = eqService.GetDataSetBySql(statement);
  var resultSetDict = eqService.DataSetToDictionary(resultSet, optionsJson.ToDictionary());
  Dictionary&lt;string, object=""&gt; dict = new Dictionary&lt;string, object=""&gt;();
  dict.Add("statement", statement);
  dict.Add("resultSet", resultSetDict);
  return Json(dict);
  }
 
  [HttpGet]
  public JsonResult GetQueryList(string modelName) {
  IEnumerable&lt;listitem&gt; queries = eqService.GetQueryList(modelName);
 
  return Json(queries, JsonRequestBehavior.AllowGet);
  }
 
  [HttpPost]
  public ActionResult SyncQuery(string queryJson, string optionsJson) {
  IDictionary&lt;string, object=""&gt; queryDict = queryJson.ToDictionary();
  eqService.SyncQueryDict(queryDict);
 
  var statement = eqService.BuildQueryDict(queryDict, optionsJson.ToDictionary());
  Dictionary&lt;string, object=""&gt; dict = new Dictionary&lt;string, object=""&gt;();
  dict.Add("statement", statement);
  return Json(dict);
  }
 
  [HttpPost]
  public ActionResult ExecuteSql(string sql, string optionsJson) {
  return Json(eqService.ExecuteSql(sql, optionsJson.ToDictionary()));
  }
 
  }
 

```

## 3. SyncQuery action

Version 3.5 of EasyQuery introduces new default action in controller: SyncQuery. To some extent it replaces old BuildQuery action but additionally provides more flexibility. As the name says its main purpose to synchronize current state of query on client-side with its server-side copy which can be, for example, stored in Session.

But you can also use it to return some information to the client.
For example, using "statement" property of returned JSON object you can pass to the client a generated SQL statement.

## 4. New JavaScript classes Query and DataModel

Client-side code now have equivalents of DbQuery and DbModel classes used on server-side to perform all operations with query and model. For example, here is a piece of JavaScript code which adds a condition into your query: 

```js
$("#AddConditionButton").click(function () {
  var query = EQ.client.getQuery();
  query.addSimpleCondition({ attr: "Customers.CompanyName", operator: "StartsWith", value: "A" });
});
```
## 5. Upgrading from previous versions

Your code from version 3.4 of EasyQuery will still work in version 3.5 without any problem.
However, to get more flexibility and avoid any possible problems in future we suggest to make the following changes:

1. Move the commands which includes eq.all.min.js and eq.view.js files in your web-page to the end of the page's code (before closing &gt;/body&lt; tag).
2. Assign the object which defines widgets' settings to easyQuerySettings global variable (see example in paragraph #1).
3. Remove the code which performs explicit initialization of EasyQuery widgets (EQ.client.init(), EQ.view.init()) since they will be initialized automatically at the point of script inclusion.
4. Remove Korzh.EasyQuery.Mvc#.NET### assembly from your project and replace it by Korzh.EasyQuery.Services.Db.NET### 
5. Change your EasyQueryController class using one of our templates. The template you need can be taken from one of the sample projects distributed with EasyQuery:
  - EQMvcDemoDb - using EasyQuery with direct connection to database and SQL query language.
  - EQMvcDemoEF - using EasyQuery with EnityFramework and Entity SQL as query langauge.
  - EQMvcDemoLinq - EntityFramework and LINQ.
</Content>
    <Tags>,asp-net,code-sample,data-model,</Tags>
  </Article>
  <Article id="e612bee5-854a-4c03-b33e-eb8dd2e7347f" title="ConstExpr class">
    <Content>```csharp
public class Korzh.EasyQuery.ConstExpr
    : EqExpression

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `DataType` | DataType |  | 
| `DataKind` | Kind |  | 
| `String` | TypeName |  | 
| `String` | Value |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | LoadFromJsonDict(`JsonDict` dict) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | SaveToJsonDictCore(`JsonDict` dict) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer, `String` tagName) |  | 
| `void` | SetContentSilent(`String` val, `String` txt) |  | 
| `void` | SetDataType(`DataType` dataType) |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeName |  | 


</Content>
    <Tags />
  </Article>
  <Article id="e620bc62-b25e-4c67-9afb-3ef9823b2a2d" title="QueryFormats class">
    <Content>```csharp
public class Korzh.EasyQuery.QueryFormats

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `DataTypeList` | quotedTypes |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | AlphaAlias |  | 
| `String` | DateFormat |  | 
| `String` | DateTimeFormat |  | 
| `EOLSymbol` | EOL |  | 
| `String` | EscapeSymbol |  | 
| `String` | FalseValue |  | 
| `Boolean` | FilterMode |  | 
| `String` | LowerFuncName |  | 
| `Int32` | MaxIdentLen |  | 
| `String` | MoneySuffix |  | 
| `OrderByStyles` | OrderByStyle |  | 
| `Boolean` | QuoteBool |  | 
| `Boolean` | QuoteColumnAlias |  | 
| `Boolean` | QuoteTime |  | 
| `Boolean` | SupportPaging |  | 
| `String` | TimeFormat |  | 
| `String` | TrueValue |  | 
| `ColumnAliasesUsage` | UseColumnAliases |  | 
| `Char` | WildcardAny |  | 
| `Char` | WildcardSingle |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | CopyFrom(`QueryFormats` source) |  | 
| `Boolean` | Equals(`Object` obj) |  | 
| `String` | GetEolSymbol() |  | 
| `Int32` | GetHashCode() |  | 
| `Boolean` | IsQuotedType(`DataType` type) |  | 
| `void` | LoadFromJsonDict(`JsonDict` dict) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | LoadNode(`String` nodeName, `String` nodeValue) |  | 
| `void` | SaveNodes(`XmlWriter` writer) |  | 
| `void` | SaveToJsonDict(`JsonDict` dict) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer, `String` rootNodeName) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="e65a4e5a-275c-4d07-8816-d0289d7c5259" title="Navigate through data model entities and attributes">
    <Content>Sometimes you need to run through all entities and attributes in your data model to perform some operation for each of them or to find a particular entity or attribute. Here is a code snippet which demonstrates this operation: 

```js
private void RunThroughEntity(Entity entity) {
  //do whatever you need with this entity
 
  //run through all sub-entities
  foreach (Entity ent in entity.SubEntities) {
  RunThroughEntity(ent);
  }
 
  //run through all attributes of this entity
  for each (EntityAttr attr in entity.Attributes) {
  //do whatever you need with this attribute
  }
 
}
 
. . . . . . . . . . .
 
//to start the process just call this function for the root entity and your model
RunThroughEntity(dataModel1.EntityRoot);
```</Content>
    <Tags>,entity-framework,data-model,code-sample,attributes,</Tags>
  </Article>
  <Article id="e67fc1cd-7d39-4ed2-bc4c-cf899658800e" title="Version 4.1.0 release notes">
    <Content>## 1. Support for .NET Core 2.0 / .NET Standard 2.0

*  All EasyQuery assemblies target .NET Standard 1.5 (or lower) version - so they are fully compatible with .NET Standard 2.0. The exception is Korzh.EasyQuery.EntityFrameworkCore.Relational package which in the previous version (4.0) raised an error when used with Entity Framework Core 2.0. Version 4.1.0 of this package targets .NET Standard 2.0 and fixes that problem.

## 2. New package: Korzh.DbExport

*  This package contains some useful function for exporting data sets to CSV or HTML (Excel compatible) formats. You can use them in your MVC projects the same way as in version 3.x of the library.

## 3. DbGate packages

*  We added several DbGate packages (for MS SQL Server, My SQL, and Postgre SQL). You can use them to load your model directly from the DbConnection object (via FillByDbGate method) if you don't use Entity Framework Core in your project.

## 4. Core library 

*  There is a new possibility to mark any condition as "In Join", so that condition will be added into JOIN clause instead of WHERE. Also, you can mark any condition as "Parameterized", so the values in this condition will be placed into result SQL as parameters.

## 5. JavaScript widgets      

*  Now it is possible to turn on/off each widget separately thanks to the new configuration of buttons in QueryPanel widget. There is a new **SortingBar** widget, which allows defining the order of sorting columns.

## 6. Data Model Editor      

*  Now Data Model Editor saves its position on exit and restores on the next launch. Also, we'd like to note, that Data Model Editor now shows MS SQL as the default DB gate.  

## 7. Other editions of EasyQuery      

*  There is a significant update for the users of ASP.NET MVC projects: we improved EqServiceProvider, so now it's not necessary to use Session to store data in between the requests.
*  For WebForms users there is a new Refresh method and also a new property ShowCheckboxes in QueryPanel control. We also fixed DateTimePicker error for the values with time part.</Content>
    <Tags>,asp-net-core,dme,mvc,javascript,widgets,</Tags>
  </Article>
  <Article id="e74892b5-caec-43e6-8661-979677b262b7" title="Entity class">
    <Content>```csharp
public class Korzh.EasyQuery.Entity
    : IComparable&lt;Entity&gt;

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `Entity` | parent |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `EntityAttrStore` | Attributes |  | 
| `String` | DbSetName |  | 
| `String` | Description |  | 
| `String` | Id |  | 
| `Boolean` | IsEmpty |  | 
| `Boolean` | IsRoot |  | 
| `DataModel` | Model |  | 
| `String` | Name |  | 
| `Type` | ObjType |  | 
| `Entity` | Parent |  | 
| `EntityStore` | SubEntities |  | 
| `String` | TypeName |  | 
| `Boolean` | UseInConditions |  | 
| `Boolean` | UseInResult |  | 
| `Boolean` | UseInSorting |  | 
| `Object` | UserData |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `EntityAttr` | FindAttribute(`EntityAttrProp` what, `String` val) |  | 
| `Entity` | FindSubEntity(`String` entityName) |  | 
| `EntityAttr` | GetFirstLeaf() |  | 
| `String` | GetFullName(`String` separator) |  | 
| `void` | LoadAttribute(`String` propname, `String` propvalue) |  | 
| `void` | LoadFromXmlReader(`XmlReader` reader) |  | 
| `void` | LoadNodes(`XmlReader` reader) |  | 
| `void` | OnModelAssignment() |  | 
| `void` | SaveAttributes(`XmlWriter` writer) |  | 
| `void` | SaveNodes(`XmlWriter` writer) |  | 
| `void` | SaveToXmlWriter(`XmlWriter` writer) |  | 
| `void` | Scan(`Action&lt;Entity&gt;` entityHandler, `Action&lt;EntityAttr&gt;` attrHandler, `Boolean` processRoot = True) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="e7f38c2e-e91c-4ee6-83b4-4f37f76f725f" title="IEqResultSet class">
    <Content>```csharp
public interface Korzh.EasyQuery.Services.IEqResultSet
    : IDictionary&lt;String, Object&gt;, ICollection&lt;KeyValuePair&lt;String, Object&gt;&gt;, IEnumerable&lt;KeyValuePair&lt;String, Object&gt;&gt;, IEnumerable

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Int32` | ColumnCount |  | 
| `Int64` | RecordCount |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | AddColumn(`String` columnId, `String` title, `Type` columnType) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="e9523ebf-bdd8-48ee-9a26-bfff062a2b37" title="ColumnList class">
    <Content>```csharp
public class Korzh.EasyQuery.ColumnList
    : Collection&lt;Column&gt;, IList&lt;Column&gt;, ICollection&lt;Column&gt;, IEnumerable&lt;Column&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;Column&gt;, IReadOnlyCollection&lt;Column&gt;

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | HasAggregate |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | ContainsGhosts(`Column&amp;` column) |  | 
| `Column` | FindByAlias(`String` alias) |  | 
| `Column` | FindByBaseAttrID(`String` attrID) |  | 
| `Column` | FindByCaption(`String` caption) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="ec30fc8e-1430-4c5f-a2a7-72bf9714ae1e" title="EmptyQueryBuilderResult class">
    <Content>```csharp
public class Korzh.EasyQuery.EmptyQueryBuilderResult
    : QueryBuilderResult

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | GetStatement() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="ee43a519-4287-4a2a-9488-a42cb4f34438" title="PagedList`1 class">
    <Content>```csharp
public class Korzh.EasyQuery.Services.PagedList&lt;T&gt;
    : IPagedList&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable, IPaging

```

### Fields

| Type | Name | Description | 
| --- | --- | --- | 
| `List&lt;T&gt;` | subset |  | 


### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `Int64` | PageCount |  | 
| `Int64` | PageIndex |  | 
| `Int64` | PageSize |  | 
| `Int64` | TotalRecords |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `IEnumerator&lt;T&gt;` | GetEnumerator() |  | 


</Content>
    <Tags />
  </Article>
  <Article id="efb4dc01-d05a-412c-97de-af86c7f00edf" title="Build query by code on client-side">
    <Content>When you work with EasyQuery.JS to build a project (for example MVC-project) you work with two Query objects. First is on the server-side (it’s accessible by `GetQuery` method of `EqServiceProviderDb`) and other - on the client-side (you can get it using `EQ.client.getQuery()` function). 

Sometimes it’s necessary to add query columns and/or conditions by code. Here is [an article](https://korzh.com/easyquery/docs/how-to/add-columns-and-conditions-by-code) which describes how to do it with server-side query object. 

And here is an example of JavaScript code which adds a condition and two columns (one of them an aggregate one) into current query on client-side:

```js
var query = EQ.client.getQuery();
query.addSimpleCondition({ attr: "Customers.CompanyName", operator: "StartsWith", value: "A" });

query.addColumn({
  "caption": "Country",
  "sorting": "Ascending",
  "expr": {
  "typeName": "ENTATTR",
  "id": "Customers.Country"
  }
});

query.addColumn({
  "caption": "Orders total",
  "sorting": "None",
  "expr": {
  "func": "SUM",
  "typeName": "AGGRFUNC",
  "argument": {
  "typeName": "ENTATTR",
  "id": "Orders.Freight"
  }

  }
});
```
</Content>
    <Tags>,javascript,mvc,asp-net,asp-net-core,jquery,widgets,code-sample,</Tags>
  </Article>
  <Article id="f35177ae-e643-468d-be59-2cfbd7c25897" title="Getting started for WPF">
    <Content>1) Run Data Model Editor application in wizard mode (“Create Data Model” program icon) and follow the instructions to create a new data model that describes the data in your database. You will define database tables you want to use in your future queries, links between them and entities with their attributes (mostly the fields in already added tables).

2) Save created data model to some file on your hard-drive (let it be model1.xml for example);

3) Drop QueryPanel components on a form. You need to add this component to a Visual Studio toolbox first if you have not done this before.

4) Create DbDataModel and DbQuery objects in your form's initialization procedure. Connect DbQuery to DbModel through its Model property and QueryPanel to DbQuery through Query property.

Example: 

```
public MainWindow()   
 {   
    InitializeComponent();   
 
    //Create new query and data model objects, connect them with one another and with QueryPanel  
    DbQuery query = new DbQuery();      
 
    query.Model = new DbDataModel();   
    queryPanel.Query = query;  
 
    //Configure query's format according to the database you use.  
    dbQuery.Formats.SetDefaultFormats(FormatType.MsSqlServer);
 
    //Load the data model you created on steps 1-2  
    query.Model.LoadFromFile("model1.xml");   
 }   
```
5) You can also drop on your form QueryColumnsPanel control to allow your users to define the result columns. Link QueryColumnsPanel with DbQuery object exactly like for the QueryPanel control.
After the steps described above your users can add query conditions and result columns;

6) When it's necessary to generate an SQL statement - create an instance of SqlQueryBuilder class and call its BuildSQL() method. Usually, this method is called on some user action (e.g. pressing “Build” button). After that read generated SQL from Result.SQL property of SqlQueryBuilder object.

7) Finally, you can pass the generated SQL statement to some DataSource for execution or use it in any other possible way.

Example:

```
protected void BuildBtn_Click(object sender, EventArgs e) { 
    SqlQueryBuilder builder = new SqlQueryBuilder(query1);
    if (builder.CanBuild) {
        builder.BuildSQL();
        string sql = builder.Result.SQL;
 
        try {
            DataSet ResultDS = new DataSet(); 
 
            OleDbDataAdapter resultDA = new OleDbDataAdapter(queryPanel.Query.Result.SQL, SomeDbConnection); 
            resultDA.Fill(ResultDS, "Result"); 
            dataGrid.ItemsSource = ResultDS.Tables[0].DefaultView; 
        }  
        catch (Exception error) { 
            //if some error occurs just show the error message  
            MessageBox.Show(error.Message);       
        } 
    }
} 
``` </Content>
    <Tags>,wpf,data-model,query-panel,get-start,dme,code-sample,</Tags>
  </Article>
  <Article id="f39a9883-6efc-41d9-8d7e-0e2de9eeae30" title="HAVING and GROUP BY clauses in generated query">
    <Content>1) When a user inserts some aggregate column into the query - EasyQuery automatically adds `GROUP BY` clause into the result SQL statement. To add an aggregate column - just insert a column into `QueryColumnsPanel` as usual, then click on the button near the newly added column and select “Aggregate” in the menu that appears.

2) To add `HAVING` clause into the resulting query you can do the following:
  
* Add special virtual attribute into your data model with expression `“Max(TableName.ExamDate)”`.
* Mark this new attribute as “Aggregate”.
* Assign to this attribute some operators (equals, less than, more than, etc.).
* Save your model.

Now when user add some condition with this new attribute - the condition will go into `HAVING` clause in the result SQL statement;
</Content>
    <Tags>,aggregate-function,group-by,having-sql,virtual-attribute,</Tags>
  </Article>
  <Article id="f52aedab-2613-4ea4-b09c-a83d1d4b97d6" title="OperatorStore class">
    <Content>```csharp
public class Korzh.EasyQuery.OperatorStore
    : OperatorList, IList&lt;Operator&gt;, ICollection&lt;Operator&gt;, IEnumerable&lt;Operator&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;Operator&gt;, IReadOnlyCollection&lt;Operator&gt;

```

### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `void` | RemoveItem(`Int32` index) |  | 


</Content>
    <Tags />
  </Article>
  <Article id="f5a4551a-05f5-4503-b7db-f7ea51b8227a" title="Processing custom value editors in EasyQuery JS">
    <Content>## 1. Value editor setup

First, of you will need to assign a custom (user-defined) value editor for some attribute or operator in your data model.

* Run Data Model Editor (DME).
* Open your model.
* Select an entity attribute which you want to assign custom value editor to.
* On the “Value Editors” tab select “Custom (user-defined)” item in the drop-down list;
* Click “Settings…” button and enter a type name of your custom value editor. For example “MyValueEditor”.
* Save your model and close DME.

## 2. Value editor widget

To process this value editor on client-side, you will need to create a new ValueEditor widget. Place it in a separate .js file and include that file in the same view where other EasyQuery widgets are used. To create new value editor widget, you will need to inherit it from eqjs.ValueEditor widget and override several methods. The name of new widget must correspond to the name of your custom value editor with “eqjs.ValueEditor_” prefix. In our example, it will be “eqjs.ValueEditor_MyValueEditor”.

Here is an example of very simple value editor which just shows an OK alert when a user clicks on the value element in condition. 

```js
(function ($, undefined) {
 
  $.widget("eqjs.ValueEditor_MyValueEditor", $.eqjs.ValueEditor, {
 
  _renderEditor: function () {
  var self = this;
 
  //do widget rendering here
  },
 
  _showEditor: function () {
  alert("OK");
  }
  })
})(jQuery);
```
Now try to run your application, add a new condition with selected attribute and click on the last element in this condition. If everything was done right - the you should see “OK” alert message.</Content>
    <Tags>,data-model,asp-net,mvc,code-sample,javascript,dme,</Tags>
  </Article>
  <Article id="fbc5e60f-6449-4215-9a01-c96cc5ecbf0d" title="Using parameters in query conditions">
    <Content>EasyQuery has different scenarios how to create a parameterized query. Here you can find an explanation how to work with parameters:

## 1. BuildParamSQL

You can generate parameterized query using `BuildParamSQL` instead of standard `BuildSQL`.

Example:

```
var builder = new SqlQueryBuilder();
builder.BuildParamSQL();
```

There is also a possibility to get the list of all parameters (with their names and types) after calling `BuilderParamSQL` method using `Params` property of DbQuery class.

Here is an example of code which calls `BuildParamSQL` method and then navigates through all generated parameters:

```
var builder = new SqlQueryBuilder();
builder.BuildParamSQL();
foreach (var param in query.Params) {
    var paramId = param.ID; //parameter's name
    var paramType = param.DataType; //parameter's type
}
```

## 2. allowParameterization 

This method can be used with EasyQuery for ASP.NET edition and only on MVC projects. Since version 3.8.0 there is a new option in QueryPanel widget: `allowParameterization`. 

The default value for this option is 'false'. If it's set to 'true' you will see a new button in each condition which allows marking that condition as 'parameterized' - so all values in it will appear in result SQL as parameters.

To see how it works you can just add the following line in `easyQuerySettings` variable definition in our EqMvcDemoDB sample project:

```
window.easyQuerySettings = {
    serviceUrl:  "/EasyQuery",
     .     .     .     .     .     .            
    queryPanel: {
        allowParameterization: true, //&lt;-----------------add this line
        .     .     .     .     .    .    .
     }
}
```
</Content>
    <Tags>,data-model,asp-net,asp-net-mvc,parameters,sql,code-sample,javascript,</Tags>
  </Article>
  <Article id="fd16cfab-77c3-4f84-80ea-6601181e31de" title="Getting started for ASP.NET WebForms">
    <Content>&gt; See also: [Getting started for ASP.NET MVC](/easyquery/docs/getting-started/asp-net-mvc)

&amp;nbsp;             

To apply [EasyQuery ASP.NET](/easyquery#asp-net/) to your WebForms application please perform the following steps:

## 1. Create Data Model

Open “EasyQuery ASP.NET” folder on your desktop and run Data Model Editor (DME) application in wizard mode (“Create Data Model” program icon). Follow the instructions to create a new data model for your database.
You will need to add database tables (select the ones you allow your users to use in their queries), links between them and the entities with their attributes (usually they are added automatically when you add tables).
When the model is created - save it to App_Data folder of your project (let name it MyModel.xml for example).
For more information about data model and more detailed instructions on how to create it - please read:

1. [About data model](https://korzh.com/easyquery/docs/fundamentals/data-model)
2. [Creating new data model using Data Model Editor](https://korzh.com/easyquery/docs/getting-started/new-data-model)

## 2. Add the references to EasyQuery libraries

Then open your project and add the following assemblies to its References list:

  - Korzh.EasyQuery.NET40
  - Korzh.EasyQuery.Db.NET40
  - Korzh.EasyQuery.WebControls.NET40
  - Korzh.Utils.Db.NET40 (only if you need “Export to CSV/Excel” functionality in your project)

Of course .NET40 suffix here is for .NET 4.0 assemblies. Use assemblies with the suffix which corresponds to the version of target .NET framework for your project ((e.g. .NET35 - for .NET 3.5 or .NET45 - for .NET 4.5).

## 3. Initialize DbModel and DbQuery objects

To avoid creating of DbQuery and DbModel object on each post back we suggest to place them into Session variable.

Example: 

```
using Korzh.EasyQuery;
using Korzh.EasyQuery.Db;
using Korzh.EasyQuery.WebControls;
 
.  .  .  .  .  .  .  .  .  .
 
   protected void Page_Load(Object sender, EventArgs e) 
   { 
      DbQuery query = (DbQuery)Session["QUERY"];
      if (query == null) {  
          //we didn't open this page before
 
          string modelPath = this.MapPath("~/App_Data/MyModel.xml");
 
          Korzh.EasyQuery.DataModel model = new Korzh.EasyQuery.Db.DbModel(); 
          model.LoadFromFile(modelPath); 
 
          query = new Korzh.EasyQuery.Db.DbQuery(); 
          query.Model = model;
 
          query.Formats.SetDefaultFormats(FormatType.MsSqlServer); 
          Session["QUERY"] = query; 
      }
 
      .  .  .  .  .  .  .  .  .  .
   } 
```

## 4. Add QueryPanel and QueryColumnsPanel controls

Drop QueryPanel and QueryColumnsPanel controls on a web form. 

&gt; NB:
You will need to add these controls to a Visual Studio toolbox if you have not done that before. 
To do it - just right-click on the Toolbox panel and select "Choose items..." menu. 
Then find and check all items with Korzh.EasyQuery.WebControls namespace in the dialog that appears (use sorting by namespaces to simplify this task).

You can also add EntitiesPanel and SortColumnsPanel controls as well but it's optional.

After that link, these controls to the DbQuery object created during the previous step. Here how your Page_Load method may look like after this step. 

```
 protected void Page_Load(Object sender, EventArgs e) 
   { 
      .  .  .  .  .  .  .  .  .  .  .
      //the code you've added on step 3
      .  .  .  .  .  .  .  .  .  .  .
 
      QueryPanel1.Query = query;
      QueryColumnsPanel1.Query = QueryPanel1.Query;
 
      //Only if you have placed EntitiesPanel and SortColumnsPanel on your form  
      EntitiesPanel1.Query = QueryPanel1.Query;
      SortColumnsPanel1.Query = QueryPanel1.Query;
   } 
```

Now the query panel is placed on your web page and ready for work. You can run your web page and try to add query conditions and result columns.

## 5. Add code which generates and executes SQL statement

When it's necessary to generate an SQL statement - create an instance of SqlQueryBuilder class and call its BuildSQL() method. Usually, this method is called on some user action (e.g. pressing “Build” button). After that read generated SQL from Result.SQL property of a SqlQueryBuild object.

Finally, you can pass the generated SQL statement to some DataSource (see ResultDS object below) for execution or use it in any other possible way.

Example: 

```
protected void BuildBtn_Click(object sender, EventArgs e) { 
    SqlQueryBuilder builder = new SqlQueryBuilder(QueryPanel1.Query as DbQuery);
    if (builder.CanBuild) {
        builder.BuildSQL();
        ResultDS.SelectCommand = builder.Result.SQL;  
        ResultDS.Select(DataSourceSelectArguments.Empty); //executes the query and shows result. 
    }
} 
```

Here is an example of `ResultDS` definition:

``` 
 &lt;asp:AccessDataSource ID="ResultDS" runat="server" DataFile="~/App_Data/NWind.mdb"&gt;&lt;/asp:AccessDataSource&gt;
```

Please note that the actual type of ResultDS component in your project will depend on database type you are using. </Content>
    <Tags>,asp-net,webforms,data-model,query-panel,get-start,dme,code-sample,</Tags>
  </Article>
  <Article id="fe5e54e3-2ea1-4e6f-a39a-62dc85487993" title="Add an extra condition to your query">
    <Content>It's a quite common situation when the queries generated by EasyQuery components must have an additional condition(s) not visible to end-users. For example, you may need to limit the result set by user ID, department ID or some time frames. EasyQuery provides you with two possible ways of resolving this task: 

## 1. ''BuildSQLEx()'' method of ''SqlQueryBuilder''

To insert additional conditions into generated SQL statements you can use `BuildSQLEx()` function of `SqlQueryBuilder` class (instead of `BuildSQL` you are using by default) and pass necessary condition(s) in its second parameter. The value of that parameter will be added to a result SQL statement at the end of WHERE clause with AND conjunction to conditions, defined by end-users through visual controls.

The only trick here - you may also need to list all tables which take part in that additional condition using `ExtraTables` property of DbQuery class. It's necessary to ensure that all necessary table joins will be included into result SQL.

Example: 

```js
Korzh.EasyQuery.Db.Table table = model.Tables.FindByName("Customers");
query.ExtraTables.Add(table);
 
SqlQueryBuilder builder = new SqlQueryBuilder(query);
builder.BuildSQLEx("", "Customers.CustomerID = 'ALFKI'");
```

## 2. ExtraConditions property of Query class

Since version 3.5.0 of EasyQuery ASP.NET you can use more simple and convenient way of inserting extra conditions: 

```js
query.ExtraConditions.AddSimpleCondition("Customers.CustomerID", "Equal", "ALFKI");
```

Now there is no need to deal with `ExtraTables` or use the exact SQL expression for your additional condition. `AddSimpleCondition` method will take care of everything. 
</Content>
    <Tags>,code-sample,entity-framework,data-model,sql,query-builder,conditions,</Tags>
  </Article>
  <Article id="ff087185-e7b4-4089-bae4-df64fdb69f6a" title="JsonDict class">
    <Content>```csharp
public class Korzh.EasyQuery.JsonDict
    : Dictionary&lt;String, Object&gt;, IDictionary&lt;String, Object&gt;, ICollection&lt;KeyValuePair&lt;String, Object&gt;&gt;, IEnumerable&lt;KeyValuePair&lt;String, Object&gt;&gt;, IEnumerable, IDictionary, ICollection, IReadOnlyDictionary&lt;String, Object&gt;, IReadOnlyCollection&lt;KeyValuePair&lt;String, Object&gt;&gt;, ISerializable, IDeserializationCallback

```

</Content>
    <Tags />
  </Article>
  <Article id="ff0e1a2a-0cda-4b2b-8ae6-28c047242bc0" title="DateTimeValueEditor class">
    <Content>```csharp
public class Korzh.EasyQuery.DateTimeValueEditor
    : ValueEditor, IDefaultValuesStorage

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | DefaultText |  | 
| `String` | DefaultValue |  | 
| `ConstValueList` | DefaultValues |  | 
| `DataType` | SubType |  | 
| `String` | TypeName |  | 
| `String` | XmlDefinition |  | 


### Methods

| Type | Name | Description | 
| --- | --- | --- | 
| `Boolean` | LoadAttribute(`String` attrName, `String` attrValue) |  | 
| `void` | SaveAttributesToXmlWriter(`XmlWriter` writer) |  | 


### Static Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | STypeCaption |  | 
| `String` | STypeName |  | 


</Content>
    <Tags />
  </Article>
  <Article id="ff0fe0c2-9da8-4953-b4af-16fe335bf440" title="EqEntityAttribute class">
    <Content>```csharp
public class Korzh.EasyQuery.EqEntityAttribute
    : Attribute

```

### Properties

| Type | Name | Description | 
| --- | --- | --- | 
| `String` | DisplayName |  | 
| `Boolean` | UseInConditions |  | 
| `Boolean` | UseInResult |  | 
| `Boolean` | UseInSorting |  | 


</Content>
    <Tags />
  </Article>
</Articles>